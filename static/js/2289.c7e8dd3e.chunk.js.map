{"version":3,"file":"static/js/2289.c7e8dd3e.chunk.js","mappings":"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AAM,IAAM,GAAM,IAAM,GAAM,IAAM,GAAM,IAAM,EAAM,IAAM,GAAM,IAAM,IAAM,GAAM,IAAM,IAAM,IAAM,GAAM,GAAM,GAAM,GAAM,IAAM,IAAM,IAAM,IAAM,IAAM,GAAM,GAAM,GAAM,IAAM,GAAM,IAAM,EAAM,IAAM,GAAM,GAAM,IAAM,IAAM,GAAM,IAAM,GAAM,IAAM,IAAM,IAAM,GAAM,IAAM,IAAM,IAAM,IAAM,GAAM,GAAM,IAAM,IAAM,IAAM,IAAM,GAAM,GAAM,IAAM,GAAM,IAAM,GAAM,GAAM,IAAM,IAAM,IAAM,GAAM,IAAM,GAAM,GAAM,IAAM,GAAM,IAAM,GAAM,IAAM,GAAM,GAAM,IAAM,IAAM,GAAM,IAAM,IAAM,GAAM,IAAM,GAAM,GAAM,IAAM,IAAM,GAAM,GAAM,GAAM,GAAM,EAAM,GAAM,GAAM,IAAM,IAAM,IAAM,GAAM,IAAM,IAAM,IAAM,IAAM,IAAM,IAAM,GAAM,IAAM,IAAM,IAAM,GAAM,IAAM,IAAM,GAAM,IAAM,IAAM,IAAM,IAAM,IAAM,EAAM,IAAM,IAAM,GAAM,GAAM,GAAM,IAAM,IAAM,IAAM,IAAM,IAAM,IAAM,GAAM,GAAM,IAAM,IAAM,IAAM,IAAM,GAAM,IAAM,IAAM,GAAM,EAAM,IAAM,GAAM,GAAM,GAAM,GAAM,IAAM,IAAM,IAAM,GAAM,IAAM,IAAM,IAAM,IAAM,GAAM,IAAM,IAAM,IAAM,IAAM,IAAM,GAAM,IAAM,IAAM,IAAM,GAAM,GAAM,IAAM,IAAM,IAAM,IAAM,GAAM,IAAM,IAAM,GAAM,IAAM,GAAM,IAAM,GAAM,GAAM,IAAM,GAAM,IAAM,IAC//CC,EAAI,CAAC,GAAM,EAAM,IAAM,IAAM,GAAM,GAAM,IAAM,GAAM,IAAM,GAAM,IAAM,IAAM,IAAM,IAAM,IAAM,IAAM,IAAM,IAAM,GAAM,IAAM,IAAM,GAAM,IAAM,IAAM,GAAM,IAAM,GAAM,GAAM,IAAM,IAAM,IAAM,IAAM,GAAM,IAAM,IAAM,GAAM,IAAM,IAAM,GAAM,GAAM,IAAM,GAAM,IAAM,GAAM,GAAM,IAAM,IAAM,GAAM,EAAM,GAAM,IAAM,IAAM,GAAM,IAAM,GAAM,IAAM,IAAM,GAAM,IAAM,GAAM,IAAM,IAAM,IAAM,GAAM,IAAM,IAAM,IAAM,IAAM,IAAM,IAAM,IAAM,GAAM,IAAM,IAAM,GAAM,IAAM,GAAM,IAAM,IAAM,IAAM,IAAM,IAAM,GAAM,GAAM,IAAM,IAAM,IAAM,IAAM,GAAM,GAAM,GAAM,GAAM,IAAM,IAAM,IAAM,IAAM,IAAM,IAAM,IAAM,EAAM,IAAM,IAAM,IAAM,GAAM,IAAM,IAAM,GAAM,EAAM,IAAM,IAAM,GAAM,EAAM,IAAM,GAAM,GAAM,IAAM,IAAM,GAAM,GAAM,EAAM,IAAM,IAAM,IAAM,EAAM,EAAM,GAAM,IAAM,IAAM,GAAM,IAAM,GAAM,GAAM,GAAM,IAAM,IAAM,IAAM,IAAM,IAAM,IAAM,IAAM,IAAM,IAAM,IAAM,IAAM,IAAM,IAAM,IAAM,GAAM,IAAM,IAAM,GAAM,IAAM,IAAM,IAAM,GAAM,IAAM,GAAM,IAAM,IAAM,IAAM,GAAM,IAAM,GAAM,IAAM,GAAM,GAAM,IAAM,IAAM,IAAM,IAAM,GAAM,GAAM,IAAM,GAAM,IAAM,GAAM,IAAM,GAAM,GAAM,GAAM,IAAM,IAAM,IAAM,GAAM,IAAM,IAAM,IAAM,IAAM,IAAM,IAAM,GAAM,IAAM,GAAM,IAAM,IAAM,GAAM,IAAM,EAAM,IAAM,GAAM,IAAM,GAAM,GAAM,GAAM,GAAM,IAAM,IAAM,GAAM,GAAM,GAAM,IAAM,IAAM,GAAM,IAAM,GAAM,GAAM,GAAM,IAAM,IAAM,IAAM,IAAM,IAAM,IAAM,IAAM,IAAM,IAAM,GAAM,GAAM,IAAM,GAAM,IAAM,IAAM,IAAM,IAAM,IAAM,GAAM,IAAM,GAAM,IAAM,GAAM,GAAM,GAAM,EAAM,IAAM,IAAM,IAAM,IAAM,GAAM,IAAM,IAAM,GAAM,GAAM,GAAM,GAAM,GAAM,KAG//CC,EAAK,CAAC,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,SAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,UAAY,WAAY,WAAY,WAAY,UAAY,UAAY,UAAY,UAAY,UAAY,UAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,UAAY,WAAY,UAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,EAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,SAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,SAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,UAAY,UAAY,WAAY,WAAY,UAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,UAAY,UAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,SAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,UAAY,UAAY,WAAY,WAAY,UAAY,UAAY,WAAY,WAAY,UAAY,UAAY,UAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,SAAY,WAAY,UAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAC1/FC,EAAK,CAAC,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,SAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,SAAY,WAAY,WAAY,WAAY,UAAY,UAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,UAAY,WAAY,UAAY,WAAY,UAAY,UAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,UAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,EAAY,UAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,SAAY,WAAY,WAAY,WAAY,WAAY,UAAY,UAAY,UAAY,WAAY,WAAY,UAAY,UAAY,UAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,UAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,SAAY,SAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,UAAY,UAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAC1/FC,EAAK,CAAC,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,SAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,UAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,UAAY,SAAY,WAAY,UAAY,WAAY,UAAY,WAAY,SAAY,WAAY,UAAY,UAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,UAAY,WAAY,UAAY,UAAY,UAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,UAAY,WAAY,UAAY,WAAY,WAAY,WAAY,EAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,SAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,UAAY,UAAY,WAAY,WAAY,WAAY,WAAY,UAAY,UAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,UAAY,WAAY,WAAY,UAAY,UAAY,UAAY,WAAY,UAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,UAAY,UAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,SAAY,WAAY,UAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,UAAY,WAAY,WAAY,WAAY,WAC1/FC,EAAK,CAAC,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,SAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,UAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,UAAY,SAAY,WAAY,UAAY,WAAY,UAAY,WAAY,SAAY,WAAY,UAAY,UAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,UAAY,WAAY,UAAY,UAAY,UAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,UAAY,WAAY,UAAY,WAAY,WAAY,WAAY,EAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,SAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,UAAY,UAAY,WAAY,WAAY,WAAY,WAAY,UAAY,UAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,UAAY,WAAY,WAAY,UAAY,UAAY,UAAY,WAAY,UAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,UAAY,UAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,SAAY,WAAY,UAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,UAAY,WAAY,WAAY,WAAY,WAG1/FC,EAAK,CAAC,WAAY,WAAY,UAAY,UAAY,WAAY,UAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,SAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,UAAY,UAAY,SAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,UAAY,WAAY,SAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,SAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,EAAY,UAAY,UAAY,UAAY,WAAY,WAAY,UAAY,WAAY,UAAY,UAAY,WAAY,WAAY,UAAY,UAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,UAAY,UAAY,WAAY,UAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,UAAY,WAAY,UAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,UAAY,UAAY,UAAY,WAAY,UAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,SAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,UAAY,WAAY,UAAY,WAAY,UAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,YAC1/FC,EAAK,CAAC,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,SAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,UAAY,WAAY,WAAY,UAAY,WAAY,WAAY,UAAY,UAAY,SAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,UAAY,WAAY,UAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,SAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,EAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,UAAY,WAAY,UAAY,WAAY,UAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,UAAY,WAAY,WAAY,UAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,UAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,UAAY,UAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,SAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,UAAY,WAAY,UAAY,WAAY,WAAY,UAAY,WAAY,WAAY,UAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,SAAY,WAAY,WAAY,UAAY,WAAY,WAAY,UAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,YAC1/FC,EAAK,CAAC,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,SAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,UAAY,UAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,SAAY,WAAY,WAAY,UAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,UAAY,SAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,UAAY,UAAY,EAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,UAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,UAAY,WAAY,UAAY,WAAY,UAAY,UAAY,WAAY,WAAY,WAAY,UAAY,UAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,UAAY,UAAY,WAAY,UAAY,WAAY,UAAY,UAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,UAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,SAAY,WAAY,WAAY,UAAY,WAAY,WAAY,UAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,UAAY,UAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,UAAY,WAAY,WAAY,SAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,YAC1/FC,EAAK,CAAC,WAAY,WAAY,UAAY,UAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,SAAY,WAAY,UAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,UAAY,SAAY,WAAY,SAAY,UAAY,WAAY,WAAY,UAAY,WAAY,WAAY,SAAY,UAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,EAAY,WAAY,UAAY,UAAY,WAAY,UAAY,WAAY,WAAY,UAAY,UAAY,WAAY,WAAY,UAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,UAAY,UAAY,UAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,SAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,UAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,SAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,UAAY,WAAY,WAAY,UAAY,WAAY,UAAY,WAAY,WAAY,WAAY,UAAY,WAAY,YAG1/FC,EAAK,CAAC,EAAY,UAAY,UAAY,UAAY,UAAY,UAAY,UAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,UAAY,UAAY,SAAY,UAAY,UAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,UAAY,UAAY,SAAY,UAAY,UAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,UAAY,UAAY,UAAY,WAAY,UAAY,UAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,UAAY,UAAY,UAAY,UAAY,UAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,SAAY,UAAY,UAAY,UAAY,WAAY,UAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,SAAY,UAAY,UAAY,UAAY,UAAY,UAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,UAAY,UAAY,UAAY,UAAY,SAAY,UAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,YAC1/FC,EAAK,CAAC,EAAY,UAAY,UAAY,UAAY,UAAY,UAAY,UAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,UAAY,UAAY,WAAY,UAAY,SAAY,UAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,UAAY,UAAY,SAAY,UAAY,UAAY,UAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,UAAY,UAAY,UAAY,UAAY,UAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,UAAY,UAAY,SAAY,UAAY,UAAY,UAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,UAAY,UAAY,UAAY,UAAY,UAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,SAAY,UAAY,UAAY,UAAY,UAAY,UAAY,WAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,UAAY,UAAY,WAAY,UAAY,SAAY,UAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,YAC1/FC,EAAK,CAAC,EAAY,UAAY,UAAY,UAAY,UAAY,UAAY,UAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,SAAY,UAAY,UAAY,UAAY,UAAY,UAAY,UAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,SAAY,UAAY,UAAY,UAAY,UAAY,WAAY,UAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,UAAY,UAAY,UAAY,UAAY,WAAY,UAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,UAAY,UAAY,UAAY,UAAY,UAAY,UAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,SAAY,UAAY,UAAY,WAAY,UAAY,UAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,SAAY,UAAY,UAAY,WAAY,UAAY,UAAY,UAAY,UAAY,SAAY,UAAY,UAAY,UAAY,UAAY,UAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,YAC1/FC,EAAK,CAAC,EAAY,UAAY,UAAY,UAAY,UAAY,UAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,UAAY,UAAY,UAAY,UAAY,UAAY,SAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WA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","sources":["../node_modules/@ethersproject/json-wallets/node_modules/aes-js/index.js","../node_modules/@ethersproject/sha2/src.ts/browser-sha2.ts","../node_modules/@ethersproject/sha2/src.ts/_version.ts","../node_modules/@ethersproject/sha2/src.ts/types.ts","../node_modules/@ethersproject/solidity/src.ts/index.ts","../node_modules/@ethersproject/solidity/src.ts/_version.ts","../node_modules/bech32/index.js","../node_modules/@ethersproject/contracts/node_modules/@ethersproject/abi/src.ts/_version.ts","../node_modules/@ethersproject/contracts/node_modules/@ethersproject/abi/src.ts/coders/abstract-coder.ts","../node_modules/@ethersproject/contracts/node_modules/@ethersproject/abi/src.ts/coders/address.ts","../node_modules/@ethersproject/contracts/node_modules/@ethersproject/abi/src.ts/coders/anonymous.ts","../node_modules/@ethersproject/contracts/node_modules/@ethersproject/abi/src.ts/coders/array.ts","../node_modules/@ethersproject/contracts/node_modules/@ethersproject/abi/src.ts/coders/boolean.ts","../node_modules/@ethersproject/contracts/node_modules/@ethersproject/abi/src.ts/coders/bytes.ts","../node_modules/@ethersproject/contracts/node_modules/@ethersproject/abi/src.ts/coders/fixed-bytes.ts","../node_modules/@ethersproject/contracts/node_modules/@ethersproject/abi/src.ts/coders/null.ts","../node_modules/@ethersproject/contracts/node_modules/@ethersproject/abi/src.ts/coders/number.ts","../node_modules/@ethersproject/contracts/node_modules/@ethersproject/abi/src.ts/coders/string.ts","../node_modules/@ethersproject/contracts/node_modules/@ethersproject/abi/src.ts/coders/tuple.ts","../node_modules/@ethersproject/contracts/node_modules/@ethersproject/abi/src.ts/fragments.ts","../node_modules/@ethersproject/contracts/node_modules/@ethersproject/abi/src.ts/abi-coder.ts","../node_modules/@ethersproject/contracts/node_modules/@ethersproject/abi/src.ts/interface.ts","../node_modules/@ethersproject/abstract-provider/src.ts/index.ts","../node_modules/@ethersproject/abstract-provider/src.ts/_version.ts","../node_modules/@ethersproject/abstract-signer/src.ts/index.ts","../node_modules/@ethersproject/abstract-signer/src.ts/_version.ts","../node_modules/@ethersproject/contracts/src.ts/index.ts","../node_modules/@ethersproject/contracts/src.ts/_version.ts","../node_modules/@ethersproject/bignumber/src.ts/fixednumber.ts","../node_modules/@ethersproject/hash/src.ts/message.ts","../node_modules/@ethersproject/hash/src.ts/_version.ts","../node_modules/@ethersproject/hash/src.ts/typed-data.ts","../node_modules/@ethersproject/basex/src.ts/index.ts","../node_modules/@ethersproject/pbkdf2/src.ts/browser-pbkdf2.ts","../node_modules/@ethersproject/wordlists/src.ts/wordlist.ts","../node_modules/@ethersproject/wordlists/src.ts/_version.ts","../node_modules/@ethersproject/wordlists/src.ts/lang-en.ts","../node_modules/@ethersproject/wordlists/src.ts/browser-wordlists.ts","../node_modules/@ethersproject/hdnode/src.ts/index.ts","../node_modules/@ethersproject/hdnode/src.ts/_version.ts","../node_modules/@ethersproject/random/src.ts/_version.ts","../node_modules/@ethersproject/random/src.ts/browser-random.ts","../node_modules/@ethersproject/json-wallets/src.ts/_version.ts","../node_modules/@ethersproject/json-wallets/src.ts/utils.ts","../node_modules/@ethersproject/json-wallets/src.ts/crowdsale.ts","../node_modules/@ethersproject/json-wallets/src.ts/inspect.ts","../node_modules/@ethersproject/json-wallets/src.ts/keystore.ts","../node_modules/@ethersproject/json-wallets/src.ts/index.ts","../node_modules/@ethersproject/wallet/src.ts/_version.ts","../node_modules/@ethersproject/wallet/src.ts/index.ts","../node_modules/@ethersproject/constants/src.ts/addresses.ts","../node_modules/@ethersproject/constants/src.ts/hashes.ts","../node_modules/@ethersproject/constants/src.ts/strings.ts","../node_modules/@ethersproject/networks/src.ts/index.ts","../node_modules/@ethersproject/networks/src.ts/_version.ts","../node_modules/@ethersproject/strings/src.ts/idna.ts","../node_modules/@ethersproject/hash/src.ts/namehash.ts","../node_modules/@ethersproject/base64/src.ts/browser-base64.ts","../node_modules/@ethersproject/web/src.ts/_version.ts","../node_modules/@ethersproject/web/src.ts/browser-geturl.ts","../node_modules/@ethersproject/web/src.ts/index.ts","../node_modules/@ethersproject/providers/src.ts/_version.ts","../node_modules/@ethersproject/providers/src.ts/formatter.ts","../node_modules/@ethersproject/providers/src.ts/base-provider.ts","../node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts","../node_modules/@ethersproject/providers/src.ts/browser-ws.ts","../node_modules/@ethersproject/providers/src.ts/websocket-provider.ts","../node_modules/@ethersproject/providers/src.ts/url-json-rpc-provider.ts","../node_modules/@ethersproject/providers/src.ts/alchemy-provider.ts","../node_modules/@ethersproject/providers/src.ts/cloudflare-provider.ts","../node_modules/@ethersproject/providers/src.ts/etherscan-provider.ts","../node_modules/@ethersproject/random/src.ts/shuffle.ts","../node_modules/@ethersproject/providers/src.ts/fallback-provider.ts","../node_modules/@ethersproject/providers/src.ts/browser-ipc-provider.ts","../node_modules/@ethersproject/providers/src.ts/infura-provider.ts","../node_modules/@ethersproject/providers/src.ts/json-rpc-batch-provider.ts","../node_modules/@ethersproject/providers/src.ts/nodesmith-provider.ts","../node_modules/@ethersproject/providers/src.ts/pocket-provider.ts","../node_modules/@ethersproject/providers/src.ts/web3-provider.ts","../node_modules/@ethersproject/providers/src.ts/index.ts","../node_modules/@ethersproject/strings/src.ts/bytes32.ts","../node_modules/@ethersproject/units/src.ts/_version.ts","../node_modules/@ethersproject/units/src.ts/index.ts","../node_modules/ethers/src.ts/_version.ts","../node_modules/ethers/src.ts/ethers.ts","../node_modules/ethers/src.ts/index.ts"],"sourcesContent":["\"use strict\";\n\n(function(root) {\n\n    function checkInt(value) {\n        return (parseInt(value) === value);\n    }\n\n    function checkInts(arrayish) {\n        if (!checkInt(arrayish.length)) { return false; }\n\n        for (var i = 0; i < arrayish.length; i++) {\n            if (!checkInt(arrayish[i]) || arrayish[i] < 0 || arrayish[i] > 255) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    function coerceArray(arg, copy) {\n\n        // ArrayBuffer view\n        if (arg.buffer && ArrayBuffer.isView(arg) && arg.name === 'Uint8Array') {\n\n            if (copy) {\n                if (arg.slice) {\n                    arg = arg.slice();\n                } else {\n                    arg = Array.prototype.slice.call(arg);\n                }\n            }\n\n            return arg;\n        }\n\n        // It's an array; check it is a valid representation of a byte\n        if (Array.isArray(arg)) {\n            if (!checkInts(arg)) {\n                throw new Error('Array contains invalid value: ' + arg);\n            }\n\n            return new Uint8Array(arg);\n        }\n\n        // Something else, but behaves like an array (maybe a Buffer? Arguments?)\n        if (checkInt(arg.length) && checkInts(arg)) {\n            return new Uint8Array(arg);\n        }\n\n        throw new Error('unsupported array-like object');\n    }\n\n    function createArray(length) {\n        return new Uint8Array(length);\n    }\n\n    function copyArray(sourceArray, targetArray, targetStart, sourceStart, sourceEnd) {\n        if (sourceStart != null || sourceEnd != null) {\n            if (sourceArray.slice) {\n                sourceArray = sourceArray.slice(sourceStart, sourceEnd);\n            } else {\n                sourceArray = Array.prototype.slice.call(sourceArray, sourceStart, sourceEnd);\n            }\n        }\n        targetArray.set(sourceArray, targetStart);\n    }\n\n\n\n    var convertUtf8 = (function() {\n        function toBytes(text) {\n            var result = [], i = 0;\n            text = encodeURI(text);\n            while (i < text.length) {\n                var c = text.charCodeAt(i++);\n\n                // if it is a % sign, encode the following 2 bytes as a hex value\n                if (c === 37) {\n                    result.push(parseInt(text.substr(i, 2), 16))\n                    i += 2;\n\n                // otherwise, just the actual byte\n                } else {\n                    result.push(c)\n                }\n            }\n\n            return coerceArray(result);\n        }\n\n        function fromBytes(bytes) {\n            var result = [], i = 0;\n\n            while (i < bytes.length) {\n                var c = bytes[i];\n\n                if (c < 128) {\n                    result.push(String.fromCharCode(c));\n                    i++;\n                } else if (c > 191 && c < 224) {\n                    result.push(String.fromCharCode(((c & 0x1f) << 6) | (bytes[i + 1] & 0x3f)));\n                    i += 2;\n                } else {\n                    result.push(String.fromCharCode(((c & 0x0f) << 12) | ((bytes[i + 1] & 0x3f) << 6) | (bytes[i + 2] & 0x3f)));\n                    i += 3;\n                }\n            }\n\n            return result.join('');\n        }\n\n        return {\n            toBytes: toBytes,\n            fromBytes: fromBytes,\n        }\n    })();\n\n    var convertHex = (function() {\n        function toBytes(text) {\n            var result = [];\n            for (var i = 0; i < text.length; i += 2) {\n                result.push(parseInt(text.substr(i, 2), 16));\n            }\n\n            return result;\n        }\n\n        // http://ixti.net/development/javascript/2011/11/11/base64-encodedecode-of-utf8-in-browser-with-js.html\n        var Hex = '0123456789abcdef';\n\n        function fromBytes(bytes) {\n                var result = [];\n                for (var i = 0; i < bytes.length; i++) {\n                    var v = bytes[i];\n                    result.push(Hex[(v & 0xf0) >> 4] + Hex[v & 0x0f]);\n                }\n                return result.join('');\n        }\n\n        return {\n            toBytes: toBytes,\n            fromBytes: fromBytes,\n        }\n    })();\n\n\n    // Number of rounds by keysize\n    var numberOfRounds = {16: 10, 24: 12, 32: 14}\n\n    // Round constant words\n    var rcon = [0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91];\n\n    // S-box and Inverse S-box (S is for Substitution)\n    var S = [0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16];\n    var Si =[0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d];\n\n    // Transformations for encryption\n    var T1 = [0xc66363a5, 0xf87c7c84, 0xee777799, 0xf67b7b8d, 0xfff2f20d, 0xd66b6bbd, 0xde6f6fb1, 0x91c5c554, 0x60303050, 0x02010103, 0xce6767a9, 0x562b2b7d, 0xe7fefe19, 0xb5d7d762, 0x4dababe6, 0xec76769a, 0x8fcaca45, 0x1f82829d, 0x89c9c940, 0xfa7d7d87, 0xeffafa15, 0xb25959eb, 0x8e4747c9, 0xfbf0f00b, 0x41adadec, 0xb3d4d467, 0x5fa2a2fd, 0x45afafea, 0x239c9cbf, 0x53a4a4f7, 0xe4727296, 0x9bc0c05b, 0x75b7b7c2, 0xe1fdfd1c, 0x3d9393ae, 0x4c26266a, 0x6c36365a, 0x7e3f3f41, 0xf5f7f702, 0x83cccc4f, 0x6834345c, 0x51a5a5f4, 0xd1e5e534, 0xf9f1f108, 0xe2717193, 0xabd8d873, 0x62313153, 0x2a15153f, 0x0804040c, 0x95c7c752, 0x46232365, 0x9dc3c35e, 0x30181828, 0x379696a1, 0x0a05050f, 0x2f9a9ab5, 0x0e070709, 0x24121236, 0x1b80809b, 0xdfe2e23d, 0xcdebeb26, 0x4e272769, 0x7fb2b2cd, 0xea75759f, 0x1209091b, 0x1d83839e, 0x582c2c74, 0x341a1a2e, 0x361b1b2d, 0xdc6e6eb2, 0xb45a5aee, 0x5ba0a0fb, 0xa45252f6, 0x763b3b4d, 0xb7d6d661, 0x7db3b3ce, 0x5229297b, 0xdde3e33e, 0x5e2f2f71, 0x13848497, 0xa65353f5, 0xb9d1d168, 0x00000000, 0xc1eded2c, 0x40202060, 0xe3fcfc1f, 0x79b1b1c8, 0xb65b5bed, 0xd46a6abe, 0x8dcbcb46, 0x67bebed9, 0x7239394b, 0x944a4ade, 0x984c4cd4, 0xb05858e8, 0x85cfcf4a, 0xbbd0d06b, 0xc5efef2a, 0x4faaaae5, 0xedfbfb16, 0x864343c5, 0x9a4d4dd7, 0x66333355, 0x11858594, 0x8a4545cf, 0xe9f9f910, 0x04020206, 0xfe7f7f81, 0xa05050f0, 0x783c3c44, 0x259f9fba, 0x4ba8a8e3, 0xa25151f3, 0x5da3a3fe, 0x804040c0, 0x058f8f8a, 0x3f9292ad, 0x219d9dbc, 0x70383848, 0xf1f5f504, 0x63bcbcdf, 0x77b6b6c1, 0xafdada75, 0x42212163, 0x20101030, 0xe5ffff1a, 0xfdf3f30e, 0xbfd2d26d, 0x81cdcd4c, 0x180c0c14, 0x26131335, 0xc3ecec2f, 0xbe5f5fe1, 0x359797a2, 0x884444cc, 0x2e171739, 0x93c4c457, 0x55a7a7f2, 0xfc7e7e82, 0x7a3d3d47, 0xc86464ac, 0xba5d5de7, 0x3219192b, 0xe6737395, 0xc06060a0, 0x19818198, 0x9e4f4fd1, 0xa3dcdc7f, 0x44222266, 0x542a2a7e, 0x3b9090ab, 0x0b888883, 0x8c4646ca, 0xc7eeee29, 0x6bb8b8d3, 0x2814143c, 0xa7dede79, 0xbc5e5ee2, 0x160b0b1d, 0xaddbdb76, 0xdbe0e03b, 0x64323256, 0x743a3a4e, 0x140a0a1e, 0x924949db, 0x0c06060a, 0x4824246c, 0xb85c5ce4, 0x9fc2c25d, 0xbdd3d36e, 0x43acacef, 0xc46262a6, 0x399191a8, 0x319595a4, 0xd3e4e437, 0xf279798b, 0xd5e7e732, 0x8bc8c843, 0x6e373759, 0xda6d6db7, 0x018d8d8c, 0xb1d5d564, 0x9c4e4ed2, 0x49a9a9e0, 0xd86c6cb4, 0xac5656fa, 0xf3f4f407, 0xcfeaea25, 0xca6565af, 0xf47a7a8e, 0x47aeaee9, 0x10080818, 0x6fbabad5, 0xf0787888, 0x4a25256f, 0x5c2e2e72, 0x381c1c24, 0x57a6a6f1, 0x73b4b4c7, 0x97c6c651, 0xcbe8e823, 0xa1dddd7c, 0xe874749c, 0x3e1f1f21, 0x964b4bdd, 0x61bdbddc, 0x0d8b8b86, 0x0f8a8a85, 0xe0707090, 0x7c3e3e42, 0x71b5b5c4, 0xcc6666aa, 0x904848d8, 0x06030305, 0xf7f6f601, 0x1c0e0e12, 0xc26161a3, 0x6a35355f, 0xae5757f9, 0x69b9b9d0, 0x17868691, 0x99c1c158, 0x3a1d1d27, 0x279e9eb9, 0xd9e1e138, 0xebf8f813, 0x2b9898b3, 0x22111133, 0xd26969bb, 0xa9d9d970, 0x078e8e89, 0x339494a7, 0x2d9b9bb6, 0x3c1e1e22, 0x15878792, 0xc9e9e920, 0x87cece49, 0xaa5555ff, 0x50282878, 0xa5dfdf7a, 0x038c8c8f, 0x59a1a1f8, 0x09898980, 0x1a0d0d17, 0x65bfbfda, 0xd7e6e631, 0x844242c6, 0xd06868b8, 0x824141c3, 0x299999b0, 0x5a2d2d77, 0x1e0f0f11, 0x7bb0b0cb, 0xa85454fc, 0x6dbbbbd6, 0x2c16163a];\n    var T2 = [0xa5c66363, 0x84f87c7c, 0x99ee7777, 0x8df67b7b, 0x0dfff2f2, 0xbdd66b6b, 0xb1de6f6f, 0x5491c5c5, 0x50603030, 0x03020101, 0xa9ce6767, 0x7d562b2b, 0x19e7fefe, 0x62b5d7d7, 0xe64dabab, 0x9aec7676, 0x458fcaca, 0x9d1f8282, 0x4089c9c9, 0x87fa7d7d, 0x15effafa, 0xebb25959, 0xc98e4747, 0x0bfbf0f0, 0xec41adad, 0x67b3d4d4, 0xfd5fa2a2, 0xea45afaf, 0xbf239c9c, 0xf753a4a4, 0x96e47272, 0x5b9bc0c0, 0xc275b7b7, 0x1ce1fdfd, 0xae3d9393, 0x6a4c2626, 0x5a6c3636, 0x417e3f3f, 0x02f5f7f7, 0x4f83cccc, 0x5c683434, 0xf451a5a5, 0x34d1e5e5, 0x08f9f1f1, 0x93e27171, 0x73abd8d8, 0x53623131, 0x3f2a1515, 0x0c080404, 0x5295c7c7, 0x65462323, 0x5e9dc3c3, 0x28301818, 0xa1379696, 0x0f0a0505, 0xb52f9a9a, 0x090e0707, 0x36241212, 0x9b1b8080, 0x3ddfe2e2, 0x26cdebeb, 0x694e2727, 0xcd7fb2b2, 0x9fea7575, 0x1b120909, 0x9e1d8383, 0x74582c2c, 0x2e341a1a, 0x2d361b1b, 0xb2dc6e6e, 0xeeb45a5a, 0xfb5ba0a0, 0xf6a45252, 0x4d763b3b, 0x61b7d6d6, 0xce7db3b3, 0x7b522929, 0x3edde3e3, 0x715e2f2f, 0x97138484, 0xf5a65353, 0x68b9d1d1, 0x00000000, 0x2cc1eded, 0x60402020, 0x1fe3fcfc, 0xc879b1b1, 0xedb65b5b, 0xbed46a6a, 0x468dcbcb, 0xd967bebe, 0x4b723939, 0xde944a4a, 0xd4984c4c, 0xe8b05858, 0x4a85cfcf, 0x6bbbd0d0, 0x2ac5efef, 0xe54faaaa, 0x16edfbfb, 0xc5864343, 0xd79a4d4d, 0x55663333, 0x94118585, 0xcf8a4545, 0x10e9f9f9, 0x06040202, 0x81fe7f7f, 0xf0a05050, 0x44783c3c, 0xba259f9f, 0xe34ba8a8, 0xf3a25151, 0xfe5da3a3, 0xc0804040, 0x8a058f8f, 0xad3f9292, 0xbc219d9d, 0x48703838, 0x04f1f5f5, 0xdf63bcbc, 0xc177b6b6, 0x75afdada, 0x63422121, 0x30201010, 0x1ae5ffff, 0x0efdf3f3, 0x6dbfd2d2, 0x4c81cdcd, 0x14180c0c, 0x35261313, 0x2fc3ecec, 0xe1be5f5f, 0xa2359797, 0xcc884444, 0x392e1717, 0x5793c4c4, 0xf255a7a7, 0x82fc7e7e, 0x477a3d3d, 0xacc86464, 0xe7ba5d5d, 0x2b321919, 0x95e67373, 0xa0c06060, 0x98198181, 0xd19e4f4f, 0x7fa3dcdc, 0x66442222, 0x7e542a2a, 0xab3b9090, 0x830b8888, 0xca8c4646, 0x29c7eeee, 0xd36bb8b8, 0x3c281414, 0x79a7dede, 0xe2bc5e5e, 0x1d160b0b, 0x76addbdb, 0x3bdbe0e0, 0x56643232, 0x4e743a3a, 0x1e140a0a, 0xdb924949, 0x0a0c0606, 0x6c482424, 0xe4b85c5c, 0x5d9fc2c2, 0x6ebdd3d3, 0xef43acac, 0xa6c46262, 0xa8399191, 0xa4319595, 0x37d3e4e4, 0x8bf27979, 0x32d5e7e7, 0x438bc8c8, 0x596e3737, 0xb7da6d6d, 0x8c018d8d, 0x64b1d5d5, 0xd29c4e4e, 0xe049a9a9, 0xb4d86c6c, 0xfaac5656, 0x07f3f4f4, 0x25cfeaea, 0xafca6565, 0x8ef47a7a, 0xe947aeae, 0x18100808, 0xd56fbaba, 0x88f07878, 0x6f4a2525, 0x725c2e2e, 0x24381c1c, 0xf157a6a6, 0xc773b4b4, 0x5197c6c6, 0x23cbe8e8, 0x7ca1dddd, 0x9ce87474, 0x213e1f1f, 0xdd964b4b, 0xdc61bdbd, 0x860d8b8b, 0x850f8a8a, 0x90e07070, 0x427c3e3e, 0xc471b5b5, 0xaacc6666, 0xd8904848, 0x05060303, 0x01f7f6f6, 0x121c0e0e, 0xa3c26161, 0x5f6a3535, 0xf9ae5757, 0xd069b9b9, 0x91178686, 0x5899c1c1, 0x273a1d1d, 0xb9279e9e, 0x38d9e1e1, 0x13ebf8f8, 0xb32b9898, 0x33221111, 0xbbd26969, 0x70a9d9d9, 0x89078e8e, 0xa7339494, 0xb62d9b9b, 0x223c1e1e, 0x92158787, 0x20c9e9e9, 0x4987cece, 0xffaa5555, 0x78502828, 0x7aa5dfdf, 0x8f038c8c, 0xf859a1a1, 0x80098989, 0x171a0d0d, 0xda65bfbf, 0x31d7e6e6, 0xc6844242, 0xb8d06868, 0xc3824141, 0xb0299999, 0x775a2d2d, 0x111e0f0f, 0xcb7bb0b0, 0xfca85454, 0xd66dbbbb, 0x3a2c1616];\n    var T3 = [0x63a5c663, 0x7c84f87c, 0x7799ee77, 0x7b8df67b, 0xf20dfff2, 0x6bbdd66b, 0x6fb1de6f, 0xc55491c5, 0x30506030, 0x01030201, 0x67a9ce67, 0x2b7d562b, 0xfe19e7fe, 0xd762b5d7, 0xabe64dab, 0x769aec76, 0xca458fca, 0x829d1f82, 0xc94089c9, 0x7d87fa7d, 0xfa15effa, 0x59ebb259, 0x47c98e47, 0xf00bfbf0, 0xadec41ad, 0xd467b3d4, 0xa2fd5fa2, 0xafea45af, 0x9cbf239c, 0xa4f753a4, 0x7296e472, 0xc05b9bc0, 0xb7c275b7, 0xfd1ce1fd, 0x93ae3d93, 0x266a4c26, 0x365a6c36, 0x3f417e3f, 0xf702f5f7, 0xcc4f83cc, 0x345c6834, 0xa5f451a5, 0xe534d1e5, 0xf108f9f1, 0x7193e271, 0xd873abd8, 0x31536231, 0x153f2a15, 0x040c0804, 0xc75295c7, 0x23654623, 0xc35e9dc3, 0x18283018, 0x96a13796, 0x050f0a05, 0x9ab52f9a, 0x07090e07, 0x12362412, 0x809b1b80, 0xe23ddfe2, 0xeb26cdeb, 0x27694e27, 0xb2cd7fb2, 0x759fea75, 0x091b1209, 0x839e1d83, 0x2c74582c, 0x1a2e341a, 0x1b2d361b, 0x6eb2dc6e, 0x5aeeb45a, 0xa0fb5ba0, 0x52f6a452, 0x3b4d763b, 0xd661b7d6, 0xb3ce7db3, 0x297b5229, 0xe33edde3, 0x2f715e2f, 0x84971384, 0x53f5a653, 0xd168b9d1, 0x00000000, 0xed2cc1ed, 0x20604020, 0xfc1fe3fc, 0xb1c879b1, 0x5bedb65b, 0x6abed46a, 0xcb468dcb, 0xbed967be, 0x394b7239, 0x4ade944a, 0x4cd4984c, 0x58e8b058, 0xcf4a85cf, 0xd06bbbd0, 0xef2ac5ef, 0xaae54faa, 0xfb16edfb, 0x43c58643, 0x4dd79a4d, 0x33556633, 0x85941185, 0x45cf8a45, 0xf910e9f9, 0x02060402, 0x7f81fe7f, 0x50f0a050, 0x3c44783c, 0x9fba259f, 0xa8e34ba8, 0x51f3a251, 0xa3fe5da3, 0x40c08040, 0x8f8a058f, 0x92ad3f92, 0x9dbc219d, 0x38487038, 0xf504f1f5, 0xbcdf63bc, 0xb6c177b6, 0xda75afda, 0x21634221, 0x10302010, 0xff1ae5ff, 0xf30efdf3, 0xd26dbfd2, 0xcd4c81cd, 0x0c14180c, 0x13352613, 0xec2fc3ec, 0x5fe1be5f, 0x97a23597, 0x44cc8844, 0x17392e17, 0xc45793c4, 0xa7f255a7, 0x7e82fc7e, 0x3d477a3d, 0x64acc864, 0x5de7ba5d, 0x192b3219, 0x7395e673, 0x60a0c060, 0x81981981, 0x4fd19e4f, 0xdc7fa3dc, 0x22664422, 0x2a7e542a, 0x90ab3b90, 0x88830b88, 0x46ca8c46, 0xee29c7ee, 0xb8d36bb8, 0x143c2814, 0xde79a7de, 0x5ee2bc5e, 0x0b1d160b, 0xdb76addb, 0xe03bdbe0, 0x32566432, 0x3a4e743a, 0x0a1e140a, 0x49db9249, 0x060a0c06, 0x246c4824, 0x5ce4b85c, 0xc25d9fc2, 0xd36ebdd3, 0xacef43ac, 0x62a6c462, 0x91a83991, 0x95a43195, 0xe437d3e4, 0x798bf279, 0xe732d5e7, 0xc8438bc8, 0x37596e37, 0x6db7da6d, 0x8d8c018d, 0xd564b1d5, 0x4ed29c4e, 0xa9e049a9, 0x6cb4d86c, 0x56faac56, 0xf407f3f4, 0xea25cfea, 0x65afca65, 0x7a8ef47a, 0xaee947ae, 0x08181008, 0xbad56fba, 0x7888f078, 0x256f4a25, 0x2e725c2e, 0x1c24381c, 0xa6f157a6, 0xb4c773b4, 0xc65197c6, 0xe823cbe8, 0xdd7ca1dd, 0x749ce874, 0x1f213e1f, 0x4bdd964b, 0xbddc61bd, 0x8b860d8b, 0x8a850f8a, 0x7090e070, 0x3e427c3e, 0xb5c471b5, 0x66aacc66, 0x48d89048, 0x03050603, 0xf601f7f6, 0x0e121c0e, 0x61a3c261, 0x355f6a35, 0x57f9ae57, 0xb9d069b9, 0x86911786, 0xc15899c1, 0x1d273a1d, 0x9eb9279e, 0xe138d9e1, 0xf813ebf8, 0x98b32b98, 0x11332211, 0x69bbd269, 0xd970a9d9, 0x8e89078e, 0x94a73394, 0x9bb62d9b, 0x1e223c1e, 0x87921587, 0xe920c9e9, 0xce4987ce, 0x55ffaa55, 0x28785028, 0xdf7aa5df, 0x8c8f038c, 0xa1f859a1, 0x89800989, 0x0d171a0d, 0xbfda65bf, 0xe631d7e6, 0x42c68442, 0x68b8d068, 0x41c38241, 0x99b02999, 0x2d775a2d, 0x0f111e0f, 0xb0cb7bb0, 0x54fca854, 0xbbd66dbb, 0x163a2c16];\n    var T4 = [0x6363a5c6, 0x7c7c84f8, 0x777799ee, 0x7b7b8df6, 0xf2f20dff, 0x6b6bbdd6, 0x6f6fb1de, 0xc5c55491, 0x30305060, 0x01010302, 0x6767a9ce, 0x2b2b7d56, 0xfefe19e7, 0xd7d762b5, 0xababe64d, 0x76769aec, 0xcaca458f, 0x82829d1f, 0xc9c94089, 0x7d7d87fa, 0xfafa15ef, 0x5959ebb2, 0x4747c98e, 0xf0f00bfb, 0xadadec41, 0xd4d467b3, 0xa2a2fd5f, 0xafafea45, 0x9c9cbf23, 0xa4a4f753, 0x727296e4, 0xc0c05b9b, 0xb7b7c275, 0xfdfd1ce1, 0x9393ae3d, 0x26266a4c, 0x36365a6c, 0x3f3f417e, 0xf7f702f5, 0xcccc4f83, 0x34345c68, 0xa5a5f451, 0xe5e534d1, 0xf1f108f9, 0x717193e2, 0xd8d873ab, 0x31315362, 0x15153f2a, 0x04040c08, 0xc7c75295, 0x23236546, 0xc3c35e9d, 0x18182830, 0x9696a137, 0x05050f0a, 0x9a9ab52f, 0x0707090e, 0x12123624, 0x80809b1b, 0xe2e23ddf, 0xebeb26cd, 0x2727694e, 0xb2b2cd7f, 0x75759fea, 0x09091b12, 0x83839e1d, 0x2c2c7458, 0x1a1a2e34, 0x1b1b2d36, 0x6e6eb2dc, 0x5a5aeeb4, 0xa0a0fb5b, 0x5252f6a4, 0x3b3b4d76, 0xd6d661b7, 0xb3b3ce7d, 0x29297b52, 0xe3e33edd, 0x2f2f715e, 0x84849713, 0x5353f5a6, 0xd1d168b9, 0x00000000, 0xeded2cc1, 0x20206040, 0xfcfc1fe3, 0xb1b1c879, 0x5b5bedb6, 0x6a6abed4, 0xcbcb468d, 0xbebed967, 0x39394b72, 0x4a4ade94, 0x4c4cd498, 0x5858e8b0, 0xcfcf4a85, 0xd0d06bbb, 0xefef2ac5, 0xaaaae54f, 0xfbfb16ed, 0x4343c586, 0x4d4dd79a, 0x33335566, 0x85859411, 0x4545cf8a, 0xf9f910e9, 0x02020604, 0x7f7f81fe, 0x5050f0a0, 0x3c3c4478, 0x9f9fba25, 0xa8a8e34b, 0x5151f3a2, 0xa3a3fe5d, 0x4040c080, 0x8f8f8a05, 0x9292ad3f, 0x9d9dbc21, 0x38384870, 0xf5f504f1, 0xbcbcdf63, 0xb6b6c177, 0xdada75af, 0x21216342, 0x10103020, 0xffff1ae5, 0xf3f30efd, 0xd2d26dbf, 0xcdcd4c81, 0x0c0c1418, 0x13133526, 0xecec2fc3, 0x5f5fe1be, 0x9797a235, 0x4444cc88, 0x1717392e, 0xc4c45793, 0xa7a7f255, 0x7e7e82fc, 0x3d3d477a, 0x6464acc8, 0x5d5de7ba, 0x19192b32, 0x737395e6, 0x6060a0c0, 0x81819819, 0x4f4fd19e, 0xdcdc7fa3, 0x22226644, 0x2a2a7e54, 0x9090ab3b, 0x8888830b, 0x4646ca8c, 0xeeee29c7, 0xb8b8d36b, 0x14143c28, 0xdede79a7, 0x5e5ee2bc, 0x0b0b1d16, 0xdbdb76ad, 0xe0e03bdb, 0x32325664, 0x3a3a4e74, 0x0a0a1e14, 0x4949db92, 0x06060a0c, 0x24246c48, 0x5c5ce4b8, 0xc2c25d9f, 0xd3d36ebd, 0xacacef43, 0x6262a6c4, 0x9191a839, 0x9595a431, 0xe4e437d3, 0x79798bf2, 0xe7e732d5, 0xc8c8438b, 0x3737596e, 0x6d6db7da, 0x8d8d8c01, 0xd5d564b1, 0x4e4ed29c, 0xa9a9e049, 0x6c6cb4d8, 0x5656faac, 0xf4f407f3, 0xeaea25cf, 0x6565afca, 0x7a7a8ef4, 0xaeaee947, 0x08081810, 0xbabad56f, 0x787888f0, 0x25256f4a, 0x2e2e725c, 0x1c1c2438, 0xa6a6f157, 0xb4b4c773, 0xc6c65197, 0xe8e823cb, 0xdddd7ca1, 0x74749ce8, 0x1f1f213e, 0x4b4bdd96, 0xbdbddc61, 0x8b8b860d, 0x8a8a850f, 0x707090e0, 0x3e3e427c, 0xb5b5c471, 0x6666aacc, 0x4848d890, 0x03030506, 0xf6f601f7, 0x0e0e121c, 0x6161a3c2, 0x35355f6a, 0x5757f9ae, 0xb9b9d069, 0x86869117, 0xc1c15899, 0x1d1d273a, 0x9e9eb927, 0xe1e138d9, 0xf8f813eb, 0x9898b32b, 0x11113322, 0x6969bbd2, 0xd9d970a9, 0x8e8e8907, 0x9494a733, 0x9b9bb62d, 0x1e1e223c, 0x87879215, 0xe9e920c9, 0xcece4987, 0x5555ffaa, 0x28287850, 0xdfdf7aa5, 0x8c8c8f03, 0xa1a1f859, 0x89898009, 0x0d0d171a, 0xbfbfda65, 0xe6e631d7, 0x4242c684, 0x6868b8d0, 0x4141c382, 0x9999b029, 0x2d2d775a, 0x0f0f111e, 0xb0b0cb7b, 0x5454fca8, 0xbbbbd66d, 0x16163a2c];\n\n    // Transformations for decryption\n    var T5 = [0x51f4a750, 0x7e416553, 0x1a17a4c3, 0x3a275e96, 0x3bab6bcb, 0x1f9d45f1, 0xacfa58ab, 0x4be30393, 0x2030fa55, 0xad766df6, 0x88cc7691, 0xf5024c25, 0x4fe5d7fc, 0xc52acbd7, 0x26354480, 0xb562a38f, 0xdeb15a49, 0x25ba1b67, 0x45ea0e98, 0x5dfec0e1, 0xc32f7502, 0x814cf012, 0x8d4697a3, 0x6bd3f9c6, 0x038f5fe7, 0x15929c95, 0xbf6d7aeb, 0x955259da, 0xd4be832d, 0x587421d3, 0x49e06929, 0x8ec9c844, 0x75c2896a, 0xf48e7978, 0x99583e6b, 0x27b971dd, 0xbee14fb6, 0xf088ad17, 0xc920ac66, 0x7dce3ab4, 0x63df4a18, 0xe51a3182, 0x97513360, 0x62537f45, 0xb16477e0, 0xbb6bae84, 0xfe81a01c, 0xf9082b94, 0x70486858, 0x8f45fd19, 0x94de6c87, 0x527bf8b7, 0xab73d323, 0x724b02e2, 0xe31f8f57, 0x6655ab2a, 0xb2eb2807, 0x2fb5c203, 0x86c57b9a, 0xd33708a5, 0x302887f2, 0x23bfa5b2, 0x02036aba, 0xed16825c, 0x8acf1c2b, 0xa779b492, 0xf307f2f0, 0x4e69e2a1, 0x65daf4cd, 0x0605bed5, 0xd134621f, 0xc4a6fe8a, 0x342e539d, 0xa2f355a0, 0x058ae132, 0xa4f6eb75, 0x0b83ec39, 0x4060efaa, 0x5e719f06, 0xbd6e1051, 0x3e218af9, 0x96dd063d, 0xdd3e05ae, 0x4de6bd46, 0x91548db5, 0x71c45d05, 0x0406d46f, 0x605015ff, 0x1998fb24, 0xd6bde997, 0x894043cc, 0x67d99e77, 0xb0e842bd, 0x07898b88, 0xe7195b38, 0x79c8eedb, 0xa17c0a47, 0x7c420fe9, 0xf8841ec9, 0x00000000, 0x09808683, 0x322bed48, 0x1e1170ac, 0x6c5a724e, 0xfd0efffb, 0x0f853856, 0x3daed51e, 0x362d3927, 0x0a0fd964, 0x685ca621, 0x9b5b54d1, 0x24362e3a, 0x0c0a67b1, 0x9357e70f, 0xb4ee96d2, 0x1b9b919e, 0x80c0c54f, 0x61dc20a2, 0x5a774b69, 0x1c121a16, 0xe293ba0a, 0xc0a02ae5, 0x3c22e043, 0x121b171d, 0x0e090d0b, 0xf28bc7ad, 0x2db6a8b9, 0x141ea9c8, 0x57f11985, 0xaf75074c, 0xee99ddbb, 0xa37f60fd, 0xf701269f, 0x5c72f5bc, 0x44663bc5, 0x5bfb7e34, 0x8b432976, 0xcb23c6dc, 0xb6edfc68, 0xb8e4f163, 0xd731dcca, 0x42638510, 0x13972240, 0x84c61120, 0x854a247d, 0xd2bb3df8, 0xaef93211, 0xc729a16d, 0x1d9e2f4b, 0xdcb230f3, 0x0d8652ec, 0x77c1e3d0, 0x2bb3166c, 0xa970b999, 0x119448fa, 0x47e96422, 0xa8fc8cc4, 0xa0f03f1a, 0x567d2cd8, 0x223390ef, 0x87494ec7, 0xd938d1c1, 0x8ccaa2fe, 0x98d40b36, 0xa6f581cf, 0xa57ade28, 0xdab78e26, 0x3fadbfa4, 0x2c3a9de4, 0x5078920d, 0x6a5fcc9b, 0x547e4662, 0xf68d13c2, 0x90d8b8e8, 0x2e39f75e, 0x82c3aff5, 0x9f5d80be, 0x69d0937c, 0x6fd52da9, 0xcf2512b3, 0xc8ac993b, 0x10187da7, 0xe89c636e, 0xdb3bbb7b, 0xcd267809, 0x6e5918f4, 0xec9ab701, 0x834f9aa8, 0xe6956e65, 0xaaffe67e, 0x21bccf08, 0xef15e8e6, 0xbae79bd9, 0x4a6f36ce, 0xea9f09d4, 0x29b07cd6, 0x31a4b2af, 0x2a3f2331, 0xc6a59430, 0x35a266c0, 0x744ebc37, 0xfc82caa6, 0xe090d0b0, 0x33a7d815, 0xf104984a, 0x41ecdaf7, 0x7fcd500e, 0x1791f62f, 0x764dd68d, 0x43efb04d, 0xccaa4d54, 0xe49604df, 0x9ed1b5e3, 0x4c6a881b, 0xc12c1fb8, 0x4665517f, 0x9d5eea04, 0x018c355d, 0xfa877473, 0xfb0b412e, 0xb3671d5a, 0x92dbd252, 0xe9105633, 0x6dd64713, 0x9ad7618c, 0x37a10c7a, 0x59f8148e, 0xeb133c89, 0xcea927ee, 0xb761c935, 0xe11ce5ed, 0x7a47b13c, 0x9cd2df59, 0x55f2733f, 0x1814ce79, 0x73c737bf, 0x53f7cdea, 0x5ffdaa5b, 0xdf3d6f14, 0x7844db86, 0xcaaff381, 0xb968c43e, 0x3824342c, 0xc2a3405f, 0x161dc372, 0xbce2250c, 0x283c498b, 0xff0d9541, 0x39a80171, 0x080cb3de, 0xd8b4e49c, 0x6456c190, 0x7bcb8461, 0xd532b670, 0x486c5c74, 0xd0b85742];\n    var T6 = [0x5051f4a7, 0x537e4165, 0xc31a17a4, 0x963a275e, 0xcb3bab6b, 0xf11f9d45, 0xabacfa58, 0x934be303, 0x552030fa, 0xf6ad766d, 0x9188cc76, 0x25f5024c, 0xfc4fe5d7, 0xd7c52acb, 0x80263544, 0x8fb562a3, 0x49deb15a, 0x6725ba1b, 0x9845ea0e, 0xe15dfec0, 0x02c32f75, 0x12814cf0, 0xa38d4697, 0xc66bd3f9, 0xe7038f5f, 0x9515929c, 0xebbf6d7a, 0xda955259, 0x2dd4be83, 0xd3587421, 0x2949e069, 0x448ec9c8, 0x6a75c289, 0x78f48e79, 0x6b99583e, 0xdd27b971, 0xb6bee14f, 0x17f088ad, 0x66c920ac, 0xb47dce3a, 0x1863df4a, 0x82e51a31, 0x60975133, 0x4562537f, 0xe0b16477, 0x84bb6bae, 0x1cfe81a0, 0x94f9082b, 0x58704868, 0x198f45fd, 0x8794de6c, 0xb7527bf8, 0x23ab73d3, 0xe2724b02, 0x57e31f8f, 0x2a6655ab, 0x07b2eb28, 0x032fb5c2, 0x9a86c57b, 0xa5d33708, 0xf2302887, 0xb223bfa5, 0xba02036a, 0x5ced1682, 0x2b8acf1c, 0x92a779b4, 0xf0f307f2, 0xa14e69e2, 0xcd65daf4, 0xd50605be, 0x1fd13462, 0x8ac4a6fe, 0x9d342e53, 0xa0a2f355, 0x32058ae1, 0x75a4f6eb, 0x390b83ec, 0xaa4060ef, 0x065e719f, 0x51bd6e10, 0xf93e218a, 0x3d96dd06, 0xaedd3e05, 0x464de6bd, 0xb591548d, 0x0571c45d, 0x6f0406d4, 0xff605015, 0x241998fb, 0x97d6bde9, 0xcc894043, 0x7767d99e, 0xbdb0e842, 0x8807898b, 0x38e7195b, 0xdb79c8ee, 0x47a17c0a, 0xe97c420f, 0xc9f8841e, 0x00000000, 0x83098086, 0x48322bed, 0xac1e1170, 0x4e6c5a72, 0xfbfd0eff, 0x560f8538, 0x1e3daed5, 0x27362d39, 0x640a0fd9, 0x21685ca6, 0xd19b5b54, 0x3a24362e, 0xb10c0a67, 0x0f9357e7, 0xd2b4ee96, 0x9e1b9b91, 0x4f80c0c5, 0xa261dc20, 0x695a774b, 0x161c121a, 0x0ae293ba, 0xe5c0a02a, 0x433c22e0, 0x1d121b17, 0x0b0e090d, 0xadf28bc7, 0xb92db6a8, 0xc8141ea9, 0x8557f119, 0x4caf7507, 0xbbee99dd, 0xfda37f60, 0x9ff70126, 0xbc5c72f5, 0xc544663b, 0x345bfb7e, 0x768b4329, 0xdccb23c6, 0x68b6edfc, 0x63b8e4f1, 0xcad731dc, 0x10426385, 0x40139722, 0x2084c611, 0x7d854a24, 0xf8d2bb3d, 0x11aef932, 0x6dc729a1, 0x4b1d9e2f, 0xf3dcb230, 0xec0d8652, 0xd077c1e3, 0x6c2bb316, 0x99a970b9, 0xfa119448, 0x2247e964, 0xc4a8fc8c, 0x1aa0f03f, 0xd8567d2c, 0xef223390, 0xc787494e, 0xc1d938d1, 0xfe8ccaa2, 0x3698d40b, 0xcfa6f581, 0x28a57ade, 0x26dab78e, 0xa43fadbf, 0xe42c3a9d, 0x0d507892, 0x9b6a5fcc, 0x62547e46, 0xc2f68d13, 0xe890d8b8, 0x5e2e39f7, 0xf582c3af, 0xbe9f5d80, 0x7c69d093, 0xa96fd52d, 0xb3cf2512, 0x3bc8ac99, 0xa710187d, 0x6ee89c63, 0x7bdb3bbb, 0x09cd2678, 0xf46e5918, 0x01ec9ab7, 0xa8834f9a, 0x65e6956e, 0x7eaaffe6, 0x0821bccf, 0xe6ef15e8, 0xd9bae79b, 0xce4a6f36, 0xd4ea9f09, 0xd629b07c, 0xaf31a4b2, 0x312a3f23, 0x30c6a594, 0xc035a266, 0x37744ebc, 0xa6fc82ca, 0xb0e090d0, 0x1533a7d8, 0x4af10498, 0xf741ecda, 0x0e7fcd50, 0x2f1791f6, 0x8d764dd6, 0x4d43efb0, 0x54ccaa4d, 0xdfe49604, 0xe39ed1b5, 0x1b4c6a88, 0xb8c12c1f, 0x7f466551, 0x049d5eea, 0x5d018c35, 0x73fa8774, 0x2efb0b41, 0x5ab3671d, 0x5292dbd2, 0x33e91056, 0x136dd647, 0x8c9ad761, 0x7a37a10c, 0x8e59f814, 0x89eb133c, 0xeecea927, 0x35b761c9, 0xede11ce5, 0x3c7a47b1, 0x599cd2df, 0x3f55f273, 0x791814ce, 0xbf73c737, 0xea53f7cd, 0x5b5ffdaa, 0x14df3d6f, 0x867844db, 0x81caaff3, 0x3eb968c4, 0x2c382434, 0x5fc2a340, 0x72161dc3, 0x0cbce225, 0x8b283c49, 0x41ff0d95, 0x7139a801, 0xde080cb3, 0x9cd8b4e4, 0x906456c1, 0x617bcb84, 0x70d532b6, 0x74486c5c, 0x42d0b857];\n    var T7 = [0xa75051f4, 0x65537e41, 0xa4c31a17, 0x5e963a27, 0x6bcb3bab, 0x45f11f9d, 0x58abacfa, 0x03934be3, 0xfa552030, 0x6df6ad76, 0x769188cc, 0x4c25f502, 0xd7fc4fe5, 0xcbd7c52a, 0x44802635, 0xa38fb562, 0x5a49deb1, 0x1b6725ba, 0x0e9845ea, 0xc0e15dfe, 0x7502c32f, 0xf012814c, 0x97a38d46, 0xf9c66bd3, 0x5fe7038f, 0x9c951592, 0x7aebbf6d, 0x59da9552, 0x832dd4be, 0x21d35874, 0x692949e0, 0xc8448ec9, 0x896a75c2, 0x7978f48e, 0x3e6b9958, 0x71dd27b9, 0x4fb6bee1, 0xad17f088, 0xac66c920, 0x3ab47dce, 0x4a1863df, 0x3182e51a, 0x33609751, 0x7f456253, 0x77e0b164, 0xae84bb6b, 0xa01cfe81, 0x2b94f908, 0x68587048, 0xfd198f45, 0x6c8794de, 0xf8b7527b, 0xd323ab73, 0x02e2724b, 0x8f57e31f, 0xab2a6655, 0x2807b2eb, 0xc2032fb5, 0x7b9a86c5, 0x08a5d337, 0x87f23028, 0xa5b223bf, 0x6aba0203, 0x825ced16, 0x1c2b8acf, 0xb492a779, 0xf2f0f307, 0xe2a14e69, 0xf4cd65da, 0xbed50605, 0x621fd134, 0xfe8ac4a6, 0x539d342e, 0x55a0a2f3, 0xe132058a, 0xeb75a4f6, 0xec390b83, 0xefaa4060, 0x9f065e71, 0x1051bd6e, 0x8af93e21, 0x063d96dd, 0x05aedd3e, 0xbd464de6, 0x8db59154, 0x5d0571c4, 0xd46f0406, 0x15ff6050, 0xfb241998, 0xe997d6bd, 0x43cc8940, 0x9e7767d9, 0x42bdb0e8, 0x8b880789, 0x5b38e719, 0xeedb79c8, 0x0a47a17c, 0x0fe97c42, 0x1ec9f884, 0x00000000, 0x86830980, 0xed48322b, 0x70ac1e11, 0x724e6c5a, 0xfffbfd0e, 0x38560f85, 0xd51e3dae, 0x3927362d, 0xd9640a0f, 0xa621685c, 0x54d19b5b, 0x2e3a2436, 0x67b10c0a, 0xe70f9357, 0x96d2b4ee, 0x919e1b9b, 0xc54f80c0, 0x20a261dc, 0x4b695a77, 0x1a161c12, 0xba0ae293, 0x2ae5c0a0, 0xe0433c22, 0x171d121b, 0x0d0b0e09, 0xc7adf28b, 0xa8b92db6, 0xa9c8141e, 0x198557f1, 0x074caf75, 0xddbbee99, 0x60fda37f, 0x269ff701, 0xf5bc5c72, 0x3bc54466, 0x7e345bfb, 0x29768b43, 0xc6dccb23, 0xfc68b6ed, 0xf163b8e4, 0xdccad731, 0x85104263, 0x22401397, 0x112084c6, 0x247d854a, 0x3df8d2bb, 0x3211aef9, 0xa16dc729, 0x2f4b1d9e, 0x30f3dcb2, 0x52ec0d86, 0xe3d077c1, 0x166c2bb3, 0xb999a970, 0x48fa1194, 0x642247e9, 0x8cc4a8fc, 0x3f1aa0f0, 0x2cd8567d, 0x90ef2233, 0x4ec78749, 0xd1c1d938, 0xa2fe8cca, 0x0b3698d4, 0x81cfa6f5, 0xde28a57a, 0x8e26dab7, 0xbfa43fad, 0x9de42c3a, 0x920d5078, 0xcc9b6a5f, 0x4662547e, 0x13c2f68d, 0xb8e890d8, 0xf75e2e39, 0xaff582c3, 0x80be9f5d, 0x937c69d0, 0x2da96fd5, 0x12b3cf25, 0x993bc8ac, 0x7da71018, 0x636ee89c, 0xbb7bdb3b, 0x7809cd26, 0x18f46e59, 0xb701ec9a, 0x9aa8834f, 0x6e65e695, 0xe67eaaff, 0xcf0821bc, 0xe8e6ef15, 0x9bd9bae7, 0x36ce4a6f, 0x09d4ea9f, 0x7cd629b0, 0xb2af31a4, 0x23312a3f, 0x9430c6a5, 0x66c035a2, 0xbc37744e, 0xcaa6fc82, 0xd0b0e090, 0xd81533a7, 0x984af104, 0xdaf741ec, 0x500e7fcd, 0xf62f1791, 0xd68d764d, 0xb04d43ef, 0x4d54ccaa, 0x04dfe496, 0xb5e39ed1, 0x881b4c6a, 0x1fb8c12c, 0x517f4665, 0xea049d5e, 0x355d018c, 0x7473fa87, 0x412efb0b, 0x1d5ab367, 0xd25292db, 0x5633e910, 0x47136dd6, 0x618c9ad7, 0x0c7a37a1, 0x148e59f8, 0x3c89eb13, 0x27eecea9, 0xc935b761, 0xe5ede11c, 0xb13c7a47, 0xdf599cd2, 0x733f55f2, 0xce791814, 0x37bf73c7, 0xcdea53f7, 0xaa5b5ffd, 0x6f14df3d, 0xdb867844, 0xf381caaf, 0xc43eb968, 0x342c3824, 0x405fc2a3, 0xc372161d, 0x250cbce2, 0x498b283c, 0x9541ff0d, 0x017139a8, 0xb3de080c, 0xe49cd8b4, 0xc1906456, 0x84617bcb, 0xb670d532, 0x5c74486c, 0x5742d0b8];\n    var T8 = [0xf4a75051, 0x4165537e, 0x17a4c31a, 0x275e963a, 0xab6bcb3b, 0x9d45f11f, 0xfa58abac, 0xe303934b, 0x30fa5520, 0x766df6ad, 0xcc769188, 0x024c25f5, 0xe5d7fc4f, 0x2acbd7c5, 0x35448026, 0x62a38fb5, 0xb15a49de, 0xba1b6725, 0xea0e9845, 0xfec0e15d, 0x2f7502c3, 0x4cf01281, 0x4697a38d, 0xd3f9c66b, 0x8f5fe703, 0x929c9515, 0x6d7aebbf, 0x5259da95, 0xbe832dd4, 0x7421d358, 0xe0692949, 0xc9c8448e, 0xc2896a75, 0x8e7978f4, 0x583e6b99, 0xb971dd27, 0xe14fb6be, 0x88ad17f0, 0x20ac66c9, 0xce3ab47d, 0xdf4a1863, 0x1a3182e5, 0x51336097, 0x537f4562, 0x6477e0b1, 0x6bae84bb, 0x81a01cfe, 0x082b94f9, 0x48685870, 0x45fd198f, 0xde6c8794, 0x7bf8b752, 0x73d323ab, 0x4b02e272, 0x1f8f57e3, 0x55ab2a66, 0xeb2807b2, 0xb5c2032f, 0xc57b9a86, 0x3708a5d3, 0x2887f230, 0xbfa5b223, 0x036aba02, 0x16825ced, 0xcf1c2b8a, 0x79b492a7, 0x07f2f0f3, 0x69e2a14e, 0xdaf4cd65, 0x05bed506, 0x34621fd1, 0xa6fe8ac4, 0x2e539d34, 0xf355a0a2, 0x8ae13205, 0xf6eb75a4, 0x83ec390b, 0x60efaa40, 0x719f065e, 0x6e1051bd, 0x218af93e, 0xdd063d96, 0x3e05aedd, 0xe6bd464d, 0x548db591, 0xc45d0571, 0x06d46f04, 0x5015ff60, 0x98fb2419, 0xbde997d6, 0x4043cc89, 0xd99e7767, 0xe842bdb0, 0x898b8807, 0x195b38e7, 0xc8eedb79, 0x7c0a47a1, 0x420fe97c, 0x841ec9f8, 0x00000000, 0x80868309, 0x2bed4832, 0x1170ac1e, 0x5a724e6c, 0x0efffbfd, 0x8538560f, 0xaed51e3d, 0x2d392736, 0x0fd9640a, 0x5ca62168, 0x5b54d19b, 0x362e3a24, 0x0a67b10c, 0x57e70f93, 0xee96d2b4, 0x9b919e1b, 0xc0c54f80, 0xdc20a261, 0x774b695a, 0x121a161c, 0x93ba0ae2, 0xa02ae5c0, 0x22e0433c, 0x1b171d12, 0x090d0b0e, 0x8bc7adf2, 0xb6a8b92d, 0x1ea9c814, 0xf1198557, 0x75074caf, 0x99ddbbee, 0x7f60fda3, 0x01269ff7, 0x72f5bc5c, 0x663bc544, 0xfb7e345b, 0x4329768b, 0x23c6dccb, 0xedfc68b6, 0xe4f163b8, 0x31dccad7, 0x63851042, 0x97224013, 0xc6112084, 0x4a247d85, 0xbb3df8d2, 0xf93211ae, 0x29a16dc7, 0x9e2f4b1d, 0xb230f3dc, 0x8652ec0d, 0xc1e3d077, 0xb3166c2b, 0x70b999a9, 0x9448fa11, 0xe9642247, 0xfc8cc4a8, 0xf03f1aa0, 0x7d2cd856, 0x3390ef22, 0x494ec787, 0x38d1c1d9, 0xcaa2fe8c, 0xd40b3698, 0xf581cfa6, 0x7ade28a5, 0xb78e26da, 0xadbfa43f, 0x3a9de42c, 0x78920d50, 0x5fcc9b6a, 0x7e466254, 0x8d13c2f6, 0xd8b8e890, 0x39f75e2e, 0xc3aff582, 0x5d80be9f, 0xd0937c69, 0xd52da96f, 0x2512b3cf, 0xac993bc8, 0x187da710, 0x9c636ee8, 0x3bbb7bdb, 0x267809cd, 0x5918f46e, 0x9ab701ec, 0x4f9aa883, 0x956e65e6, 0xffe67eaa, 0xbccf0821, 0x15e8e6ef, 0xe79bd9ba, 0x6f36ce4a, 0x9f09d4ea, 0xb07cd629, 0xa4b2af31, 0x3f23312a, 0xa59430c6, 0xa266c035, 0x4ebc3774, 0x82caa6fc, 0x90d0b0e0, 0xa7d81533, 0x04984af1, 0xecdaf741, 0xcd500e7f, 0x91f62f17, 0x4dd68d76, 0xefb04d43, 0xaa4d54cc, 0x9604dfe4, 0xd1b5e39e, 0x6a881b4c, 0x2c1fb8c1, 0x65517f46, 0x5eea049d, 0x8c355d01, 0x877473fa, 0x0b412efb, 0x671d5ab3, 0xdbd25292, 0x105633e9, 0xd647136d, 0xd7618c9a, 0xa10c7a37, 0xf8148e59, 0x133c89eb, 0xa927eece, 0x61c935b7, 0x1ce5ede1, 0x47b13c7a, 0xd2df599c, 0xf2733f55, 0x14ce7918, 0xc737bf73, 0xf7cdea53, 0xfdaa5b5f, 0x3d6f14df, 0x44db8678, 0xaff381ca, 0x68c43eb9, 0x24342c38, 0xa3405fc2, 0x1dc37216, 0xe2250cbc, 0x3c498b28, 0x0d9541ff, 0xa8017139, 0x0cb3de08, 0xb4e49cd8, 0x56c19064, 0xcb84617b, 0x32b670d5, 0x6c5c7448, 0xb85742d0];\n\n    // Transformations for decryption key expansion\n    var U1 = [0x00000000, 0x0e090d0b, 0x1c121a16, 0x121b171d, 0x3824342c, 0x362d3927, 0x24362e3a, 0x2a3f2331, 0x70486858, 0x7e416553, 0x6c5a724e, 0x62537f45, 0x486c5c74, 0x4665517f, 0x547e4662, 0x5a774b69, 0xe090d0b0, 0xee99ddbb, 0xfc82caa6, 0xf28bc7ad, 0xd8b4e49c, 0xd6bde997, 0xc4a6fe8a, 0xcaaff381, 0x90d8b8e8, 0x9ed1b5e3, 0x8ccaa2fe, 0x82c3aff5, 0xa8fc8cc4, 0xa6f581cf, 0xb4ee96d2, 0xbae79bd9, 0xdb3bbb7b, 0xd532b670, 0xc729a16d, 0xc920ac66, 0xe31f8f57, 0xed16825c, 0xff0d9541, 0xf104984a, 0xab73d323, 0xa57ade28, 0xb761c935, 0xb968c43e, 0x9357e70f, 0x9d5eea04, 0x8f45fd19, 0x814cf012, 0x3bab6bcb, 0x35a266c0, 0x27b971dd, 0x29b07cd6, 0x038f5fe7, 0x0d8652ec, 0x1f9d45f1, 0x119448fa, 0x4be30393, 0x45ea0e98, 0x57f11985, 0x59f8148e, 0x73c737bf, 0x7dce3ab4, 0x6fd52da9, 0x61dc20a2, 0xad766df6, 0xa37f60fd, 0xb16477e0, 0xbf6d7aeb, 0x955259da, 0x9b5b54d1, 0x894043cc, 0x87494ec7, 0xdd3e05ae, 0xd33708a5, 0xc12c1fb8, 0xcf2512b3, 0xe51a3182, 0xeb133c89, 0xf9082b94, 0xf701269f, 0x4de6bd46, 0x43efb04d, 0x51f4a750, 0x5ffdaa5b, 0x75c2896a, 0x7bcb8461, 0x69d0937c, 0x67d99e77, 0x3daed51e, 0x33a7d815, 0x21bccf08, 0x2fb5c203, 0x058ae132, 0x0b83ec39, 0x1998fb24, 0x1791f62f, 0x764dd68d, 0x7844db86, 0x6a5fcc9b, 0x6456c190, 0x4e69e2a1, 0x4060efaa, 0x527bf8b7, 0x5c72f5bc, 0x0605bed5, 0x080cb3de, 0x1a17a4c3, 0x141ea9c8, 0x3e218af9, 0x302887f2, 0x223390ef, 0x2c3a9de4, 0x96dd063d, 0x98d40b36, 0x8acf1c2b, 0x84c61120, 0xaef93211, 0xa0f03f1a, 0xb2eb2807, 0xbce2250c, 0xe6956e65, 0xe89c636e, 0xfa877473, 0xf48e7978, 0xdeb15a49, 0xd0b85742, 0xc2a3405f, 0xccaa4d54, 0x41ecdaf7, 0x4fe5d7fc, 0x5dfec0e1, 0x53f7cdea, 0x79c8eedb, 0x77c1e3d0, 0x65daf4cd, 0x6bd3f9c6, 0x31a4b2af, 0x3fadbfa4, 0x2db6a8b9, 0x23bfa5b2, 0x09808683, 0x07898b88, 0x15929c95, 0x1b9b919e, 0xa17c0a47, 0xaf75074c, 0xbd6e1051, 0xb3671d5a, 0x99583e6b, 0x97513360, 0x854a247d, 0x8b432976, 0xd134621f, 0xdf3d6f14, 0xcd267809, 0xc32f7502, 0xe9105633, 0xe7195b38, 0xf5024c25, 0xfb0b412e, 0x9ad7618c, 0x94de6c87, 0x86c57b9a, 0x88cc7691, 0xa2f355a0, 0xacfa58ab, 0xbee14fb6, 0xb0e842bd, 0xea9f09d4, 0xe49604df, 0xf68d13c2, 0xf8841ec9, 0xd2bb3df8, 0xdcb230f3, 0xcea927ee, 0xc0a02ae5, 0x7a47b13c, 0x744ebc37, 0x6655ab2a, 0x685ca621, 0x42638510, 0x4c6a881b, 0x5e719f06, 0x5078920d, 0x0a0fd964, 0x0406d46f, 0x161dc372, 0x1814ce79, 0x322bed48, 0x3c22e043, 0x2e39f75e, 0x2030fa55, 0xec9ab701, 0xe293ba0a, 0xf088ad17, 0xfe81a01c, 0xd4be832d, 0xdab78e26, 0xc8ac993b, 0xc6a59430, 0x9cd2df59, 0x92dbd252, 0x80c0c54f, 0x8ec9c844, 0xa4f6eb75, 0xaaffe67e, 0xb8e4f163, 0xb6edfc68, 0x0c0a67b1, 0x02036aba, 0x10187da7, 0x1e1170ac, 0x342e539d, 0x3a275e96, 0x283c498b, 0x26354480, 0x7c420fe9, 0x724b02e2, 0x605015ff, 0x6e5918f4, 0x44663bc5, 0x4a6f36ce, 0x587421d3, 0x567d2cd8, 0x37a10c7a, 0x39a80171, 0x2bb3166c, 0x25ba1b67, 0x0f853856, 0x018c355d, 0x13972240, 0x1d9e2f4b, 0x47e96422, 0x49e06929, 0x5bfb7e34, 0x55f2733f, 0x7fcd500e, 0x71c45d05, 0x63df4a18, 0x6dd64713, 0xd731dcca, 0xd938d1c1, 0xcb23c6dc, 0xc52acbd7, 0xef15e8e6, 0xe11ce5ed, 0xf307f2f0, 0xfd0efffb, 0xa779b492, 0xa970b999, 0xbb6bae84, 0xb562a38f, 0x9f5d80be, 0x91548db5, 0x834f9aa8, 0x8d4697a3];\n    var U2 = [0x00000000, 0x0b0e090d, 0x161c121a, 0x1d121b17, 0x2c382434, 0x27362d39, 0x3a24362e, 0x312a3f23, 0x58704868, 0x537e4165, 0x4e6c5a72, 0x4562537f, 0x74486c5c, 0x7f466551, 0x62547e46, 0x695a774b, 0xb0e090d0, 0xbbee99dd, 0xa6fc82ca, 0xadf28bc7, 0x9cd8b4e4, 0x97d6bde9, 0x8ac4a6fe, 0x81caaff3, 0xe890d8b8, 0xe39ed1b5, 0xfe8ccaa2, 0xf582c3af, 0xc4a8fc8c, 0xcfa6f581, 0xd2b4ee96, 0xd9bae79b, 0x7bdb3bbb, 0x70d532b6, 0x6dc729a1, 0x66c920ac, 0x57e31f8f, 0x5ced1682, 0x41ff0d95, 0x4af10498, 0x23ab73d3, 0x28a57ade, 0x35b761c9, 0x3eb968c4, 0x0f9357e7, 0x049d5eea, 0x198f45fd, 0x12814cf0, 0xcb3bab6b, 0xc035a266, 0xdd27b971, 0xd629b07c, 0xe7038f5f, 0xec0d8652, 0xf11f9d45, 0xfa119448, 0x934be303, 0x9845ea0e, 0x8557f119, 0x8e59f814, 0xbf73c737, 0xb47dce3a, 0xa96fd52d, 0xa261dc20, 0xf6ad766d, 0xfda37f60, 0xe0b16477, 0xebbf6d7a, 0xda955259, 0xd19b5b54, 0xcc894043, 0xc787494e, 0xaedd3e05, 0xa5d33708, 0xb8c12c1f, 0xb3cf2512, 0x82e51a31, 0x89eb133c, 0x94f9082b, 0x9ff70126, 0x464de6bd, 0x4d43efb0, 0x5051f4a7, 0x5b5ffdaa, 0x6a75c289, 0x617bcb84, 0x7c69d093, 0x7767d99e, 0x1e3daed5, 0x1533a7d8, 0x0821bccf, 0x032fb5c2, 0x32058ae1, 0x390b83ec, 0x241998fb, 0x2f1791f6, 0x8d764dd6, 0x867844db, 0x9b6a5fcc, 0x906456c1, 0xa14e69e2, 0xaa4060ef, 0xb7527bf8, 0xbc5c72f5, 0xd50605be, 0xde080cb3, 0xc31a17a4, 0xc8141ea9, 0xf93e218a, 0xf2302887, 0xef223390, 0xe42c3a9d, 0x3d96dd06, 0x3698d40b, 0x2b8acf1c, 0x2084c611, 0x11aef932, 0x1aa0f03f, 0x07b2eb28, 0x0cbce225, 0x65e6956e, 0x6ee89c63, 0x73fa8774, 0x78f48e79, 0x49deb15a, 0x42d0b857, 0x5fc2a340, 0x54ccaa4d, 0xf741ecda, 0xfc4fe5d7, 0xe15dfec0, 0xea53f7cd, 0xdb79c8ee, 0xd077c1e3, 0xcd65daf4, 0xc66bd3f9, 0xaf31a4b2, 0xa43fadbf, 0xb92db6a8, 0xb223bfa5, 0x83098086, 0x8807898b, 0x9515929c, 0x9e1b9b91, 0x47a17c0a, 0x4caf7507, 0x51bd6e10, 0x5ab3671d, 0x6b99583e, 0x60975133, 0x7d854a24, 0x768b4329, 0x1fd13462, 0x14df3d6f, 0x09cd2678, 0x02c32f75, 0x33e91056, 0x38e7195b, 0x25f5024c, 0x2efb0b41, 0x8c9ad761, 0x8794de6c, 0x9a86c57b, 0x9188cc76, 0xa0a2f355, 0xabacfa58, 0xb6bee14f, 0xbdb0e842, 0xd4ea9f09, 0xdfe49604, 0xc2f68d13, 0xc9f8841e, 0xf8d2bb3d, 0xf3dcb230, 0xeecea927, 0xe5c0a02a, 0x3c7a47b1, 0x37744ebc, 0x2a6655ab, 0x21685ca6, 0x10426385, 0x1b4c6a88, 0x065e719f, 0x0d507892, 0x640a0fd9, 0x6f0406d4, 0x72161dc3, 0x791814ce, 0x48322bed, 0x433c22e0, 0x5e2e39f7, 0x552030fa, 0x01ec9ab7, 0x0ae293ba, 0x17f088ad, 0x1cfe81a0, 0x2dd4be83, 0x26dab78e, 0x3bc8ac99, 0x30c6a594, 0x599cd2df, 0x5292dbd2, 0x4f80c0c5, 0x448ec9c8, 0x75a4f6eb, 0x7eaaffe6, 0x63b8e4f1, 0x68b6edfc, 0xb10c0a67, 0xba02036a, 0xa710187d, 0xac1e1170, 0x9d342e53, 0x963a275e, 0x8b283c49, 0x80263544, 0xe97c420f, 0xe2724b02, 0xff605015, 0xf46e5918, 0xc544663b, 0xce4a6f36, 0xd3587421, 0xd8567d2c, 0x7a37a10c, 0x7139a801, 0x6c2bb316, 0x6725ba1b, 0x560f8538, 0x5d018c35, 0x40139722, 0x4b1d9e2f, 0x2247e964, 0x2949e069, 0x345bfb7e, 0x3f55f273, 0x0e7fcd50, 0x0571c45d, 0x1863df4a, 0x136dd647, 0xcad731dc, 0xc1d938d1, 0xdccb23c6, 0xd7c52acb, 0xe6ef15e8, 0xede11ce5, 0xf0f307f2, 0xfbfd0eff, 0x92a779b4, 0x99a970b9, 0x84bb6bae, 0x8fb562a3, 0xbe9f5d80, 0xb591548d, 0xa8834f9a, 0xa38d4697];\n    var U3 = [0x00000000, 0x0d0b0e09, 0x1a161c12, 0x171d121b, 0x342c3824, 0x3927362d, 0x2e3a2436, 0x23312a3f, 0x68587048, 0x65537e41, 0x724e6c5a, 0x7f456253, 0x5c74486c, 0x517f4665, 0x4662547e, 0x4b695a77, 0xd0b0e090, 0xddbbee99, 0xcaa6fc82, 0xc7adf28b, 0xe49cd8b4, 0xe997d6bd, 0xfe8ac4a6, 0xf381caaf, 0xb8e890d8, 0xb5e39ed1, 0xa2fe8cca, 0xaff582c3, 0x8cc4a8fc, 0x81cfa6f5, 0x96d2b4ee, 0x9bd9bae7, 0xbb7bdb3b, 0xb670d532, 0xa16dc729, 0xac66c920, 0x8f57e31f, 0x825ced16, 0x9541ff0d, 0x984af104, 0xd323ab73, 0xde28a57a, 0xc935b761, 0xc43eb968, 0xe70f9357, 0xea049d5e, 0xfd198f45, 0xf012814c, 0x6bcb3bab, 0x66c035a2, 0x71dd27b9, 0x7cd629b0, 0x5fe7038f, 0x52ec0d86, 0x45f11f9d, 0x48fa1194, 0x03934be3, 0x0e9845ea, 0x198557f1, 0x148e59f8, 0x37bf73c7, 0x3ab47dce, 0x2da96fd5, 0x20a261dc, 0x6df6ad76, 0x60fda37f, 0x77e0b164, 0x7aebbf6d, 0x59da9552, 0x54d19b5b, 0x43cc8940, 0x4ec78749, 0x05aedd3e, 0x08a5d337, 0x1fb8c12c, 0x12b3cf25, 0x3182e51a, 0x3c89eb13, 0x2b94f908, 0x269ff701, 0xbd464de6, 0xb04d43ef, 0xa75051f4, 0xaa5b5ffd, 0x896a75c2, 0x84617bcb, 0x937c69d0, 0x9e7767d9, 0xd51e3dae, 0xd81533a7, 0xcf0821bc, 0xc2032fb5, 0xe132058a, 0xec390b83, 0xfb241998, 0xf62f1791, 0xd68d764d, 0xdb867844, 0xcc9b6a5f, 0xc1906456, 0xe2a14e69, 0xefaa4060, 0xf8b7527b, 0xf5bc5c72, 0xbed50605, 0xb3de080c, 0xa4c31a17, 0xa9c8141e, 0x8af93e21, 0x87f23028, 0x90ef2233, 0x9de42c3a, 0x063d96dd, 0x0b3698d4, 0x1c2b8acf, 0x112084c6, 0x3211aef9, 0x3f1aa0f0, 0x2807b2eb, 0x250cbce2, 0x6e65e695, 0x636ee89c, 0x7473fa87, 0x7978f48e, 0x5a49deb1, 0x5742d0b8, 0x405fc2a3, 0x4d54ccaa, 0xdaf741ec, 0xd7fc4fe5, 0xc0e15dfe, 0xcdea53f7, 0xeedb79c8, 0xe3d077c1, 0xf4cd65da, 0xf9c66bd3, 0xb2af31a4, 0xbfa43fad, 0xa8b92db6, 0xa5b223bf, 0x86830980, 0x8b880789, 0x9c951592, 0x919e1b9b, 0x0a47a17c, 0x074caf75, 0x1051bd6e, 0x1d5ab367, 0x3e6b9958, 0x33609751, 0x247d854a, 0x29768b43, 0x621fd134, 0x6f14df3d, 0x7809cd26, 0x7502c32f, 0x5633e910, 0x5b38e719, 0x4c25f502, 0x412efb0b, 0x618c9ad7, 0x6c8794de, 0x7b9a86c5, 0x769188cc, 0x55a0a2f3, 0x58abacfa, 0x4fb6bee1, 0x42bdb0e8, 0x09d4ea9f, 0x04dfe496, 0x13c2f68d, 0x1ec9f884, 0x3df8d2bb, 0x30f3dcb2, 0x27eecea9, 0x2ae5c0a0, 0xb13c7a47, 0xbc37744e, 0xab2a6655, 0xa621685c, 0x85104263, 0x881b4c6a, 0x9f065e71, 0x920d5078, 0xd9640a0f, 0xd46f0406, 0xc372161d, 0xce791814, 0xed48322b, 0xe0433c22, 0xf75e2e39, 0xfa552030, 0xb701ec9a, 0xba0ae293, 0xad17f088, 0xa01cfe81, 0x832dd4be, 0x8e26dab7, 0x993bc8ac, 0x9430c6a5, 0xdf599cd2, 0xd25292db, 0xc54f80c0, 0xc8448ec9, 0xeb75a4f6, 0xe67eaaff, 0xf163b8e4, 0xfc68b6ed, 0x67b10c0a, 0x6aba0203, 0x7da71018, 0x70ac1e11, 0x539d342e, 0x5e963a27, 0x498b283c, 0x44802635, 0x0fe97c42, 0x02e2724b, 0x15ff6050, 0x18f46e59, 0x3bc54466, 0x36ce4a6f, 0x21d35874, 0x2cd8567d, 0x0c7a37a1, 0x017139a8, 0x166c2bb3, 0x1b6725ba, 0x38560f85, 0x355d018c, 0x22401397, 0x2f4b1d9e, 0x642247e9, 0x692949e0, 0x7e345bfb, 0x733f55f2, 0x500e7fcd, 0x5d0571c4, 0x4a1863df, 0x47136dd6, 0xdccad731, 0xd1c1d938, 0xc6dccb23, 0xcbd7c52a, 0xe8e6ef15, 0xe5ede11c, 0xf2f0f307, 0xfffbfd0e, 0xb492a779, 0xb999a970, 0xae84bb6b, 0xa38fb562, 0x80be9f5d, 0x8db59154, 0x9aa8834f, 0x97a38d46];\n    var U4 = [0x00000000, 0x090d0b0e, 0x121a161c, 0x1b171d12, 0x24342c38, 0x2d392736, 0x362e3a24, 0x3f23312a, 0x48685870, 0x4165537e, 0x5a724e6c, 0x537f4562, 0x6c5c7448, 0x65517f46, 0x7e466254, 0x774b695a, 0x90d0b0e0, 0x99ddbbee, 0x82caa6fc, 0x8bc7adf2, 0xb4e49cd8, 0xbde997d6, 0xa6fe8ac4, 0xaff381ca, 0xd8b8e890, 0xd1b5e39e, 0xcaa2fe8c, 0xc3aff582, 0xfc8cc4a8, 0xf581cfa6, 0xee96d2b4, 0xe79bd9ba, 0x3bbb7bdb, 0x32b670d5, 0x29a16dc7, 0x20ac66c9, 0x1f8f57e3, 0x16825ced, 0x0d9541ff, 0x04984af1, 0x73d323ab, 0x7ade28a5, 0x61c935b7, 0x68c43eb9, 0x57e70f93, 0x5eea049d, 0x45fd198f, 0x4cf01281, 0xab6bcb3b, 0xa266c035, 0xb971dd27, 0xb07cd629, 0x8f5fe703, 0x8652ec0d, 0x9d45f11f, 0x9448fa11, 0xe303934b, 0xea0e9845, 0xf1198557, 0xf8148e59, 0xc737bf73, 0xce3ab47d, 0xd52da96f, 0xdc20a261, 0x766df6ad, 0x7f60fda3, 0x6477e0b1, 0x6d7aebbf, 0x5259da95, 0x5b54d19b, 0x4043cc89, 0x494ec787, 0x3e05aedd, 0x3708a5d3, 0x2c1fb8c1, 0x2512b3cf, 0x1a3182e5, 0x133c89eb, 0x082b94f9, 0x01269ff7, 0xe6bd464d, 0xefb04d43, 0xf4a75051, 0xfdaa5b5f, 0xc2896a75, 0xcb84617b, 0xd0937c69, 0xd99e7767, 0xaed51e3d, 0xa7d81533, 0xbccf0821, 0xb5c2032f, 0x8ae13205, 0x83ec390b, 0x98fb2419, 0x91f62f17, 0x4dd68d76, 0x44db8678, 0x5fcc9b6a, 0x56c19064, 0x69e2a14e, 0x60efaa40, 0x7bf8b752, 0x72f5bc5c, 0x05bed506, 0x0cb3de08, 0x17a4c31a, 0x1ea9c814, 0x218af93e, 0x2887f230, 0x3390ef22, 0x3a9de42c, 0xdd063d96, 0xd40b3698, 0xcf1c2b8a, 0xc6112084, 0xf93211ae, 0xf03f1aa0, 0xeb2807b2, 0xe2250cbc, 0x956e65e6, 0x9c636ee8, 0x877473fa, 0x8e7978f4, 0xb15a49de, 0xb85742d0, 0xa3405fc2, 0xaa4d54cc, 0xecdaf741, 0xe5d7fc4f, 0xfec0e15d, 0xf7cdea53, 0xc8eedb79, 0xc1e3d077, 0xdaf4cd65, 0xd3f9c66b, 0xa4b2af31, 0xadbfa43f, 0xb6a8b92d, 0xbfa5b223, 0x80868309, 0x898b8807, 0x929c9515, 0x9b919e1b, 0x7c0a47a1, 0x75074caf, 0x6e1051bd, 0x671d5ab3, 0x583e6b99, 0x51336097, 0x4a247d85, 0x4329768b, 0x34621fd1, 0x3d6f14df, 0x267809cd, 0x2f7502c3, 0x105633e9, 0x195b38e7, 0x024c25f5, 0x0b412efb, 0xd7618c9a, 0xde6c8794, 0xc57b9a86, 0xcc769188, 0xf355a0a2, 0xfa58abac, 0xe14fb6be, 0xe842bdb0, 0x9f09d4ea, 0x9604dfe4, 0x8d13c2f6, 0x841ec9f8, 0xbb3df8d2, 0xb230f3dc, 0xa927eece, 0xa02ae5c0, 0x47b13c7a, 0x4ebc3774, 0x55ab2a66, 0x5ca62168, 0x63851042, 0x6a881b4c, 0x719f065e, 0x78920d50, 0x0fd9640a, 0x06d46f04, 0x1dc37216, 0x14ce7918, 0x2bed4832, 0x22e0433c, 0x39f75e2e, 0x30fa5520, 0x9ab701ec, 0x93ba0ae2, 0x88ad17f0, 0x81a01cfe, 0xbe832dd4, 0xb78e26da, 0xac993bc8, 0xa59430c6, 0xd2df599c, 0xdbd25292, 0xc0c54f80, 0xc9c8448e, 0xf6eb75a4, 0xffe67eaa, 0xe4f163b8, 0xedfc68b6, 0x0a67b10c, 0x036aba02, 0x187da710, 0x1170ac1e, 0x2e539d34, 0x275e963a, 0x3c498b28, 0x35448026, 0x420fe97c, 0x4b02e272, 0x5015ff60, 0x5918f46e, 0x663bc544, 0x6f36ce4a, 0x7421d358, 0x7d2cd856, 0xa10c7a37, 0xa8017139, 0xb3166c2b, 0xba1b6725, 0x8538560f, 0x8c355d01, 0x97224013, 0x9e2f4b1d, 0xe9642247, 0xe0692949, 0xfb7e345b, 0xf2733f55, 0xcd500e7f, 0xc45d0571, 0xdf4a1863, 0xd647136d, 0x31dccad7, 0x38d1c1d9, 0x23c6dccb, 0x2acbd7c5, 0x15e8e6ef, 0x1ce5ede1, 0x07f2f0f3, 0x0efffbfd, 0x79b492a7, 0x70b999a9, 0x6bae84bb, 0x62a38fb5, 0x5d80be9f, 0x548db591, 0x4f9aa883, 0x4697a38d];\n\n    function convertToInt32(bytes) {\n        var result = [];\n        for (var i = 0; i < bytes.length; i += 4) {\n            result.push(\n                (bytes[i    ] << 24) |\n                (bytes[i + 1] << 16) |\n                (bytes[i + 2] <<  8) |\n                 bytes[i + 3]\n            );\n        }\n        return result;\n    }\n\n    var AES = function(key) {\n        if (!(this instanceof AES)) {\n            throw Error('AES must be instanitated with `new`');\n        }\n\n        Object.defineProperty(this, 'key', {\n            value: coerceArray(key, true)\n        });\n\n        this._prepare();\n    }\n\n\n    AES.prototype._prepare = function() {\n\n        var rounds = numberOfRounds[this.key.length];\n        if (rounds == null) {\n            throw new Error('invalid key size (must be 16, 24 or 32 bytes)');\n        }\n\n        // encryption round keys\n        this._Ke = [];\n\n        // decryption round keys\n        this._Kd = [];\n\n        for (var i = 0; i <= rounds; i++) {\n            this._Ke.push([0, 0, 0, 0]);\n            this._Kd.push([0, 0, 0, 0]);\n        }\n\n        var roundKeyCount = (rounds + 1) * 4;\n        var KC = this.key.length / 4;\n\n        // convert the key into ints\n        var tk = convertToInt32(this.key);\n\n        // copy values into round key arrays\n        var index;\n        for (var i = 0; i < KC; i++) {\n            index = i >> 2;\n            this._Ke[index][i % 4] = tk[i];\n            this._Kd[rounds - index][i % 4] = tk[i];\n        }\n\n        // key expansion (fips-197 section 5.2)\n        var rconpointer = 0;\n        var t = KC, tt;\n        while (t < roundKeyCount) {\n            tt = tk[KC - 1];\n            tk[0] ^= ((S[(tt >> 16) & 0xFF] << 24) ^\n                      (S[(tt >>  8) & 0xFF] << 16) ^\n                      (S[ tt        & 0xFF] <<  8) ^\n                       S[(tt >> 24) & 0xFF]        ^\n                      (rcon[rconpointer] << 24));\n            rconpointer += 1;\n\n            // key expansion (for non-256 bit)\n            if (KC != 8) {\n                for (var i = 1; i < KC; i++) {\n                    tk[i] ^= tk[i - 1];\n                }\n\n            // key expansion for 256-bit keys is \"slightly different\" (fips-197)\n            } else {\n                for (var i = 1; i < (KC / 2); i++) {\n                    tk[i] ^= tk[i - 1];\n                }\n                tt = tk[(KC / 2) - 1];\n\n                tk[KC / 2] ^= (S[ tt        & 0xFF]        ^\n                              (S[(tt >>  8) & 0xFF] <<  8) ^\n                              (S[(tt >> 16) & 0xFF] << 16) ^\n                              (S[(tt >> 24) & 0xFF] << 24));\n\n                for (var i = (KC / 2) + 1; i < KC; i++) {\n                    tk[i] ^= tk[i - 1];\n                }\n            }\n\n            // copy values into round key arrays\n            var i = 0, r, c;\n            while (i < KC && t < roundKeyCount) {\n                r = t >> 2;\n                c = t % 4;\n                this._Ke[r][c] = tk[i];\n                this._Kd[rounds - r][c] = tk[i++];\n                t++;\n            }\n        }\n\n        // inverse-cipher-ify the decryption round key (fips-197 section 5.3)\n        for (var r = 1; r < rounds; r++) {\n            for (var c = 0; c < 4; c++) {\n                tt = this._Kd[r][c];\n                this._Kd[r][c] = (U1[(tt >> 24) & 0xFF] ^\n                                  U2[(tt >> 16) & 0xFF] ^\n                                  U3[(tt >>  8) & 0xFF] ^\n                                  U4[ tt        & 0xFF]);\n            }\n        }\n    }\n\n    AES.prototype.encrypt = function(plaintext) {\n        if (plaintext.length != 16) {\n            throw new Error('invalid plaintext size (must be 16 bytes)');\n        }\n\n        var rounds = this._Ke.length - 1;\n        var a = [0, 0, 0, 0];\n\n        // convert plaintext to (ints ^ key)\n        var t = convertToInt32(plaintext);\n        for (var i = 0; i < 4; i++) {\n            t[i] ^= this._Ke[0][i];\n        }\n\n        // apply round transforms\n        for (var r = 1; r < rounds; r++) {\n            for (var i = 0; i < 4; i++) {\n                a[i] = (T1[(t[ i         ] >> 24) & 0xff] ^\n                        T2[(t[(i + 1) % 4] >> 16) & 0xff] ^\n                        T3[(t[(i + 2) % 4] >>  8) & 0xff] ^\n                        T4[ t[(i + 3) % 4]        & 0xff] ^\n                        this._Ke[r][i]);\n            }\n            t = a.slice();\n        }\n\n        // the last round is special\n        var result = createArray(16), tt;\n        for (var i = 0; i < 4; i++) {\n            tt = this._Ke[rounds][i];\n            result[4 * i    ] = (S[(t[ i         ] >> 24) & 0xff] ^ (tt >> 24)) & 0xff;\n            result[4 * i + 1] = (S[(t[(i + 1) % 4] >> 16) & 0xff] ^ (tt >> 16)) & 0xff;\n            result[4 * i + 2] = (S[(t[(i + 2) % 4] >>  8) & 0xff] ^ (tt >>  8)) & 0xff;\n            result[4 * i + 3] = (S[ t[(i + 3) % 4]        & 0xff] ^  tt       ) & 0xff;\n        }\n\n        return result;\n    }\n\n    AES.prototype.decrypt = function(ciphertext) {\n        if (ciphertext.length != 16) {\n            throw new Error('invalid ciphertext size (must be 16 bytes)');\n        }\n\n        var rounds = this._Kd.length - 1;\n        var a = [0, 0, 0, 0];\n\n        // convert plaintext to (ints ^ key)\n        var t = convertToInt32(ciphertext);\n        for (var i = 0; i < 4; i++) {\n            t[i] ^= this._Kd[0][i];\n        }\n\n        // apply round transforms\n        for (var r = 1; r < rounds; r++) {\n            for (var i = 0; i < 4; i++) {\n                a[i] = (T5[(t[ i          ] >> 24) & 0xff] ^\n                        T6[(t[(i + 3) % 4] >> 16) & 0xff] ^\n                        T7[(t[(i + 2) % 4] >>  8) & 0xff] ^\n                        T8[ t[(i + 1) % 4]        & 0xff] ^\n                        this._Kd[r][i]);\n            }\n            t = a.slice();\n        }\n\n        // the last round is special\n        var result = createArray(16), tt;\n        for (var i = 0; i < 4; i++) {\n            tt = this._Kd[rounds][i];\n            result[4 * i    ] = (Si[(t[ i         ] >> 24) & 0xff] ^ (tt >> 24)) & 0xff;\n            result[4 * i + 1] = (Si[(t[(i + 3) % 4] >> 16) & 0xff] ^ (tt >> 16)) & 0xff;\n            result[4 * i + 2] = (Si[(t[(i + 2) % 4] >>  8) & 0xff] ^ (tt >>  8)) & 0xff;\n            result[4 * i + 3] = (Si[ t[(i + 1) % 4]        & 0xff] ^  tt       ) & 0xff;\n        }\n\n        return result;\n    }\n\n\n    /**\n     *  Mode Of Operation - Electonic Codebook (ECB)\n     */\n    var ModeOfOperationECB = function(key) {\n        if (!(this instanceof ModeOfOperationECB)) {\n            throw Error('AES must be instanitated with `new`');\n        }\n\n        this.description = \"Electronic Code Block\";\n        this.name = \"ecb\";\n\n        this._aes = new AES(key);\n    }\n\n    ModeOfOperationECB.prototype.encrypt = function(plaintext) {\n        plaintext = coerceArray(plaintext);\n\n        if ((plaintext.length % 16) !== 0) {\n            throw new Error('invalid plaintext size (must be multiple of 16 bytes)');\n        }\n\n        var ciphertext = createArray(plaintext.length);\n        var block = createArray(16);\n\n        for (var i = 0; i < plaintext.length; i += 16) {\n            copyArray(plaintext, block, 0, i, i + 16);\n            block = this._aes.encrypt(block);\n            copyArray(block, ciphertext, i);\n        }\n\n        return ciphertext;\n    }\n\n    ModeOfOperationECB.prototype.decrypt = function(ciphertext) {\n        ciphertext = coerceArray(ciphertext);\n\n        if ((ciphertext.length % 16) !== 0) {\n            throw new Error('invalid ciphertext size (must be multiple of 16 bytes)');\n        }\n\n        var plaintext = createArray(ciphertext.length);\n        var block = createArray(16);\n\n        for (var i = 0; i < ciphertext.length; i += 16) {\n            copyArray(ciphertext, block, 0, i, i + 16);\n            block = this._aes.decrypt(block);\n            copyArray(block, plaintext, i);\n        }\n\n        return plaintext;\n    }\n\n\n    /**\n     *  Mode Of Operation - Cipher Block Chaining (CBC)\n     */\n    var ModeOfOperationCBC = function(key, iv) {\n        if (!(this instanceof ModeOfOperationCBC)) {\n            throw Error('AES must be instanitated with `new`');\n        }\n\n        this.description = \"Cipher Block Chaining\";\n        this.name = \"cbc\";\n\n        if (!iv) {\n            iv = createArray(16);\n\n        } else if (iv.length != 16) {\n            throw new Error('invalid initialation vector size (must be 16 bytes)');\n        }\n\n        this._lastCipherblock = coerceArray(iv, true);\n\n        this._aes = new AES(key);\n    }\n\n    ModeOfOperationCBC.prototype.encrypt = function(plaintext) {\n        plaintext = coerceArray(plaintext);\n\n        if ((plaintext.length % 16) !== 0) {\n            throw new Error('invalid plaintext size (must be multiple of 16 bytes)');\n        }\n\n        var ciphertext = createArray(plaintext.length);\n        var block = createArray(16);\n\n        for (var i = 0; i < plaintext.length; i += 16) {\n            copyArray(plaintext, block, 0, i, i + 16);\n\n            for (var j = 0; j < 16; j++) {\n                block[j] ^= this._lastCipherblock[j];\n            }\n\n            this._lastCipherblock = this._aes.encrypt(block);\n            copyArray(this._lastCipherblock, ciphertext, i);\n        }\n\n        return ciphertext;\n    }\n\n    ModeOfOperationCBC.prototype.decrypt = function(ciphertext) {\n        ciphertext = coerceArray(ciphertext);\n\n        if ((ciphertext.length % 16) !== 0) {\n            throw new Error('invalid ciphertext size (must be multiple of 16 bytes)');\n        }\n\n        var plaintext = createArray(ciphertext.length);\n        var block = createArray(16);\n\n        for (var i = 0; i < ciphertext.length; i += 16) {\n            copyArray(ciphertext, block, 0, i, i + 16);\n            block = this._aes.decrypt(block);\n\n            for (var j = 0; j < 16; j++) {\n                plaintext[i + j] = block[j] ^ this._lastCipherblock[j];\n            }\n\n            copyArray(ciphertext, this._lastCipherblock, 0, i, i + 16);\n        }\n\n        return plaintext;\n    }\n\n\n    /**\n     *  Mode Of Operation - Cipher Feedback (CFB)\n     */\n    var ModeOfOperationCFB = function(key, iv, segmentSize) {\n        if (!(this instanceof ModeOfOperationCFB)) {\n            throw Error('AES must be instanitated with `new`');\n        }\n\n        this.description = \"Cipher Feedback\";\n        this.name = \"cfb\";\n\n        if (!iv) {\n            iv = createArray(16);\n\n        } else if (iv.length != 16) {\n            throw new Error('invalid initialation vector size (must be 16 size)');\n        }\n\n        if (!segmentSize) { segmentSize = 1; }\n\n        this.segmentSize = segmentSize;\n\n        this._shiftRegister = coerceArray(iv, true);\n\n        this._aes = new AES(key);\n    }\n\n    ModeOfOperationCFB.prototype.encrypt = function(plaintext) {\n        if ((plaintext.length % this.segmentSize) != 0) {\n            throw new Error('invalid plaintext size (must be segmentSize bytes)');\n        }\n\n        var encrypted = coerceArray(plaintext, true);\n\n        var xorSegment;\n        for (var i = 0; i < encrypted.length; i += this.segmentSize) {\n            xorSegment = this._aes.encrypt(this._shiftRegister);\n            for (var j = 0; j < this.segmentSize; j++) {\n                encrypted[i + j] ^= xorSegment[j];\n            }\n\n            // Shift the register\n            copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);\n            copyArray(encrypted, this._shiftRegister, 16 - this.segmentSize, i, i + this.segmentSize);\n        }\n\n        return encrypted;\n    }\n\n    ModeOfOperationCFB.prototype.decrypt = function(ciphertext) {\n        if ((ciphertext.length % this.segmentSize) != 0) {\n            throw new Error('invalid ciphertext size (must be segmentSize bytes)');\n        }\n\n        var plaintext = coerceArray(ciphertext, true);\n\n        var xorSegment;\n        for (var i = 0; i < plaintext.length; i += this.segmentSize) {\n            xorSegment = this._aes.encrypt(this._shiftRegister);\n\n            for (var j = 0; j < this.segmentSize; j++) {\n                plaintext[i + j] ^= xorSegment[j];\n            }\n\n            // Shift the register\n            copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);\n            copyArray(ciphertext, this._shiftRegister, 16 - this.segmentSize, i, i + this.segmentSize);\n        }\n\n        return plaintext;\n    }\n\n    /**\n     *  Mode Of Operation - Output Feedback (OFB)\n     */\n    var ModeOfOperationOFB = function(key, iv) {\n        if (!(this instanceof ModeOfOperationOFB)) {\n            throw Error('AES must be instanitated with `new`');\n        }\n\n        this.description = \"Output Feedback\";\n        this.name = \"ofb\";\n\n        if (!iv) {\n            iv = createArray(16);\n\n        } else if (iv.length != 16) {\n            throw new Error('invalid initialation vector size (must be 16 bytes)');\n        }\n\n        this._lastPrecipher = coerceArray(iv, true);\n        this._lastPrecipherIndex = 16;\n\n        this._aes = new AES(key);\n    }\n\n    ModeOfOperationOFB.prototype.encrypt = function(plaintext) {\n        var encrypted = coerceArray(plaintext, true);\n\n        for (var i = 0; i < encrypted.length; i++) {\n            if (this._lastPrecipherIndex === 16) {\n                this._lastPrecipher = this._aes.encrypt(this._lastPrecipher);\n                this._lastPrecipherIndex = 0;\n            }\n            encrypted[i] ^= this._lastPrecipher[this._lastPrecipherIndex++];\n        }\n\n        return encrypted;\n    }\n\n    // Decryption is symetric\n    ModeOfOperationOFB.prototype.decrypt = ModeOfOperationOFB.prototype.encrypt;\n\n\n    /**\n     *  Counter object for CTR common mode of operation\n     */\n    var Counter = function(initialValue) {\n        if (!(this instanceof Counter)) {\n            throw Error('Counter must be instanitated with `new`');\n        }\n\n        // We allow 0, but anything false-ish uses the default 1\n        if (initialValue !== 0 && !initialValue) { initialValue = 1; }\n\n        if (typeof(initialValue) === 'number') {\n            this._counter = createArray(16);\n            this.setValue(initialValue);\n\n        } else {\n            this.setBytes(initialValue);\n        }\n    }\n\n    Counter.prototype.setValue = function(value) {\n        if (typeof(value) !== 'number' || parseInt(value) != value) {\n            throw new Error('invalid counter value (must be an integer)');\n        }\n\n        for (var index = 15; index >= 0; --index) {\n            this._counter[index] = value % 256;\n            value = value >> 8;\n        }\n    }\n\n    Counter.prototype.setBytes = function(bytes) {\n        bytes = coerceArray(bytes, true);\n\n        if (bytes.length != 16) {\n            throw new Error('invalid counter bytes size (must be 16 bytes)');\n        }\n\n        this._counter = bytes;\n    };\n\n    Counter.prototype.increment = function() {\n        for (var i = 15; i >= 0; i--) {\n            if (this._counter[i] === 255) {\n                this._counter[i] = 0;\n            } else {\n                this._counter[i]++;\n                break;\n            }\n        }\n    }\n\n\n    /**\n     *  Mode Of Operation - Counter (CTR)\n     */\n    var ModeOfOperationCTR = function(key, counter) {\n        if (!(this instanceof ModeOfOperationCTR)) {\n            throw Error('AES must be instanitated with `new`');\n        }\n\n        this.description = \"Counter\";\n        this.name = \"ctr\";\n\n        if (!(counter instanceof Counter)) {\n            counter = new Counter(counter)\n        }\n\n        this._counter = counter;\n\n        this._remainingCounter = null;\n        this._remainingCounterIndex = 16;\n\n        this._aes = new AES(key);\n    }\n\n    ModeOfOperationCTR.prototype.encrypt = function(plaintext) {\n        var encrypted = coerceArray(plaintext, true);\n\n        for (var i = 0; i < encrypted.length; i++) {\n            if (this._remainingCounterIndex === 16) {\n                this._remainingCounter = this._aes.encrypt(this._counter._counter);\n                this._remainingCounterIndex = 0;\n                this._counter.increment();\n            }\n            encrypted[i] ^= this._remainingCounter[this._remainingCounterIndex++];\n        }\n\n        return encrypted;\n    }\n\n    // Decryption is symetric\n    ModeOfOperationCTR.prototype.decrypt = ModeOfOperationCTR.prototype.encrypt;\n\n\n    ///////////////////////\n    // Padding\n\n    // See:https://tools.ietf.org/html/rfc2315\n    function pkcs7pad(data) {\n        data = coerceArray(data, true);\n        var padder = 16 - (data.length % 16);\n        var result = createArray(data.length + padder);\n        copyArray(data, result);\n        for (var i = data.length; i < result.length; i++) {\n            result[i] = padder;\n        }\n        return result;\n    }\n\n    function pkcs7strip(data) {\n        data = coerceArray(data, true);\n        if (data.length < 16) { throw new Error('PKCS#7 invalid length'); }\n\n        var padder = data[data.length - 1];\n        if (padder > 16) { throw new Error('PKCS#7 padding byte out of range'); }\n\n        var length = data.length - padder;\n        for (var i = 0; i < padder; i++) {\n            if (data[length + i] !== padder) {\n                throw new Error('PKCS#7 invalid padding byte');\n            }\n        }\n\n        var result = createArray(length);\n        copyArray(data, result, 0, 0, length);\n        return result;\n    }\n\n    ///////////////////////\n    // Exporting\n\n\n    // The block cipher\n    var aesjs = {\n        AES: AES,\n        Counter: Counter,\n\n        ModeOfOperation: {\n            ecb: ModeOfOperationECB,\n            cbc: ModeOfOperationCBC,\n            cfb: ModeOfOperationCFB,\n            ofb: ModeOfOperationOFB,\n            ctr: ModeOfOperationCTR\n        },\n\n        utils: {\n            hex: convertHex,\n            utf8: convertUtf8\n        },\n\n        padding: {\n            pkcs7: {\n                pad: pkcs7pad,\n                strip: pkcs7strip\n            }\n        },\n\n        _arrayTest: {\n            coerceArray: coerceArray,\n            createArray: createArray,\n            copyArray: copyArray,\n        }\n    };\n\n\n    // node.js\n    if (typeof exports !== 'undefined') {\n        module.exports = aesjs\n\n    // RequireJS/AMD\n    // http://www.requirejs.org/docs/api.html\n    // https://github.com/amdjs/amdjs-api/wiki/AMD\n    } else if (typeof(define) === 'function' && define.amd) {\n        define(aesjs);\n\n    // Web Browsers\n    } else {\n\n        // If there was an existing library at \"aesjs\" make sure it's still available\n        if (root.aesjs) {\n            aesjs._aesjs = root.aesjs;\n        }\n\n        root.aesjs = aesjs;\n    }\n\n\n})(this);\n","\"use strict\";\n\nimport hash from \"hash.js\";\n//const _ripemd160 = _hash.ripemd160;\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nimport { SupportedAlgorithm } from \"./types\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport function ripemd160(data: BytesLike): string {\n    return \"0x\" + (hash.ripemd160().update(arrayify(data)).digest(\"hex\"));\n}\n\nexport function sha256(data: BytesLike): string {\n    return \"0x\" + (hash.sha256().update(arrayify(data)).digest(\"hex\"));\n}\n\nexport function sha512(data: BytesLike): string {\n    return \"0x\" + (hash.sha512().update(arrayify(data)).digest(\"hex\"));\n}\n\nexport function computeHmac(algorithm: SupportedAlgorithm, key: BytesLike, data: BytesLike): string {\n    if (!SupportedAlgorithm[algorithm]) {\n        logger.throwError(\"unsupported algorithm \" + algorithm, Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"hmac\",\n            algorithm: algorithm\n        });\n    }\n\n    return \"0x\" + hash.hmac((<any>hash)[algorithm], arrayify(key)).update(arrayify(data)).digest(\"hex\");\n}\n\n","export const version = \"sha2/5.5.0\";\n","export enum SupportedAlgorithm { sha256 = \"sha256\", sha512 = \"sha512\" };\n\n","\"use strict\";\n\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { arrayify, concat, hexlify, zeroPad } from \"@ethersproject/bytes\";\nimport { keccak256 as hashKeccak256 } from \"@ethersproject/keccak256\";\nimport { sha256 as hashSha256 } from \"@ethersproject/sha2\";\nimport { toUtf8Bytes } from \"@ethersproject/strings\";\n\nconst regexBytes = new RegExp(\"^bytes([0-9]+)$\");\nconst regexNumber = new RegExp(\"^(u?int)([0-9]*)$\");\nconst regexArray = new RegExp(\"^(.*)\\\\[([0-9]*)\\\\]$\");\n\nconst Zeros = \"0000000000000000000000000000000000000000000000000000000000000000\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n\nfunction _pack(type: string, value: any, isArray?: boolean): Uint8Array {\n    switch(type) {\n        case \"address\":\n            if (isArray) { return zeroPad(value, 32); }\n            return arrayify(value);\n        case \"string\":\n            return toUtf8Bytes(value);\n        case \"bytes\":\n            return arrayify(value);\n        case \"bool\":\n            value = (value ? \"0x01\": \"0x00\");\n            if (isArray) { return zeroPad(value, 32); }\n            return arrayify(value);\n    }\n\n    let match =  type.match(regexNumber);\n    if (match) {\n        //let signed = (match[1] === \"int\")\n        let size = parseInt(match[2] || \"256\")\n\n        if ((match[2] && String(size) !== match[2]) || (size % 8 !== 0) || size === 0 || size > 256) {\n            logger.throwArgumentError(\"invalid number type\", \"type\", type)\n        }\n\n        if (isArray) { size = 256; }\n\n        value = BigNumber.from(value).toTwos(size);\n\n        return zeroPad(value, size / 8);\n    }\n\n    match = type.match(regexBytes);\n    if (match) {\n        const size = parseInt(match[1]);\n\n        if (String(size) !== match[1] || size === 0 || size > 32) {\n            logger.throwArgumentError(\"invalid bytes type\", \"type\", type)\n        }\n        if (arrayify(value).byteLength !== size) {\n            logger.throwArgumentError(`invalid value for ${ type }`, \"value\", value)\n        }\n        if (isArray) { return arrayify((value + Zeros).substring(0, 66)); }\n        return value;\n    }\n\n    match = type.match(regexArray);\n    if (match && Array.isArray(value)) {\n        const baseType = match[1];\n        const count = parseInt(match[2] || String(value.length));\n        if (count != value.length) {\n            logger.throwArgumentError(`invalid array length for ${ type }`, \"value\", value)\n        }\n        const result: Array<Uint8Array> = [];\n        value.forEach(function(value) {\n            result.push(_pack(baseType, value, true));\n        });\n        return concat(result);\n    }\n\n    return logger.throwArgumentError(\"invalid type\", \"type\", type)\n}\n\n// @TODO: Array Enum\n\nexport function pack(types: ReadonlyArray<string>, values: ReadonlyArray<any>) {\n    if (types.length != values.length) {\n        logger.throwArgumentError(\"wrong number of values; expected ${ types.length }\", \"values\", values)\n    }\n    const tight: Array<Uint8Array> = [];\n    types.forEach(function(type, index) {\n        tight.push(_pack(type, values[index]));\n    });\n    return hexlify(concat(tight));\n}\n\nexport function keccak256(types: ReadonlyArray<string>, values: ReadonlyArray<any>) {\n    return hashKeccak256(pack(types, values));\n}\n\nexport function sha256(types: ReadonlyArray<string>, values: ReadonlyArray<any>) {\n    return hashSha256(pack(types, values));\n}\n","export const version = \"solidity/5.5.0\";\n","'use strict'\nvar ALPHABET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l'\n\n// pre-compute lookup table\nvar ALPHABET_MAP = {}\nfor (var z = 0; z < ALPHABET.length; z++) {\n  var x = ALPHABET.charAt(z)\n\n  if (ALPHABET_MAP[x] !== undefined) throw new TypeError(x + ' is ambiguous')\n  ALPHABET_MAP[x] = z\n}\n\nfunction polymodStep (pre) {\n  var b = pre >> 25\n  return ((pre & 0x1FFFFFF) << 5) ^\n    (-((b >> 0) & 1) & 0x3b6a57b2) ^\n    (-((b >> 1) & 1) & 0x26508e6d) ^\n    (-((b >> 2) & 1) & 0x1ea119fa) ^\n    (-((b >> 3) & 1) & 0x3d4233dd) ^\n    (-((b >> 4) & 1) & 0x2a1462b3)\n}\n\nfunction prefixChk (prefix) {\n  var chk = 1\n  for (var i = 0; i < prefix.length; ++i) {\n    var c = prefix.charCodeAt(i)\n    if (c < 33 || c > 126) return 'Invalid prefix (' + prefix + ')'\n\n    chk = polymodStep(chk) ^ (c >> 5)\n  }\n  chk = polymodStep(chk)\n\n  for (i = 0; i < prefix.length; ++i) {\n    var v = prefix.charCodeAt(i)\n    chk = polymodStep(chk) ^ (v & 0x1f)\n  }\n  return chk\n}\n\nfunction encode (prefix, words, LIMIT) {\n  LIMIT = LIMIT || 90\n  if ((prefix.length + 7 + words.length) > LIMIT) throw new TypeError('Exceeds length limit')\n\n  prefix = prefix.toLowerCase()\n\n  // determine chk mod\n  var chk = prefixChk(prefix)\n  if (typeof chk === 'string') throw new Error(chk)\n\n  var result = prefix + '1'\n  for (var i = 0; i < words.length; ++i) {\n    var x = words[i]\n    if ((x >> 5) !== 0) throw new Error('Non 5-bit word')\n\n    chk = polymodStep(chk) ^ x\n    result += ALPHABET.charAt(x)\n  }\n\n  for (i = 0; i < 6; ++i) {\n    chk = polymodStep(chk)\n  }\n  chk ^= 1\n\n  for (i = 0; i < 6; ++i) {\n    var v = (chk >> ((5 - i) * 5)) & 0x1f\n    result += ALPHABET.charAt(v)\n  }\n\n  return result\n}\n\nfunction __decode (str, LIMIT) {\n  LIMIT = LIMIT || 90\n  if (str.length < 8) return str + ' too short'\n  if (str.length > LIMIT) return 'Exceeds length limit'\n\n  // don't allow mixed case\n  var lowered = str.toLowerCase()\n  var uppered = str.toUpperCase()\n  if (str !== lowered && str !== uppered) return 'Mixed-case string ' + str\n  str = lowered\n\n  var split = str.lastIndexOf('1')\n  if (split === -1) return 'No separator character for ' + str\n  if (split === 0) return 'Missing prefix for ' + str\n\n  var prefix = str.slice(0, split)\n  var wordChars = str.slice(split + 1)\n  if (wordChars.length < 6) return 'Data too short'\n\n  var chk = prefixChk(prefix)\n  if (typeof chk === 'string') return chk\n\n  var words = []\n  for (var i = 0; i < wordChars.length; ++i) {\n    var c = wordChars.charAt(i)\n    var v = ALPHABET_MAP[c]\n    if (v === undefined) return 'Unknown character ' + c\n    chk = polymodStep(chk) ^ v\n\n    // not in the checksum?\n    if (i + 6 >= wordChars.length) continue\n    words.push(v)\n  }\n\n  if (chk !== 1) return 'Invalid checksum for ' + str\n  return { prefix: prefix, words: words }\n}\n\nfunction decodeUnsafe () {\n  var res = __decode.apply(null, arguments)\n  if (typeof res === 'object') return res\n}\n\nfunction decode (str) {\n  var res = __decode.apply(null, arguments)\n  if (typeof res === 'object') return res\n\n  throw new Error(res)\n}\n\nfunction convert (data, inBits, outBits, pad) {\n  var value = 0\n  var bits = 0\n  var maxV = (1 << outBits) - 1\n\n  var result = []\n  for (var i = 0; i < data.length; ++i) {\n    value = (value << inBits) | data[i]\n    bits += inBits\n\n    while (bits >= outBits) {\n      bits -= outBits\n      result.push((value >> bits) & maxV)\n    }\n  }\n\n  if (pad) {\n    if (bits > 0) {\n      result.push((value << (outBits - bits)) & maxV)\n    }\n  } else {\n    if (bits >= inBits) return 'Excess padding'\n    if ((value << (outBits - bits)) & maxV) return 'Non-zero padding'\n  }\n\n  return result\n}\n\nfunction toWordsUnsafe (bytes) {\n  var res = convert(bytes, 8, 5, true)\n  if (Array.isArray(res)) return res\n}\n\nfunction toWords (bytes) {\n  var res = convert(bytes, 8, 5, true)\n  if (Array.isArray(res)) return res\n\n  throw new Error(res)\n}\n\nfunction fromWordsUnsafe (words) {\n  var res = convert(words, 5, 8, false)\n  if (Array.isArray(res)) return res\n}\n\nfunction fromWords (words) {\n  var res = convert(words, 5, 8, false)\n  if (Array.isArray(res)) return res\n\n  throw new Error(res)\n}\n\nmodule.exports = {\n  decodeUnsafe: decodeUnsafe,\n  decode: decode,\n  encode: encode,\n  toWordsUnsafe: toWordsUnsafe,\n  toWords: toWords,\n  fromWordsUnsafe: fromWordsUnsafe,\n  fromWords: fromWords\n}\n","export const version = \"abi/5.5.0\";\n","\"use strict\";\n\nimport { arrayify, BytesLike, concat, hexConcat, hexlify } from \"@ethersproject/bytes\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"../_version\";\nconst logger = new Logger(version);\n\nexport interface Result extends ReadonlyArray<any> {\n    readonly [key: string]: any;\n}\n\nexport function checkResultErrors(result: Result): Array<{ path: Array<string | number>, error: Error }> {\n    // Find the first error (if any)\n    const errors: Array<{ path: Array<string | number>, error: Error }> = [ ];\n\n    const checkErrors = function(path: Array<string | number>, object: any): void {\n        if (!Array.isArray(object)) { return; }\n        for (let key in object) {\n            const childPath = path.slice();\n            childPath.push(key);\n\n            try {\n                 checkErrors(childPath, object[key]);\n            } catch (error) {\n                errors.push({ path: childPath, error: error });\n            }\n        }\n    }\n    checkErrors([ ], result);\n\n    return errors;\n\n}\n\nexport type CoerceFunc = (type: string, value: any) => any;\n\nexport abstract class Coder {\n\n    // The coder name:\n    //   - address, uint256, tuple, array, etc.\n    readonly name: string;\n\n    // The fully expanded type, including composite types:\n    //   - address, uint256, tuple(address,bytes), uint256[3][4][],  etc.\n    readonly type: string;\n\n    // The localName bound in the signature, in this example it is \"baz\":\n    //   - tuple(address foo, uint bar) baz\n    readonly localName: string;\n\n    // Whether this type is dynamic:\n    //  - Dynamic: bytes, string, address[], tuple(boolean[]), etc.\n    //  - Not Dynamic: address, uint256, boolean[3], tuple(address, uint8)\n    readonly dynamic: boolean;\n\n    constructor(name: string, type: string, localName: string, dynamic: boolean) {\n        // @TODO: defineReadOnly these\n        this.name = name;\n        this.type = type;\n        this.localName = localName;\n        this.dynamic = dynamic;\n    }\n\n    _throwError(message: string, value: any): void {\n        logger.throwArgumentError(message, this.localName, value);\n    }\n\n    abstract encode(writer: Writer, value: any): number;\n    abstract decode(reader: Reader): any;\n\n    abstract defaultValue(): any;\n}\n\nexport class Writer {\n    readonly wordSize: number;\n\n    _data: Array<Uint8Array>;\n    _dataLength: number;\n    _padding: Uint8Array;\n\n    constructor(wordSize?: number) {\n        defineReadOnly(this, \"wordSize\", wordSize || 32);\n        this._data = [ ];\n        this._dataLength = 0;\n        this._padding = new Uint8Array(wordSize);\n    }\n\n    get data(): string {\n        return hexConcat(this._data);\n    }\n    get length(): number { return this._dataLength; }\n\n    _writeData(data: Uint8Array): number {\n        this._data.push(data);\n        this._dataLength += data.length;\n        return data.length;\n    }\n\n    appendWriter(writer: Writer): number {\n        return this._writeData(concat(writer._data));\n    }\n\n    // Arrayish items; padded on the right to wordSize\n    writeBytes(value: BytesLike): number {\n        let bytes = arrayify(value);\n        const paddingOffset = bytes.length % this.wordSize;\n        if (paddingOffset) {\n            bytes = concat([ bytes, this._padding.slice(paddingOffset) ])\n        }\n        return this._writeData(bytes);\n    }\n\n    _getValue(value: BigNumberish): Uint8Array {\n        let bytes = arrayify(BigNumber.from(value));\n        if (bytes.length > this.wordSize) {\n            logger.throwError(\"value out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n                length: this.wordSize,\n                offset: bytes.length\n            });\n        }\n        if (bytes.length % this.wordSize) {\n            bytes = concat([ this._padding.slice(bytes.length % this.wordSize), bytes ]);\n        }\n        return bytes;\n    }\n\n    // BigNumberish items; padded on the left to wordSize\n    writeValue(value: BigNumberish): number {\n        return this._writeData(this._getValue(value));\n    }\n\n    writeUpdatableValue(): (value: BigNumberish) => void {\n        const offset = this._data.length;\n        this._data.push(this._padding);\n        this._dataLength += this.wordSize;\n        return (value: BigNumberish) => {\n            this._data[offset] = this._getValue(value);\n        };\n    }\n}\n\nexport class Reader {\n    readonly wordSize: number;\n    readonly allowLoose: boolean;\n\n    readonly _data: Uint8Array;\n    readonly _coerceFunc: CoerceFunc;\n\n    _offset: number;\n\n    constructor(data: BytesLike, wordSize?: number, coerceFunc?: CoerceFunc, allowLoose?: boolean) {\n        defineReadOnly(this, \"_data\", arrayify(data));\n        defineReadOnly(this, \"wordSize\", wordSize || 32);\n        defineReadOnly(this, \"_coerceFunc\", coerceFunc);\n        defineReadOnly(this, \"allowLoose\", allowLoose);\n\n        this._offset = 0;\n    }\n\n    get data(): string { return hexlify(this._data); }\n    get consumed(): number { return this._offset; }\n\n    // The default Coerce function\n    static coerce(name: string, value: any): any {\n        let match = name.match(\"^u?int([0-9]+)$\");\n        if (match && parseInt(match[1]) <= 48) { value =  value.toNumber(); }\n        return value;\n    }\n\n    coerce(name: string, value: any): any {\n        if (this._coerceFunc) { return this._coerceFunc(name, value); }\n        return Reader.coerce(name, value);\n    }\n\n    _peekBytes(offset: number, length: number, loose?: boolean): Uint8Array {\n        let alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;\n        if (this._offset + alignedLength > this._data.length) {\n            if (this.allowLoose && loose && this._offset + length <= this._data.length) {\n                alignedLength = length;\n            } else {\n                logger.throwError(\"data out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n                    length: this._data.length,\n                    offset: this._offset + alignedLength\n                });\n            }\n        }\n        return this._data.slice(this._offset, this._offset + alignedLength)\n    }\n\n    subReader(offset: number): Reader {\n        return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);\n    }\n\n    readBytes(length: number, loose?: boolean): Uint8Array {\n        let bytes = this._peekBytes(0, length, !!loose);\n        this._offset += bytes.length;\n        // @TODO: Make sure the length..end bytes are all 0?\n        return bytes.slice(0, length);\n    }\n\n    readValue(): BigNumber {\n        return BigNumber.from(this.readBytes(this.wordSize));\n    }\n}\n","\"use strict\";\n\nimport { getAddress } from \"@ethersproject/address\";\nimport { hexZeroPad } from \"@ethersproject/bytes\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\nexport class AddressCoder extends Coder {\n\n    constructor(localName: string) {\n        super(\"address\", \"address\", localName, false);\n    }\n\n    defaultValue(): string {\n        return \"0x0000000000000000000000000000000000000000\";\n    }\n\n    encode(writer: Writer, value: string): number {\n        try {\n            value = getAddress(value)\n        } catch (error) {\n            this._throwError(error.message, value);\n        }\n        return writer.writeValue(value);\n    }\n\n    decode(reader: Reader): any {\n        return getAddress(hexZeroPad(reader.readValue().toHexString(), 20));\n    }\n}\n\n","\"use strict\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\n// Clones the functionality of an existing Coder, but without a localName\nexport class AnonymousCoder extends Coder {\n    private coder: Coder;\n\n    constructor(coder: Coder) {\n        super(coder.name, coder.type, undefined, coder.dynamic);\n        this.coder = coder;\n    }\n\n    defaultValue(): any {\n        return this.coder.defaultValue();\n    }\n\n    encode(writer: Writer, value: any): number {\n        return this.coder.encode(writer, value);\n    }\n\n    decode(reader: Reader): any {\n        return this.coder.decode(reader);\n    }\n}\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"../_version\";\nconst logger = new Logger(version);\n\nimport { Coder, Reader, Result, Writer } from \"./abstract-coder\";\nimport { AnonymousCoder } from \"./anonymous\";\n\nexport function pack(writer: Writer, coders: ReadonlyArray<Coder>, values: Array<any> | { [ name: string ]: any }): number {\n    let arrayValues: Array<any> = null;\n\n    if (Array.isArray(values)) {\n       arrayValues = values;\n\n    } else if (values && typeof(values) === \"object\") {\n        let unique: { [ name: string ]: boolean } = { };\n\n        arrayValues = coders.map((coder) => {\n            const name = coder.localName;\n            if (!name) {\n                logger.throwError(\"cannot encode object for signature with missing names\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"values\",\n                    coder: coder,\n                    value: values\n                });\n            }\n\n            if (unique[name]) {\n                logger.throwError(\"cannot encode object for signature with duplicate names\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"values\",\n                    coder: coder,\n                    value: values\n                });\n            }\n\n            unique[name] = true;\n\n            return values[name];\n        });\n\n    } else {\n        logger.throwArgumentError(\"invalid tuple value\", \"tuple\", values);\n    }\n\n    if (coders.length !== arrayValues.length) {\n        logger.throwArgumentError(\"types/value length mismatch\", \"tuple\", values);\n    }\n\n    let staticWriter = new Writer(writer.wordSize);\n    let dynamicWriter = new Writer(writer.wordSize);\n\n    let updateFuncs: Array<(baseOffset: number) => void> = [];\n    coders.forEach((coder, index) => {\n        let value = arrayValues[index];\n\n        if (coder.dynamic) {\n            // Get current dynamic offset (for the future pointer)\n            let dynamicOffset = dynamicWriter.length;\n\n            // Encode the dynamic value into the dynamicWriter\n            coder.encode(dynamicWriter, value);\n\n            // Prepare to populate the correct offset once we are done\n            let updateFunc = staticWriter.writeUpdatableValue();\n            updateFuncs.push((baseOffset: number) => {\n                updateFunc(baseOffset + dynamicOffset);\n            });\n\n        } else {\n            coder.encode(staticWriter, value);\n        }\n    });\n\n    // Backfill all the dynamic offsets, now that we know the static length\n    updateFuncs.forEach((func) => { func(staticWriter.length); });\n\n    let length = writer.appendWriter(staticWriter);\n    length += writer.appendWriter(dynamicWriter);\n    return length;\n}\n\nexport function unpack(reader: Reader, coders: Array<Coder>): Result {\n    let values: any = [];\n\n    // A reader anchored to this base\n    let baseReader = reader.subReader(0);\n\n    coders.forEach((coder) => {\n        let value: any = null;\n\n        if (coder.dynamic) {\n            let offset = reader.readValue();\n            let offsetReader = baseReader.subReader(offset.toNumber());\n            try {\n                value = coder.decode(offsetReader);\n            } catch (error) {\n                // Cannot recover from this\n                if (error.code === Logger.errors.BUFFER_OVERRUN) { throw error; }\n                value = error;\n                value.baseType = coder.name;\n                value.name = coder.localName;\n                value.type = coder.type;\n            }\n\n        } else {\n            try {\n                value = coder.decode(reader);\n            } catch (error) {\n                // Cannot recover from this\n                if (error.code === Logger.errors.BUFFER_OVERRUN) { throw error; }\n                value = error;\n                value.baseType = coder.name;\n                value.name = coder.localName;\n                value.type = coder.type;\n            }\n        }\n\n        if (value != undefined) {\n            values.push(value);\n        }\n    });\n\n    // We only output named properties for uniquely named coders\n    const uniqueNames = coders.reduce((accum, coder) => {\n        const name = coder.localName;\n        if (name) {\n            if (!accum[name]) { accum[name] = 0; }\n            accum[name]++;\n        }\n        return accum;\n    }, <{ [ name: string ]: number }>{ });\n\n    // Add any named parameters (i.e. tuples)\n    coders.forEach((coder: Coder, index: number) => {\n        let name = coder.localName;\n        if (!name || uniqueNames[name] !== 1) { return; }\n\n        if (name === \"length\") { name = \"_length\"; }\n\n        if (values[name] != null) { return; }\n\n        const value = values[index];\n\n        if (value instanceof Error) {\n            Object.defineProperty(values, name, {\n                enumerable: true,\n                get: () => { throw value; }\n            });\n        } else {\n            values[name] = value;\n        }\n    });\n\n    for (let i = 0; i < values.length; i++) {\n        const value = values[i];\n        if (value instanceof Error) {\n            Object.defineProperty(values, i, {\n                enumerable: true,\n                get: () => { throw value; }\n            });\n        }\n    }\n\n    return Object.freeze(values);\n}\n\n\nexport class ArrayCoder extends Coder {\n    readonly coder: Coder;\n    readonly length: number;\n\n    constructor(coder: Coder, length: number, localName: string) {\n        const type = (coder.type + \"[\" + (length >= 0 ? length: \"\") + \"]\");\n        const dynamic = (length === -1 || coder.dynamic);\n        super(\"array\", type, localName, dynamic);\n\n        this.coder = coder;\n        this.length = length;\n    }\n\n    defaultValue(): Array<any> {\n        // Verifies the child coder is valid (even if the array is dynamic or 0-length)\n        const defaultChild = this.coder.defaultValue();\n\n        const result: Array<any> = [];\n        for (let i = 0; i < this.length; i++) {\n            result.push(defaultChild);\n        }\n        return result;\n    }\n\n    encode(writer: Writer, value: Array<any>): number {\n        if (!Array.isArray(value)) {\n            this._throwError(\"expected array value\", value);\n        }\n\n        let count = this.length;\n\n        if (count === -1) {\n            count = value.length;\n            writer.writeValue(value.length);\n        }\n\n        logger.checkArgumentCount(value.length, count, \"coder array\" + (this.localName? (\" \"+ this.localName): \"\"));\n\n        let coders = [];\n        for (let i = 0; i < value.length; i++) { coders.push(this.coder); }\n\n        return pack(writer, coders, value);\n    }\n\n    decode(reader: Reader): any {\n        let count = this.length;\n        if (count === -1) {\n            count = reader.readValue().toNumber();\n\n            // Check that there is *roughly* enough data to ensure\n            // stray random data is not being read as a length. Each\n            // slot requires at least 32 bytes for their value (or 32\n            // bytes as a link to the data). This could use a much\n            // tighter bound, but we are erroring on the side of safety.\n            if (count * 32 > reader._data.length) {\n                logger.throwError(\"insufficient data length\", Logger.errors.BUFFER_OVERRUN, {\n                    length: reader._data.length,\n                    count: count\n                });\n            }\n        }\n        let coders = [];\n        for (let i = 0; i < count; i++) { coders.push(new AnonymousCoder(this.coder)); }\n\n        return reader.coerce(this.name, unpack(reader, coders));\n    }\n}\n\n","\"use strict\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\nexport class BooleanCoder extends Coder {\n\n    constructor(localName: string) {\n        super(\"bool\", \"bool\", localName, false);\n    }\n\n    defaultValue(): boolean {\n        return false;\n    }\n\n    encode(writer: Writer, value: boolean): number {\n        return writer.writeValue(value ? 1: 0);\n    }\n\n    decode(reader: Reader): any {\n        return reader.coerce(this.type, !reader.readValue().isZero());\n    }\n}\n\n","\"use strict\";\n\nimport { arrayify, hexlify } from \"@ethersproject/bytes\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\nexport class DynamicBytesCoder extends Coder {\n    constructor(type: string, localName: string) {\n       super(type, type, localName, true);\n    }\n\n    defaultValue(): string {\n        return \"0x\";\n    }\n\n    encode(writer: Writer, value: any): number {\n        value = arrayify(value);\n        let length = writer.writeValue(value.length);\n        length += writer.writeBytes(value);\n        return length;\n    }\n\n    decode(reader: Reader): any {\n        return reader.readBytes(reader.readValue().toNumber(), true);\n    }\n}\n\nexport class BytesCoder extends DynamicBytesCoder {\n    constructor(localName: string) {\n        super(\"bytes\", localName);\n    }\n\n    decode(reader: Reader): any {\n        return reader.coerce(this.name, hexlify(super.decode(reader)));\n    }\n}\n\n\n","\"use strict\";\n\nimport { arrayify, BytesLike, hexlify } from \"@ethersproject/bytes\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\n// @TODO: Merge this with bytes\nexport class FixedBytesCoder extends Coder {\n    readonly size: number;\n\n    constructor(size: number, localName: string) {\n        let name = \"bytes\" + String(size);\n        super(name, name, localName, false);\n        this.size = size;\n    }\n\n    defaultValue(): string {\n        return (\"0x0000000000000000000000000000000000000000000000000000000000000000\").substring(0, 2 + this.size * 2);\n    }\n\n    encode(writer: Writer, value: BytesLike): number {\n        let data = arrayify(value);\n        if (data.length !== this.size) { this._throwError(\"incorrect data length\", value); }\n        return writer.writeBytes(data);\n    }\n\n    decode(reader: Reader): any {\n        return reader.coerce(this.name, hexlify(reader.readBytes(this.size)));\n    }\n}\n","\"use strict\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\nexport class NullCoder extends Coder {\n\n    constructor(localName: string) {\n        super(\"null\", \"\", localName, false);\n    }\n\n    defaultValue(): null {\n        return null;\n    }\n\n    encode(writer: Writer, value: any): number {\n        if (value != null) { this._throwError(\"not null\", value); }\n        return writer.writeBytes([ ]);\n    }\n\n    decode(reader: Reader): any {\n        reader.readBytes(0);\n        return reader.coerce(this.name, null);\n    }\n}\n","\"use strict\";\n\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { MaxUint256, NegativeOne, One, Zero } from \"@ethersproject/constants\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\nexport class NumberCoder extends Coder {\n    readonly size: number;\n    readonly signed: boolean;\n\n    constructor(size: number, signed: boolean, localName: string) {\n        const name = ((signed ? \"int\": \"uint\") + (size * 8));\n        super(name, name, localName, false);\n\n        this.size = size;\n        this.signed = signed;\n    }\n\n    defaultValue(): number {\n        return 0;\n    }\n\n    encode(writer: Writer, value: BigNumberish): number {\n        let v = BigNumber.from(value);\n\n        // Check bounds are safe for encoding\n        let maxUintValue = MaxUint256.mask(writer.wordSize * 8);\n        if (this.signed) {\n            let bounds = maxUintValue.mask(this.size * 8 - 1);\n            if (v.gt(bounds) || v.lt(bounds.add(One).mul(NegativeOne))) {\n                this._throwError(\"value out-of-bounds\", value);\n            }\n        } else if (v.lt(Zero) || v.gt(maxUintValue.mask(this.size * 8))) {\n            this._throwError(\"value out-of-bounds\", value);\n        }\n\n        v = v.toTwos(this.size * 8).mask(this.size * 8);\n\n        if (this.signed) {\n            v = v.fromTwos(this.size * 8).toTwos(8 * writer.wordSize);\n        }\n\n        return writer.writeValue(v);\n    }\n\n    decode(reader: Reader): any {\n        let value = reader.readValue().mask(this.size * 8);\n\n        if (this.signed) {\n            value = value.fromTwos(this.size * 8);\n        }\n\n        return reader.coerce(this.name, value);\n    }\n}\n\n","\"use strict\";\n\nimport { toUtf8Bytes, toUtf8String } from \"@ethersproject/strings\";\n\nimport { Reader, Writer } from \"./abstract-coder\";\nimport { DynamicBytesCoder } from \"./bytes\";\n\nexport class StringCoder extends DynamicBytesCoder {\n\n    constructor(localName: string) {\n        super(\"string\", localName);\n    }\n\n    defaultValue(): string {\n        return \"\";\n    }\n\n    encode(writer: Writer, value: any): number {\n        return super.encode(writer, toUtf8Bytes(value));\n    }\n\n    decode(reader: Reader): any {\n        return toUtf8String(super.decode(reader));\n    }\n}\n","\"use strict\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\nimport { pack, unpack } from \"./array\";\n\nexport class TupleCoder extends Coder {\n    readonly coders: Array<Coder>;\n\n    constructor(coders: Array<Coder>, localName: string) {\n        let dynamic = false;\n        const types: Array<string> = [];\n        coders.forEach((coder) => {\n            if (coder.dynamic) { dynamic = true; }\n            types.push(coder.type);\n        });\n        const type = (\"tuple(\" + types.join(\",\") + \")\");\n\n        super(\"tuple\", type, localName, dynamic);\n        this.coders = coders;\n    }\n\n    defaultValue(): any {\n        const values: any = [ ];\n        this.coders.forEach((coder) => {\n            values.push(coder.defaultValue());\n        });\n\n        // We only output named properties for uniquely named coders\n        const uniqueNames = this.coders.reduce((accum, coder) => {\n            const name = coder.localName;\n            if (name) {\n                if (!accum[name]) { accum[name] = 0; }\n                accum[name]++;\n            }\n            return accum;\n        }, <{ [ name: string ]: number }>{ });\n\n        // Add named values\n        this.coders.forEach((coder: Coder, index: number) => {\n            let name = coder.localName;\n            if (!name || uniqueNames[name] !== 1) { return; }\n\n            if (name === \"length\") { name = \"_length\"; }\n\n            if (values[name] != null) { return; }\n\n            values[name] = values[index];\n        });\n\n        return Object.freeze(values);\n    }\n\n    encode(writer: Writer, value: Array<any> | { [ name: string ]: any }): number {\n        return pack(writer, this.coders, value);\n    }\n\n    decode(reader: Reader): any {\n        return reader.coerce(this.name, unpack(reader, this.coders));\n    }\n}\n\n","\"use strict\";\n\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport interface JsonFragmentType {\n    readonly name?: string;\n    readonly indexed?: boolean;\n    readonly type?: string;\n    readonly internalType?: any; // @TODO: in v6 reduce type\n    readonly components?: ReadonlyArray<JsonFragmentType>;\n}\n\nexport interface JsonFragment {\n    readonly name?: string;\n    readonly type?: string;\n\n    readonly anonymous?: boolean;\n\n    readonly payable?: boolean;\n    readonly constant?: boolean;\n    readonly stateMutability?: string;\n\n    readonly inputs?: ReadonlyArray<JsonFragmentType>;\n    readonly outputs?: ReadonlyArray<JsonFragmentType>;\n\n    readonly gas?: string;\n};\n\nconst _constructorGuard = { };\n\n// AST Node parser state\ntype ParseState = {\n    allowArray?: boolean,\n    allowName?: boolean,\n    allowParams?: boolean,\n    allowType?: boolean,\n    readArray?: boolean,\n};\n\n// AST Node\ntype ParseNode = {\n    parent?: any,\n    type?: string,\n    name?: string,\n    state?: ParseState,\n    indexed?: boolean,\n    components?: Array<ParseNode>\n};\n\nlet ModifiersBytes: { [ name: string ]: boolean } = { calldata: true, memory: true, storage: true };\nlet ModifiersNest: { [ name: string ]: boolean } = { calldata: true, memory: true };\nfunction checkModifier(type: string, name: string): boolean {\n    if (type === \"bytes\" || type === \"string\") {\n        if (ModifiersBytes[name]) { return true; }\n    } else if (type === \"address\") {\n        if (name === \"payable\") { return true; }\n    } else if (type.indexOf(\"[\") >= 0 || type === \"tuple\") {\n        if (ModifiersNest[name]) { return true; }\n    }\n    if (ModifiersBytes[name] || name === \"payable\") {\n        logger.throwArgumentError(\"invalid modifier\", \"name\", name);\n    }\n    return false;\n}\n\n// @TODO: Make sure that children of an indexed tuple are marked with a null indexed\nfunction parseParamType(param: string, allowIndexed: boolean): ParseNode {\n\n    let originalParam = param;\n    function throwError(i: number) {\n        logger.throwArgumentError(`unexpected character at position ${ i }`, \"param\", param);\n    }\n    param = param.replace(/\\s/g, \" \");\n\n    function newNode(parent: ParseNode): ParseNode {\n        let node: ParseNode = { type: \"\", name: \"\", parent: parent, state: { allowType: true } };\n        if (allowIndexed) { node.indexed = false; }\n        return node\n    }\n\n    let parent: ParseNode = { type: \"\", name: \"\", state: { allowType: true } };\n    let node = parent;\n\n    for (let i = 0; i < param.length; i++) {\n        let c = param[i];\n        switch (c) {\n            case \"(\":\n                if (node.state.allowType && node.type === \"\") {\n                    node.type = \"tuple\";\n                } else if (!node.state.allowParams) {\n                    throwError(i);\n                }\n                node.state.allowType = false;\n                node.type = verifyType(node.type);\n                node.components = [ newNode(node) ];\n                node = node.components[0];\n                break;\n\n            case \")\":\n                delete node.state;\n\n                if (node.name === \"indexed\") {\n                    if (!allowIndexed) { throwError(i); }\n                    node.indexed = true;\n                    node.name = \"\";\n                }\n\n                if (checkModifier(node.type, node.name)) { node.name = \"\"; }\n\n                node.type = verifyType(node.type);\n\n                let child = node;\n                node = node.parent;\n                if (!node) { throwError(i); }\n                delete child.parent;\n                node.state.allowParams = false;\n                node.state.allowName = true;\n                node.state.allowArray = true;\n                break;\n\n            case \",\":\n                delete node.state;\n\n                if (node.name === \"indexed\") {\n                    if (!allowIndexed) { throwError(i); }\n                    node.indexed = true;\n                    node.name = \"\";\n                }\n\n                if (checkModifier(node.type, node.name)) { node.name = \"\"; }\n\n                node.type = verifyType(node.type);\n\n                let sibling: ParseNode = newNode(node.parent);\n                 //{ type: \"\", name: \"\", parent: node.parent, state: { allowType: true } };\n                node.parent.components.push(sibling);\n                delete node.parent;\n                node = sibling;\n                break;\n\n            // Hit a space...\n            case \" \":\n\n                // If reading type, the type is done and may read a param or name\n                if (node.state.allowType) {\n                    if (node.type !== \"\") {\n                        node.type = verifyType(node.type);\n                        delete node.state.allowType;\n                        node.state.allowName = true;\n                        node.state.allowParams = true;\n                    }\n                }\n\n                // If reading name, the name is done\n                if (node.state.allowName) {\n                    if (node.name !== \"\") {\n                        if (node.name === \"indexed\") {\n                            if (!allowIndexed) { throwError(i); }\n                            if (node.indexed) { throwError(i); }\n                            node.indexed = true;\n                            node.name = \"\";\n                        } else if (checkModifier(node.type, node.name)) {\n                            node.name = \"\";\n                        } else {\n                            node.state.allowName = false;\n                        }\n                    }\n                }\n\n                break;\n\n            case \"[\":\n                if (!node.state.allowArray) { throwError(i); }\n\n                node.type += c;\n\n                node.state.allowArray = false;\n                node.state.allowName = false;\n                node.state.readArray = true;\n                break;\n\n            case \"]\":\n                if (!node.state.readArray) { throwError(i); }\n\n                node.type += c;\n\n                node.state.readArray = false;\n                node.state.allowArray = true;\n                node.state.allowName = true;\n                break;\n\n            default:\n                if (node.state.allowType) {\n                    node.type += c;\n                    node.state.allowParams = true;\n                    node.state.allowArray = true;\n                } else if (node.state.allowName) {\n                    node.name += c;\n                    delete node.state.allowArray;\n                } else if (node.state.readArray) {\n                    node.type += c;\n                } else {\n                    throwError(i);\n               }\n        }\n    }\n\n    if (node.parent) { logger.throwArgumentError(\"unexpected eof\", \"param\", param); }\n\n    delete parent.state;\n\n    if (node.name === \"indexed\") {\n        if (!allowIndexed) { throwError(originalParam.length - 7); }\n        if (node.indexed) { throwError(originalParam.length - 7); }\n        node.indexed = true;\n        node.name = \"\";\n    } else if (checkModifier(node.type, node.name)) {\n        node.name = \"\";\n    }\n\n    parent.type = verifyType(parent.type);\n\n    return parent;\n}\n\nfunction populate(object: any, params: any) {\n    for (let key in params) { defineReadOnly(object, key, params[key]); }\n}\n\nexport const FormatTypes: { [ name: string ]: string } = Object.freeze({\n    // Bare formatting, as is needed for computing a sighash of an event or function\n    sighash: \"sighash\",\n\n    // Human-Readable with Minimal spacing and without names (compact human-readable)\n    minimal: \"minimal\",\n\n    // Human-Readable with nice spacing, including all names\n    full: \"full\",\n\n    // JSON-format a la Solidity\n    json: \"json\"\n});\n\nconst paramTypeArray = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\n\nexport class ParamType {\n\n    // The local name of the parameter (of null if unbound)\n    readonly name: string;\n\n    // The fully qualified type (e.g. \"address\", \"tuple(address)\", \"uint256[3][]\"\n    readonly type: string;\n\n    // The base type (e.g. \"address\", \"tuple\", \"array\")\n    readonly baseType: string;\n\n    // Indexable Paramters ONLY (otherwise null)\n    readonly indexed: boolean;\n\n    // Tuples ONLY: (otherwise null)\n    //  - sub-components\n    readonly components: Array<ParamType>;\n\n    // Arrays ONLY: (otherwise null)\n    //  - length of the array (-1 for dynamic length)\n    //  - child type\n    readonly arrayLength: number;\n    readonly arrayChildren: ParamType;\n\n    readonly _isParamType: boolean;\n\n    constructor(constructorGuard: any, params: any) {\n        if (constructorGuard !== _constructorGuard) { logger.throwError(\"use fromString\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"new ParamType()\"\n        }); }\n        populate(this, params);\n\n        let match = this.type.match(paramTypeArray);\n        if (match) {\n            populate(this, {\n                arrayLength: parseInt(match[2] || \"-1\"),\n                arrayChildren: ParamType.fromObject({\n                    type: match[1],\n                    components: this.components\n                }),\n                baseType: \"array\"\n            });\n        } else {\n            populate(this, {\n                arrayLength: null,\n                arrayChildren: null,\n                baseType: ((this.components != null) ? \"tuple\": this.type)\n            });\n        }\n\n        this._isParamType = true;\n\n        Object.freeze(this);\n    }\n\n    // Format the parameter fragment\n    //   - sighash: \"(uint256,address)\"\n    //   - minimal: \"tuple(uint256,address) indexed\"\n    //   - full:    \"tuple(uint256 foo, address bar) indexed baz\"\n    format(format?: string): string {\n        if (!format) { format = FormatTypes.sighash; }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n\n        if (format === FormatTypes.json) {\n            let result: any = {\n                type: ((this.baseType === \"tuple\") ? \"tuple\": this.type),\n                name: (this.name || undefined)\n            };\n            if (typeof(this.indexed) === \"boolean\") { result.indexed = this.indexed; }\n            if (this.components) {\n                result.components = this.components.map((comp) => JSON.parse(comp.format(format)));\n            }\n            return JSON.stringify(result);\n        }\n\n        let result = \"\";\n\n        // Array\n        if (this.baseType === \"array\") {\n            result += this.arrayChildren.format(format);\n            result += \"[\" + (this.arrayLength < 0 ? \"\": String(this.arrayLength)) + \"]\";\n        } else {\n            if (this.baseType === \"tuple\") {\n                if (format !== FormatTypes.sighash) {\n                    result += this.type;\n                }\n                result += \"(\" + this.components.map(\n                    (comp) => comp.format(format)\n                ).join((format === FormatTypes.full) ? \", \": \",\") + \")\";\n            } else {\n                result += this.type;\n            }\n        }\n\n        if (format !== FormatTypes.sighash) {\n            if (this.indexed === true) { result += \" indexed\"; }\n            if (format === FormatTypes.full && this.name) {\n                result += \" \" + this.name;\n            }\n        }\n\n        return result;\n    }\n\n    static from(value: string | JsonFragmentType | ParamType, allowIndexed?: boolean): ParamType {\n        if (typeof(value) === \"string\") {\n            return ParamType.fromString(value, allowIndexed);\n        }\n        return ParamType.fromObject(value);\n    }\n\n    static fromObject(value: JsonFragmentType | ParamType): ParamType {\n        if (ParamType.isParamType(value)) { return value; }\n\n        return new ParamType(_constructorGuard, {\n            name: (value.name || null),\n            type: verifyType(value.type),\n            indexed: ((value.indexed == null) ? null: !!value.indexed),\n            components: (value.components ? value.components.map(ParamType.fromObject): null)\n        });\n    }\n\n    static fromString(value: string, allowIndexed?: boolean): ParamType {\n        function ParamTypify(node: ParseNode): ParamType {\n            return ParamType.fromObject({\n                name: node.name,\n                type: node.type,\n                indexed: node.indexed,\n                components: node.components\n            });\n        }\n\n        return ParamTypify(parseParamType(value, !!allowIndexed));\n    }\n\n    static isParamType(value: any): value is ParamType {\n        return !!(value != null && value._isParamType);\n    }\n};\n\nfunction parseParams(value: string, allowIndex: boolean): Array<ParamType> {\n    return splitNesting(value).map((param) => ParamType.fromString(param, allowIndex));\n}\n\ntype TypeCheck<T> = { -readonly [ K in keyof T ]: T[K] };\n\ninterface _Fragment {\n    readonly type: string;\n    readonly name: string;\n    readonly inputs: ReadonlyArray<ParamType>;\n}\n\nexport abstract class Fragment {\n\n    readonly type: string;\n    readonly name: string;\n    readonly inputs: Array<ParamType>;\n\n    readonly _isFragment: boolean;\n\n    constructor(constructorGuard: any, params: any) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"use a static from method\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new Fragment()\"\n            });\n        }\n        populate(this, params);\n\n        this._isFragment = true;\n\n        Object.freeze(this);\n    }\n\n    abstract format(format?: string): string;\n\n    static from(value: Fragment | JsonFragment | string): Fragment {\n        if (Fragment.isFragment(value)) { return value; }\n\n        if (typeof(value) === \"string\") {\n            return Fragment.fromString(value);\n        }\n\n        return Fragment.fromObject(value);\n    }\n\n    static fromObject(value: Fragment | JsonFragment): Fragment {\n        if (Fragment.isFragment(value)) { return value; }\n\n        switch (value.type) {\n            case \"function\":\n                return FunctionFragment.fromObject(value);\n            case \"event\":\n                return EventFragment.fromObject(value);\n            case \"constructor\":\n                return ConstructorFragment.fromObject(value);\n            case \"error\":\n                return ErrorFragment.fromObject(value);\n            case \"fallback\":\n            case \"receive\":\n                // @TODO: Something? Maybe return a FunctionFragment? A custom DefaultFunctionFragment?\n                return null;\n        }\n\n        return logger.throwArgumentError(\"invalid fragment object\", \"value\", value);\n    }\n\n    static fromString(value: string): Fragment {\n        // Make sure the \"returns\" is surrounded by a space and all whitespace is exactly one space\n        value = value.replace(/\\s/g, \" \");\n        value = value.replace(/\\(/g, \" (\").replace(/\\)/g, \") \").replace(/\\s+/g, \" \");\n        value = value.trim();\n\n        if (value.split(\" \")[0] === \"event\") {\n           return EventFragment.fromString(value.substring(5).trim());\n        } else if (value.split(\" \")[0] === \"function\") {\n            return FunctionFragment.fromString(value.substring(8).trim());\n        } else if (value.split(\"(\")[0].trim() === \"constructor\") {\n            return ConstructorFragment.fromString(value.trim());\n        } else if (value.split(\" \")[0] === \"error\") {\n           return ErrorFragment.fromString(value.substring(5).trim());\n        }\n\n        return logger.throwArgumentError(\"unsupported fragment\", \"value\", value);\n    }\n\n    static isFragment(value: any): value is Fragment {\n        return !!(value && value._isFragment);\n    }\n}\n\ninterface _EventFragment extends _Fragment {\n    readonly anonymous: boolean;\n}\n\nexport class EventFragment extends Fragment {\n    readonly anonymous: boolean;\n\n    format(format?: string): string {\n        if (!format) { format = FormatTypes.sighash; }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"event\",\n                anonymous: this.anonymous,\n                name: this.name,\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format)))\n            });\n        }\n\n        let result = \"\";\n\n        if (format !== FormatTypes.sighash) {\n            result += \"event \";\n        }\n\n        result += this.name + \"(\" + this.inputs.map(\n            (input) => input.format(format)\n        ).join((format === FormatTypes.full) ? \", \": \",\") + \") \";\n\n        if (format !== FormatTypes.sighash) {\n            if (this.anonymous) {\n                result += \"anonymous \";\n            }\n        }\n\n        return result.trim();\n    }\n\n    static from(value: EventFragment | JsonFragment | string): EventFragment {\n        if (typeof(value) === \"string\") {\n            return EventFragment.fromString(value);\n        }\n        return EventFragment.fromObject(value);\n    }\n\n    static fromObject(value: JsonFragment | EventFragment): EventFragment {\n        if (EventFragment.isEventFragment(value)) { return value; }\n\n        if (value.type !== \"event\") {\n            logger.throwArgumentError(\"invalid event object\", \"value\", value);\n        }\n\n        const params: TypeCheck<_EventFragment> = {\n            name: verifyIdentifier(value.name),\n            anonymous: value.anonymous,\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),\n            type: \"event\"\n        };\n\n        return new EventFragment(_constructorGuard, params);\n    }\n\n    static fromString(value: string): EventFragment {\n\n        let match = value.match(regexParen);\n        if (!match) {\n            logger.throwArgumentError(\"invalid event string\", \"value\", value);\n        }\n\n        let anonymous = false;\n        match[3].split(\" \").forEach((modifier) => {\n            switch(modifier.trim()) {\n                case \"anonymous\":\n                    anonymous = true;\n                    break;\n                case \"\":\n                    break;\n                default:\n                    logger.warn(\"unknown modifier: \" + modifier);\n            }\n        });\n\n        return EventFragment.fromObject({\n            name: match[1].trim(),\n            anonymous: anonymous,\n            inputs: parseParams(match[2], true),\n            type: \"event\"\n        });\n    }\n\n    static isEventFragment(value: any): value is EventFragment {\n        return (value && value._isFragment && value.type === \"event\");\n    }\n}\n\nfunction parseGas(value: string, params: any): string {\n    params.gas = null;\n\n    let comps = value.split(\"@\");\n    if (comps.length !== 1) {\n        if (comps.length > 2) {\n            logger.throwArgumentError(\"invalid human-readable ABI signature\", \"value\", value);\n        }\n        if (!comps[1].match(/^[0-9]+$/)) {\n            logger.throwArgumentError(\"invalid human-readable ABI signature gas\", \"value\", value);\n        }\n        params.gas = BigNumber.from(comps[1]);\n        return comps[0];\n    }\n\n    return value;\n}\n\nfunction parseModifiers(value: string, params: any): void {\n    params.constant = false;\n    params.payable = false;\n    params.stateMutability = \"nonpayable\";\n\n    value.split(\" \").forEach((modifier) => {\n        switch (modifier.trim()) {\n            case \"constant\":\n                params.constant = true;\n                break;\n            case \"payable\":\n                params.payable = true;\n                params.stateMutability = \"payable\";\n                break;\n            case \"nonpayable\":\n                params.payable = false;\n                params.stateMutability = \"nonpayable\";\n                break;\n            case \"pure\":\n                params.constant = true;\n                params.stateMutability = \"pure\";\n                break;\n            case \"view\":\n                params.constant = true;\n                params.stateMutability = \"view\";\n                break;\n            case \"external\":\n            case \"public\":\n            case \"\":\n                break;\n            default:\n                console.log(\"unknown modifier: \" + modifier);\n        }\n    });\n}\n\ntype StateInputValue = {\n    constant?: boolean;\n    payable?: boolean;\n    stateMutability?: string;\n    type?: string;\n};\n\ntype StateOutputValue = {\n    constant: boolean;\n    payable: boolean;\n    stateMutability: string;\n};\n\nfunction verifyState(value: StateInputValue): StateOutputValue {\n    let result: any = {\n        constant: false,\n        payable: true,\n        stateMutability: \"payable\"\n    };\n\n    if (value.stateMutability != null) {\n        result.stateMutability = value.stateMutability;\n\n        // Set (and check things are consistent) the constant property\n        result.constant = (result.stateMutability === \"view\" || result.stateMutability === \"pure\");\n        if (value.constant != null) {\n            if ((!!value.constant) !== result.constant) {\n                logger.throwArgumentError(\"cannot have constant function with mutability \" + result.stateMutability, \"value\", value);\n            }\n        }\n\n        // Set (and check things are consistent) the payable property\n        result.payable = (result.stateMutability === \"payable\");\n        if (value.payable != null) {\n            if ((!!value.payable) !== result.payable) {\n                logger.throwArgumentError(\"cannot have payable function with mutability \" + result.stateMutability, \"value\", value);\n            }\n        }\n\n    } else if (value.payable != null) {\n        result.payable = !!value.payable;\n\n        // If payable we can assume non-constant; otherwise we can't assume\n        if (value.constant == null && !result.payable && value.type !== \"constructor\") {\n            logger.throwArgumentError(\"unable to determine stateMutability\", \"value\", value);\n        }\n\n        result.constant = !!value.constant;\n\n        if (result.constant) {\n            result.stateMutability = \"view\";\n        } else {\n            result.stateMutability = (result.payable ? \"payable\": \"nonpayable\");\n        }\n\n        if (result.payable && result.constant) {\n            logger.throwArgumentError(\"cannot have constant payable function\", \"value\", value);\n        }\n\n    } else if (value.constant != null) {\n        result.constant = !!value.constant;\n        result.payable = !result.constant;\n        result.stateMutability = (result.constant ? \"view\": \"payable\");\n\n    } else if (value.type !== \"constructor\") {\n        logger.throwArgumentError(\"unable to determine stateMutability\", \"value\", value);\n    }\n\n    return result;\n}\n\ninterface _ConstructorFragment extends _Fragment {\n    stateMutability: string;\n    payable: boolean;\n    gas?: BigNumber;\n}\n\nexport class ConstructorFragment extends Fragment {\n    stateMutability: string;\n    payable: boolean;\n    gas?: BigNumber;\n\n    format(format?: string): string {\n        if (!format) { format = FormatTypes.sighash; }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"constructor\",\n                stateMutability: ((this.stateMutability !== \"nonpayable\") ? this.stateMutability: undefined),\n                payable: this.payable,\n                gas: (this.gas ? this.gas.toNumber(): undefined),\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format)))\n            });\n        }\n\n        if (format === FormatTypes.sighash) {\n            logger.throwError(\"cannot format a constructor for sighash\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"format(sighash)\"\n            });\n        }\n\n        let result = \"constructor(\" + this.inputs.map(\n            (input) => input.format(format)\n        ).join((format === FormatTypes.full) ? \", \": \",\") + \") \";\n\n        if (this.stateMutability && this.stateMutability !== \"nonpayable\") {\n            result += this.stateMutability + \" \";\n        }\n\n        return result.trim();\n    }\n\n    static from(value: ConstructorFragment | JsonFragment | string): ConstructorFragment {\n        if (typeof(value) === \"string\") {\n            return ConstructorFragment.fromString(value);\n        }\n        return ConstructorFragment.fromObject(value);\n    }\n\n    static fromObject(value: ConstructorFragment | JsonFragment): ConstructorFragment {\n        if (ConstructorFragment.isConstructorFragment(value)) { return value; }\n\n        if (value.type !== \"constructor\") {\n            logger.throwArgumentError(\"invalid constructor object\", \"value\", value);\n        }\n\n        let state = verifyState(value);\n        if (state.constant) {\n            logger.throwArgumentError(\"constructor cannot be constant\", \"value\", value);\n        }\n\n        const params: TypeCheck<_ConstructorFragment> = {\n            name: null,\n            type: value.type,\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject): []),\n            payable: state.payable,\n            stateMutability: state.stateMutability,\n            gas: (value.gas ? BigNumber.from(value.gas): null)\n        };\n\n        return new ConstructorFragment(_constructorGuard, params);\n    }\n\n    static fromString(value: string): ConstructorFragment {\n        let params: any = { type: \"constructor\" };\n\n        value = parseGas(value, params);\n\n        let parens = value.match(regexParen);\n        if (!parens || parens[1].trim() !== \"constructor\") {\n            logger.throwArgumentError(\"invalid constructor string\", \"value\", value);\n        }\n\n        params.inputs = parseParams(parens[2].trim(), false);\n\n        parseModifiers(parens[3].trim(), params);\n\n        return ConstructorFragment.fromObject(params);\n    }\n\n    static isConstructorFragment(value: any): value is ConstructorFragment {\n        return (value && value._isFragment && value.type === \"constructor\");\n    }\n}\n\ninterface _FunctionFragment extends _ConstructorFragment {\n    constant: boolean;\n    outputs?: Array<ParamType>;\n}\n\nexport class FunctionFragment extends ConstructorFragment {\n    constant: boolean;\n    outputs?: Array<ParamType>;\n\n    format(format?: string): string {\n        if (!format) { format = FormatTypes.sighash; }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"function\",\n                name: this.name,\n                constant: this.constant,\n                stateMutability: ((this.stateMutability !== \"nonpayable\") ? this.stateMutability: undefined),\n                payable: this.payable,\n                gas: (this.gas ? this.gas.toNumber(): undefined),\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),\n                outputs: this.outputs.map((output) => JSON.parse(output.format(format))),\n            });\n        }\n\n        let result = \"\";\n\n        if (format !== FormatTypes.sighash) {\n            result += \"function \";\n        }\n\n        result += this.name + \"(\" + this.inputs.map(\n            (input) => input.format(format)\n        ).join((format === FormatTypes.full) ? \", \": \",\") + \") \";\n\n        if (format !== FormatTypes.sighash) {\n            if (this.stateMutability) {\n                if (this.stateMutability !== \"nonpayable\") {\n                    result += (this.stateMutability + \" \");\n                }\n            } else if (this.constant) {\n                result += \"view \";\n            }\n\n            if (this.outputs && this.outputs.length) {\n                result += \"returns (\" + this.outputs.map(\n                    (output) => output.format(format)\n                ).join(\", \") + \") \";\n            }\n\n            if (this.gas != null) {\n                result += \"@\" + this.gas.toString() + \" \";\n            }\n        }\n\n        return result.trim();\n    }\n\n    static from(value: FunctionFragment | JsonFragment | string): FunctionFragment {\n        if (typeof(value) === \"string\") {\n            return FunctionFragment.fromString(value);\n        }\n        return FunctionFragment.fromObject(value);\n    }\n\n    static fromObject(value: FunctionFragment | JsonFragment): FunctionFragment {\n        if (FunctionFragment.isFunctionFragment(value)) { return value; }\n\n        if (value.type !== \"function\") {\n            logger.throwArgumentError(\"invalid function object\", \"value\", value);\n        }\n\n        let state = verifyState(value);\n\n        const params: TypeCheck<_FunctionFragment> = {\n            type: value.type,\n            name: verifyIdentifier(value.name),\n            constant: state.constant,\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject): []),\n            outputs: (value.outputs ? value.outputs.map(ParamType.fromObject): [ ]),\n            payable: state.payable,\n            stateMutability: state.stateMutability,\n            gas: (value.gas ? BigNumber.from(value.gas): null)\n        };\n\n        return new FunctionFragment(_constructorGuard, params);\n    }\n\n    static fromString(value: string): FunctionFragment {\n        let params: any = { type: \"function\" };\n        value = parseGas(value, params);\n\n        let comps = value.split(\" returns \");\n        if (comps.length > 2) {\n            logger.throwArgumentError(\"invalid function string\", \"value\", value);\n        }\n\n        let parens = comps[0].match(regexParen);\n        if (!parens) {\n            logger.throwArgumentError(\"invalid function signature\", \"value\", value);\n        }\n\n        params.name = parens[1].trim();\n        if (params.name) { verifyIdentifier(params.name); }\n\n        params.inputs = parseParams(parens[2], false);\n\n        parseModifiers(parens[3].trim(), params);\n\n        // We have outputs\n        if (comps.length > 1) {\n           let returns = comps[1].match(regexParen);\n            if (returns[1].trim() != \"\" || returns[3].trim() != \"\") {\n                logger.throwArgumentError(\"unexpected tokens\", \"value\", value);\n            }\n            params.outputs = parseParams(returns[2], false);\n        } else {\n            params.outputs = [ ];\n        }\n\n        return FunctionFragment.fromObject(params);\n    }\n\n    static isFunctionFragment(value: any): value is FunctionFragment {\n        return (value && value._isFragment && value.type === \"function\");\n    }\n}\n\n//export class StructFragment extends Fragment {\n//}\n\nfunction checkForbidden(fragment: ErrorFragment): ErrorFragment {\n    const sig = fragment.format();\n    if (sig === \"Error(string)\" || sig === \"Panic(uint256)\") {\n        logger.throwArgumentError(`cannot specify user defined ${ sig } error`, \"fragment\", fragment);\n    }\n    return fragment;\n}\n\nexport class ErrorFragment extends Fragment {\n\n    format(format?: string): string {\n        if (!format) { format = FormatTypes.sighash; }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"error\",\n                name: this.name,\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),\n            });\n        }\n\n        let result = \"\";\n\n        if (format !== FormatTypes.sighash) {\n            result += \"error \";\n        }\n\n        result += this.name + \"(\" + this.inputs.map(\n            (input) => input.format(format)\n        ).join((format === FormatTypes.full) ? \", \": \",\") + \") \";\n\n        return result.trim();\n    }\n\n    static from(value: ErrorFragment | JsonFragment | string): ErrorFragment {\n        if (typeof(value) === \"string\") {\n            return ErrorFragment.fromString(value);\n        }\n        return ErrorFragment.fromObject(value);\n    }\n\n    static fromObject(value: ErrorFragment | JsonFragment): ErrorFragment {\n        if (ErrorFragment.isErrorFragment(value)) { return value; }\n\n        if (value.type !== \"error\") {\n            logger.throwArgumentError(\"invalid error object\", \"value\", value);\n        }\n\n        const params: TypeCheck<_Fragment> = {\n            type: value.type,\n            name: verifyIdentifier(value.name),\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject): [])\n        };\n\n        return checkForbidden(new ErrorFragment(_constructorGuard, params));\n    }\n\n    static fromString(value: string): ErrorFragment {\n        let params: any = { type: \"error\" };\n\n        let parens = value.match(regexParen);\n        if (!parens) {\n            logger.throwArgumentError(\"invalid error signature\", \"value\", value);\n        }\n\n        params.name = parens[1].trim();\n        if (params.name) { verifyIdentifier(params.name); }\n\n        params.inputs = parseParams(parens[2], false);\n\n        return checkForbidden(ErrorFragment.fromObject(params));\n    }\n\n    static isErrorFragment(value: any): value is ErrorFragment {\n        return (value && value._isFragment && value.type === \"error\");\n    }\n}\n\nfunction verifyType(type: string): string {\n\n    // These need to be transformed to their full description\n    if (type.match(/^uint($|[^1-9])/)) {\n        type = \"uint256\" + type.substring(4);\n    } else if (type.match(/^int($|[^1-9])/)) {\n        type = \"int256\" + type.substring(3);\n    }\n\n    // @TODO: more verification\n\n    return type;\n}\n\n// See: https://github.com/ethereum/solidity/blob/1f8f1a3db93a548d0555e3e14cfc55a10e25b60e/docs/grammar/SolidityLexer.g4#L234\nconst regexIdentifier = new RegExp(\"^[a-zA-Z$_][a-zA-Z0-9$_]*$\");\nfunction verifyIdentifier(value: string): string {\n    if (!value || !value.match(regexIdentifier)) {\n        logger.throwArgumentError(`invalid identifier \"${ value }\"`, \"value\", value);\n    }\n    return value;\n}\n\nconst regexParen = new RegExp(\"^([^)(]*)\\\\((.*)\\\\)([^)(]*)$\");\n\nfunction splitNesting(value: string): Array<any> {\n    value = value.trim();\n\n    let result = [];\n    let accum = \"\";\n    let depth = 0;\n    for (let offset = 0; offset < value.length; offset++) {\n        let c = value[offset];\n        if (c === \",\" && depth === 0) {\n            result.push(accum);\n            accum = \"\";\n        } else {\n            accum += c;\n            if (c === \"(\") {\n                depth++;\n            } else if (c === \")\") {\n                depth--;\n                if (depth === -1) {\n                    logger.throwArgumentError(\"unbalanced parenthesis\", \"value\", value);\n                }\n            }\n        }\n    }\n    if (accum) { result.push(accum); }\n\n    return result;\n}\n\n","\"use strict\";\n\n// See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { Coder, Reader, Result, Writer } from \"./coders/abstract-coder\";\nimport { AddressCoder } from \"./coders/address\";\nimport { ArrayCoder } from \"./coders/array\";\nimport { BooleanCoder } from \"./coders/boolean\";\nimport { BytesCoder } from \"./coders/bytes\";\nimport { FixedBytesCoder } from \"./coders/fixed-bytes\";\nimport { NullCoder } from \"./coders/null\";\nimport { NumberCoder } from \"./coders/number\";\nimport { StringCoder } from \"./coders/string\";\nimport { TupleCoder } from \"./coders/tuple\";\n\nimport { ParamType } from \"./fragments\";\n\n\nconst paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\nconst paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\n\n\nexport type CoerceFunc = (type: string, value: any) => any;\n\nexport class AbiCoder {\n    readonly coerceFunc: CoerceFunc;\n\n    constructor(coerceFunc?: CoerceFunc) {\n        logger.checkNew(new.target, AbiCoder);\n        defineReadOnly(this, \"coerceFunc\", coerceFunc || null);\n    }\n\n    _getCoder(param: ParamType): Coder {\n\n        switch (param.baseType) {\n            case \"address\":\n                return new AddressCoder(param.name);\n            case \"bool\":\n                return new BooleanCoder(param.name);\n            case \"string\":\n                return new StringCoder(param.name);\n            case \"bytes\":\n                return new BytesCoder(param.name);\n            case \"array\":\n                return new ArrayCoder(this._getCoder(param.arrayChildren), param.arrayLength, param.name);\n            case \"tuple\":\n                return new TupleCoder((param.components || []).map((component) => {\n                    return this._getCoder(component);\n                }), param.name);\n            case \"\":\n                return new NullCoder(param.name);\n        }\n\n        // u?int[0-9]*\n        let match = param.type.match(paramTypeNumber);\n        if (match) {\n            let size = parseInt(match[2] || \"256\");\n            if (size === 0 || size > 256 || (size % 8) !== 0) {\n                logger.throwArgumentError(\"invalid \" + match[1] + \" bit length\", \"param\", param);\n            }\n            return new NumberCoder(size / 8, (match[1] === \"int\"), param.name);\n        }\n\n        // bytes[0-9]+\n        match = param.type.match(paramTypeBytes);\n        if (match) {\n            let size = parseInt(match[1]);\n            if (size === 0 || size > 32) {\n                logger.throwArgumentError(\"invalid bytes length\", \"param\", param);\n            }\n            return new FixedBytesCoder(size, param.name);\n        }\n\n        return logger.throwArgumentError(\"invalid type\", \"type\", param.type);\n    }\n\n    _getWordSize(): number { return 32; }\n\n    _getReader(data: Uint8Array, allowLoose?: boolean): Reader {\n        return new Reader(data, this._getWordSize(), this.coerceFunc, allowLoose);\n    }\n\n    _getWriter(): Writer {\n        return new Writer(this._getWordSize());\n    }\n\n    getDefaultValue(types: ReadonlyArray<string | ParamType>): Result {\n        const coders: Array<Coder> = types.map((type) => this._getCoder(ParamType.from(type)));\n        const coder = new TupleCoder(coders, \"_\");\n        return coder.defaultValue();\n    }\n\n    encode(types: ReadonlyArray<string | ParamType>, values: ReadonlyArray<any>): string {\n        if (types.length !== values.length) {\n            logger.throwError(\"types/values length mismatch\", Logger.errors.INVALID_ARGUMENT, {\n                count: { types: types.length, values: values.length },\n                value: { types: types, values: values }\n            });\n        }\n\n        const coders = types.map((type) => this._getCoder(ParamType.from(type)));\n        const coder = (new TupleCoder(coders, \"_\"));\n\n        const writer = this._getWriter();\n        coder.encode(writer, values);\n        return writer.data;\n    }\n\n    decode(types: ReadonlyArray<string | ParamType>, data: BytesLike, loose?: boolean): Result {\n        const coders: Array<Coder> = types.map((type) => this._getCoder(ParamType.from(type)));\n        const coder = new TupleCoder(coders, \"_\");\n        return coder.decode(this._getReader(arrayify(data), loose));\n    }\n}\n\nexport const defaultAbiCoder: AbiCoder = new AbiCoder();\n\n","\"use strict\";\n\nimport { getAddress } from \"@ethersproject/address\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { arrayify, BytesLike, concat, hexDataSlice, hexlify, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { id } from \"@ethersproject/hash\";\nimport { keccak256 } from \"@ethersproject/keccak256\"\nimport { defineReadOnly, Description, getStatic } from \"@ethersproject/properties\";\n\nimport { AbiCoder, defaultAbiCoder } from \"./abi-coder\";\nimport { checkResultErrors, Result } from \"./coders/abstract-coder\";\nimport { ConstructorFragment, ErrorFragment, EventFragment, FormatTypes, Fragment, FunctionFragment, JsonFragment, ParamType } from \"./fragments\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport { checkResultErrors, Result };\n\nexport class LogDescription extends Description<LogDescription> {\n    readonly eventFragment: EventFragment;\n    readonly name: string;\n    readonly signature: string;\n    readonly topic: string;\n    readonly args: Result\n}\n\nexport class TransactionDescription extends Description<TransactionDescription> {\n    readonly functionFragment: FunctionFragment;\n    readonly name: string;\n    readonly args: Result;\n    readonly signature: string;\n    readonly sighash: string;\n    readonly value: BigNumber;\n}\n\nexport class ErrorDescription extends Description<ErrorDescription> {\n    readonly errorFragment: ErrorFragment;\n    readonly name: string;\n    readonly args: Result;\n    readonly signature: string;\n    readonly sighash: string;\n}\n\nexport class Indexed extends Description<Indexed> {\n    readonly hash: string;\n    readonly _isIndexed: boolean;\n\n    static isIndexed(value: any): value is Indexed {\n        return !!(value && value._isIndexed);\n    }\n}\n\nconst BuiltinErrors: Record<string, { signature: string, inputs: Array<string>, name: string, reason?: boolean }> = {\n    \"0x08c379a0\": { signature: \"Error(string)\", name: \"Error\", inputs: [ \"string\" ], reason: true },\n    \"0x4e487b71\": { signature: \"Panic(uint256)\", name: \"Panic\", inputs: [ \"uint256\" ] }\n}\n\nfunction wrapAccessError(property: string, error: Error): Error {\n    const wrap = new Error(`deferred error during ABI decoding triggered accessing ${ property }`);\n    (<any>wrap).error = error;\n    return wrap;\n}\n\n/*\nfunction checkNames(fragment: Fragment, type: \"input\" | \"output\", params: Array<ParamType>): void {\n    params.reduce((accum, param) => {\n        if (param.name) {\n            if (accum[param.name]) {\n                logger.throwArgumentError(`duplicate ${ type } parameter ${ JSON.stringify(param.name) } in ${ fragment.format(\"full\") }`, \"fragment\", fragment);\n            }\n            accum[param.name] = true;\n        }\n        return accum;\n    }, <{ [ name: string ]: boolean }>{ });\n}\n*/\nexport class Interface {\n    readonly fragments: ReadonlyArray<Fragment>;\n\n    readonly errors: { [ name: string ]: ErrorFragment };\n    readonly events: { [ name: string ]: EventFragment };\n    readonly functions: { [ name: string ]: FunctionFragment };\n    readonly structs: { [ name: string ]: any };\n\n    readonly deploy: ConstructorFragment;\n\n    readonly _abiCoder: AbiCoder;\n\n    readonly _isInterface: boolean;\n\n    constructor(fragments: string | ReadonlyArray<Fragment | JsonFragment | string>) {\n        logger.checkNew(new.target, Interface);\n\n        let abi: ReadonlyArray<Fragment | JsonFragment | string> = [ ];\n        if (typeof(fragments) === \"string\") {\n            abi = JSON.parse(fragments);\n        } else {\n            abi = fragments;\n        }\n\n        defineReadOnly(this, \"fragments\", abi.map((fragment) => {\n            return Fragment.from(fragment);\n        }).filter((fragment) => (fragment != null)));\n\n        defineReadOnly(this, \"_abiCoder\", getStatic<() => AbiCoder>(new.target, \"getAbiCoder\")());\n\n        defineReadOnly(this, \"functions\", { });\n        defineReadOnly(this, \"errors\", { });\n        defineReadOnly(this, \"events\", { });\n        defineReadOnly(this, \"structs\", { });\n\n        // Add all fragments by their signature\n        this.fragments.forEach((fragment) => {\n            let bucket: { [ name: string ]: Fragment } = null;\n            switch (fragment.type) {\n                case \"constructor\":\n                    if (this.deploy) {\n                        logger.warn(\"duplicate definition - constructor\");\n                        return;\n                    }\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    defineReadOnly(this, \"deploy\", <ConstructorFragment>fragment);\n                    return;\n                case \"function\":\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    //checkNames(fragment, \"output\", (<FunctionFragment>fragment).outputs);\n                    bucket = this.functions;\n                    break;\n                case \"event\":\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    bucket = this.events;\n                    break;\n                case \"error\":\n                    bucket = this.errors;\n                    break;\n                default:\n                    return;\n            }\n\n            let signature = fragment.format();\n            if (bucket[signature]) {\n                logger.warn(\"duplicate definition - \" + signature);\n                return;\n            }\n\n            bucket[signature] = fragment;\n        });\n\n        // If we do not have a constructor add a default\n        if (!this.deploy) {\n            defineReadOnly(this, \"deploy\", ConstructorFragment.from({\n                payable: false,\n                type: \"constructor\"\n            }));\n        }\n\n        defineReadOnly(this, \"_isInterface\", true);\n    }\n\n    format(format?: string): string | Array<string> {\n        if (!format) { format = FormatTypes.full; }\n        if (format === FormatTypes.sighash) {\n            logger.throwArgumentError(\"interface does not support formatting sighash\", \"format\", format);\n        }\n\n        const abi = this.fragments.map((fragment) => fragment.format(format));\n\n        // We need to re-bundle the JSON fragments a bit\n        if (format === FormatTypes.json) {\n             return JSON.stringify(abi.map((j) => JSON.parse(j)));\n        }\n\n        return abi;\n    }\n\n    // Sub-classes can override these to handle other blockchains\n    static getAbiCoder(): AbiCoder {\n        return defaultAbiCoder;\n    }\n\n    static getAddress(address: string): string {\n        return getAddress(address);\n    }\n\n    static getSighash(fragment: ErrorFragment | FunctionFragment): string {\n        return hexDataSlice(id(fragment.format()), 0, 4);\n    }\n\n    static getEventTopic(eventFragment: EventFragment): string {\n        return id(eventFragment.format());\n    }\n\n    // Find a function definition by any means necessary (unless it is ambiguous)\n    getFunction(nameOrSignatureOrSighash: string): FunctionFragment {\n        if (isHexString(nameOrSignatureOrSighash)) {\n            for (const name in this.functions) {\n                if (nameOrSignatureOrSighash === this.getSighash(name)) {\n                    return this.functions[name];\n                }\n            }\n            logger.throwArgumentError(\"no matching function\", \"sighash\", nameOrSignatureOrSighash);\n        }\n\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (nameOrSignatureOrSighash.indexOf(\"(\") === -1) {\n            const name = nameOrSignatureOrSighash.trim();\n            const matching = Object.keys(this.functions).filter((f) => (f.split(\"(\"/* fix:) */)[0] === name));\n            if (matching.length === 0) {\n                logger.throwArgumentError(\"no matching function\", \"name\", name);\n            } else if (matching.length > 1) {\n                logger.throwArgumentError(\"multiple matching functions\", \"name\", name);\n            }\n\n            return this.functions[matching[0]];\n        }\n\n        // Normalize the signature and lookup the function\n        const result = this.functions[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];\n        if (!result) {\n            logger.throwArgumentError(\"no matching function\", \"signature\", nameOrSignatureOrSighash);\n        }\n        return result;\n    }\n\n    // Find an event definition by any means necessary (unless it is ambiguous)\n    getEvent(nameOrSignatureOrTopic: string): EventFragment {\n        if (isHexString(nameOrSignatureOrTopic)) {\n            const topichash = nameOrSignatureOrTopic.toLowerCase();\n            for (const name in this.events) {\n                if (topichash === this.getEventTopic(name)) {\n                    return this.events[name];\n                }\n            }\n            logger.throwArgumentError(\"no matching event\", \"topichash\", topichash);\n        }\n\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (nameOrSignatureOrTopic.indexOf(\"(\") === -1) {\n            const name = nameOrSignatureOrTopic.trim();\n            const matching = Object.keys(this.events).filter((f) => (f.split(\"(\"/* fix:) */)[0] === name));\n            if (matching.length === 0) {\n                logger.throwArgumentError(\"no matching event\", \"name\", name);\n            } else if (matching.length > 1) {\n                logger.throwArgumentError(\"multiple matching events\", \"name\", name);\n            }\n\n            return this.events[matching[0]];\n        }\n\n        // Normalize the signature and lookup the function\n        const result = this.events[EventFragment.fromString(nameOrSignatureOrTopic).format()];\n        if (!result) {\n            logger.throwArgumentError(\"no matching event\", \"signature\", nameOrSignatureOrTopic);\n        }\n        return result;\n    }\n\n    // Find a function definition by any means necessary (unless it is ambiguous)\n    getError(nameOrSignatureOrSighash: string): ErrorFragment {\n        if (isHexString(nameOrSignatureOrSighash)) {\n            const getSighash = getStatic<(f: ErrorFragment | FunctionFragment) => string>(this.constructor, \"getSighash\");\n            for (const name in this.errors) {\n                const error = this.errors[name];\n                if (nameOrSignatureOrSighash === getSighash(error)) {\n                    return this.errors[name];\n                }\n            }\n            logger.throwArgumentError(\"no matching error\", \"sighash\", nameOrSignatureOrSighash);\n        }\n\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (nameOrSignatureOrSighash.indexOf(\"(\") === -1) {\n            const name = nameOrSignatureOrSighash.trim();\n            const matching = Object.keys(this.errors).filter((f) => (f.split(\"(\"/* fix:) */)[0] === name));\n            if (matching.length === 0) {\n                logger.throwArgumentError(\"no matching error\", \"name\", name);\n            } else if (matching.length > 1) {\n                logger.throwArgumentError(\"multiple matching errors\", \"name\", name);\n            }\n\n            return this.errors[matching[0]];\n        }\n\n        // Normalize the signature and lookup the function\n        const result = this.errors[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];\n        if (!result) {\n            logger.throwArgumentError(\"no matching error\", \"signature\", nameOrSignatureOrSighash);\n        }\n        return result;\n    }\n\n    // Get the sighash (the bytes4 selector) used by Solidity to identify a function\n    getSighash(fragment: ErrorFragment | FunctionFragment | string): string {\n        if (typeof(fragment) === \"string\") {\n            try {\n                fragment = this.getFunction(fragment);\n            } catch (error) {\n                try {\n                    fragment = this.getError(<string>fragment);\n                } catch (_) {\n                    throw error;\n                }\n            }\n        }\n\n        return getStatic<(f: ErrorFragment | FunctionFragment) => string>(this.constructor, \"getSighash\")(fragment);\n    }\n\n    // Get the topic (the bytes32 hash) used by Solidity to identify an event\n    getEventTopic(eventFragment: EventFragment | string): string {\n        if (typeof(eventFragment) === \"string\") {\n            eventFragment = this.getEvent(eventFragment);\n        }\n\n        return getStatic<(e: EventFragment) => string>(this.constructor, \"getEventTopic\")(eventFragment);\n    }\n\n\n    _decodeParams(params: ReadonlyArray<ParamType>, data: BytesLike): Result {\n        return this._abiCoder.decode(params, data)\n    }\n\n    _encodeParams(params: ReadonlyArray<ParamType>, values: ReadonlyArray<any>): string {\n        return this._abiCoder.encode(params, values)\n    }\n\n    encodeDeploy(values?: ReadonlyArray<any>): string {\n        return this._encodeParams(this.deploy.inputs, values || [ ]);\n    }\n\n    decodeErrorResult(fragment: ErrorFragment | string, data: BytesLike): Result {\n        if (typeof(fragment) === \"string\") {\n            fragment = this.getError(fragment);\n        }\n\n        const bytes = arrayify(data);\n\n        if (hexlify(bytes.slice(0, 4)) !== this.getSighash(fragment)) {\n            logger.throwArgumentError(`data signature does not match error ${ fragment.name }.`, \"data\", hexlify(bytes));\n        }\n\n        return this._decodeParams(fragment.inputs, bytes.slice(4));\n    }\n\n    encodeErrorResult(fragment: ErrorFragment | string, values?: ReadonlyArray<any>): string {\n        if (typeof(fragment) === \"string\") {\n            fragment = this.getError(fragment);\n        }\n\n        return hexlify(concat([\n            this.getSighash(fragment),\n            this._encodeParams(fragment.inputs, values || [ ])\n        ]));\n    }\n\n    // Decode the data for a function call (e.g. tx.data)\n    decodeFunctionData(functionFragment: FunctionFragment | string, data: BytesLike): Result {\n        if (typeof(functionFragment) === \"string\") {\n            functionFragment = this.getFunction(functionFragment);\n        }\n\n        const bytes = arrayify(data);\n\n        if (hexlify(bytes.slice(0, 4)) !== this.getSighash(functionFragment)) {\n            logger.throwArgumentError(`data signature does not match function ${ functionFragment.name }.`, \"data\", hexlify(bytes));\n        }\n\n        return this._decodeParams(functionFragment.inputs, bytes.slice(4));\n    }\n\n    // Encode the data for a function call (e.g. tx.data)\n    encodeFunctionData(functionFragment: FunctionFragment | string, values?: ReadonlyArray<any>): string {\n        if (typeof(functionFragment) === \"string\") {\n            functionFragment = this.getFunction(functionFragment);\n        }\n\n        return hexlify(concat([\n            this.getSighash(functionFragment),\n            this._encodeParams(functionFragment.inputs, values || [ ])\n        ]));\n    }\n\n    // Decode the result from a function call (e.g. from eth_call)\n    decodeFunctionResult(functionFragment: FunctionFragment | string, data: BytesLike): Result {\n        if (typeof(functionFragment) === \"string\") {\n            functionFragment = this.getFunction(functionFragment);\n        }\n\n        let bytes = arrayify(data);\n\n        let reason: string = null;\n        let errorArgs: Result = null;\n        let errorName: string = null;\n        let errorSignature: string = null;\n        switch (bytes.length % this._abiCoder._getWordSize()) {\n            case 0:\n                try {\n                    return this._abiCoder.decode(functionFragment.outputs, bytes);\n                } catch (error) { }\n                break;\n\n            case 4: {\n                const selector = hexlify(bytes.slice(0, 4));\n                const builtin = BuiltinErrors[selector];\n                if (builtin) {\n                    errorArgs = this._abiCoder.decode(builtin.inputs, bytes.slice(4));\n                    errorName = builtin.name;\n                    errorSignature = builtin.signature;\n                    if (builtin.reason) { reason = errorArgs[0]; }\n                } else {\n                    try {\n                        const error = this.getError(selector);\n                        errorArgs = this._abiCoder.decode(error.inputs, bytes.slice(4));\n                        errorName = error.name;\n                        errorSignature = error.format();\n                    } catch (error) {\n                        console.log(error);\n                    }\n                }\n                break;\n            }\n        }\n\n        return logger.throwError(\"call revert exception\", Logger.errors.CALL_EXCEPTION, {\n            method: functionFragment.format(),\n            errorArgs, errorName, errorSignature, reason\n        });\n    }\n\n    // Encode the result for a function call (e.g. for eth_call)\n    encodeFunctionResult(functionFragment: FunctionFragment | string, values?: ReadonlyArray<any>): string {\n        if (typeof(functionFragment) === \"string\") {\n            functionFragment = this.getFunction(functionFragment);\n        }\n\n        return hexlify(this._abiCoder.encode(functionFragment.outputs, values || [ ]));\n    }\n\n    // Create the filter for the event with search criteria (e.g. for eth_filterLog)\n    encodeFilterTopics(eventFragment: EventFragment, values: ReadonlyArray<any>): Array<string | Array<string>> {\n        if (typeof(eventFragment) === \"string\") {\n            eventFragment = this.getEvent(eventFragment);\n        }\n\n        if (values.length > eventFragment.inputs.length) {\n            logger.throwError(\"too many arguments for \" + eventFragment.format(), Logger.errors.UNEXPECTED_ARGUMENT, {\n                argument: \"values\",\n                value: values\n            })\n        }\n\n        let topics: Array<string | Array<string>> = [];\n        if (!eventFragment.anonymous) { topics.push(this.getEventTopic(eventFragment)); }\n\n        const encodeTopic = (param: ParamType, value: any): string => {\n            if (param.type === \"string\") {\n                 return id(value);\n            } else if (param.type === \"bytes\") {\n                 return keccak256(hexlify(value));\n            }\n\n            // Check addresses are valid\n            if (param.type === \"address\") { this._abiCoder.encode( [ \"address\" ], [ value ]); }\n            return hexZeroPad(hexlify(value), 32);\n        };\n\n        values.forEach((value, index) => {\n\n            let param = eventFragment.inputs[index];\n\n            if (!param.indexed) {\n                if (value != null) {\n                    logger.throwArgumentError(\"cannot filter non-indexed parameters; must be null\", (\"contract.\" + param.name), value);\n                }\n                return;\n            }\n\n            if (value == null) {\n                topics.push(null);\n            } else if (param.baseType === \"array\" || param.baseType === \"tuple\") {\n                logger.throwArgumentError(\"filtering with tuples or arrays not supported\", (\"contract.\" + param.name), value);\n            } else if (Array.isArray(value)) {\n                topics.push(value.map((value) => encodeTopic(param, value)));\n            } else {\n                topics.push(encodeTopic(param, value));\n            }\n        });\n\n        // Trim off trailing nulls\n        while (topics.length && topics[topics.length - 1] === null) {\n            topics.pop();\n        }\n\n        return topics;\n    }\n\n    encodeEventLog(eventFragment: EventFragment, values: ReadonlyArray<any>): { data: string, topics: Array<string> } {\n        if (typeof(eventFragment) === \"string\") {\n            eventFragment = this.getEvent(eventFragment);\n        }\n\n        const topics: Array<string> = [ ];\n\n        const dataTypes: Array<ParamType> = [ ];\n        const dataValues: Array<string> = [ ];\n\n        if (!eventFragment.anonymous) {\n            topics.push(this.getEventTopic(eventFragment));\n        }\n\n        if (values.length !== eventFragment.inputs.length) {\n            logger.throwArgumentError(\"event arguments/values mismatch\", \"values\", values);\n        }\n\n        eventFragment.inputs.forEach((param, index) => {\n            const value = values[index];\n            if (param.indexed) {\n                if (param.type === \"string\") {\n                    topics.push(id(value))\n                } else if (param.type === \"bytes\") {\n                    topics.push(keccak256(value))\n                } else if (param.baseType === \"tuple\" || param.baseType === \"array\") {\n                    // @TODO\n                    throw new Error(\"not implemented\");\n                } else {\n                    topics.push(this._abiCoder.encode([ param.type] , [ value ]));\n                }\n            } else {\n                dataTypes.push(param);\n                dataValues.push(value);\n            }\n        });\n\n        return {\n            data: this._abiCoder.encode(dataTypes , dataValues),\n            topics: topics\n        };\n    }\n\n    // Decode a filter for the event and the search criteria\n    decodeEventLog(eventFragment: EventFragment | string, data: BytesLike, topics?: ReadonlyArray<string>): Result {\n        if (typeof(eventFragment) === \"string\") {\n            eventFragment = this.getEvent(eventFragment);\n        }\n\n        if (topics != null && !eventFragment.anonymous) {\n            let topicHash = this.getEventTopic(eventFragment);\n            if (!isHexString(topics[0], 32) || topics[0].toLowerCase() !== topicHash) {\n                logger.throwError(\"fragment/topic mismatch\", Logger.errors.INVALID_ARGUMENT, { argument: \"topics[0]\", expected: topicHash, value: topics[0] });\n            }\n            topics = topics.slice(1);\n        }\n\n        let indexed: Array<ParamType> = [];\n        let nonIndexed: Array<ParamType> = [];\n        let dynamic: Array<boolean> = [];\n\n        eventFragment.inputs.forEach((param, index) => {\n            if (param.indexed) {\n                if (param.type === \"string\" || param.type === \"bytes\" || param.baseType === \"tuple\" || param.baseType === \"array\") {\n                    indexed.push(ParamType.fromObject({ type: \"bytes32\", name: param.name }));\n                    dynamic.push(true);\n                } else {\n                    indexed.push(param);\n                    dynamic.push(false);\n                }\n            } else {\n                nonIndexed.push(param);\n                dynamic.push(false);\n            }\n        });\n\n        let resultIndexed = (topics != null) ? this._abiCoder.decode(indexed, concat(topics)): null;\n        let resultNonIndexed = this._abiCoder.decode(nonIndexed, data, true);\n\n        let result: (Array<any> & { [ key: string ]: any }) = [ ];\n        let nonIndexedIndex = 0, indexedIndex = 0;\n        eventFragment.inputs.forEach((param, index) => {\n            if (param.indexed) {\n                if (resultIndexed == null) {\n                    result[index] = new Indexed({ _isIndexed: true, hash: null });\n\n                } else if (dynamic[index]) {\n                    result[index] = new Indexed({ _isIndexed: true, hash: resultIndexed[indexedIndex++] });\n\n                } else {\n                    try {\n                        result[index] = resultIndexed[indexedIndex++];\n                    } catch (error) {\n                        result[index] = error;\n                    }\n                }\n            } else {\n                try {\n                    result[index] = resultNonIndexed[nonIndexedIndex++];\n                } catch (error) {\n                    result[index] = error;\n                }\n            }\n\n            // Add the keyword argument if named and safe\n            if (param.name && result[param.name] == null) {\n                const value = result[index];\n\n                // Make error named values throw on access\n                if (value instanceof Error) {\n                    Object.defineProperty(result, param.name, {\n                        enumerable: true,\n                        get: () => { throw wrapAccessError(`property ${ JSON.stringify(param.name) }`, value); }\n                    });\n                } else {\n                    result[param.name] = value;\n                }\n            }\n        });\n\n        // Make all error indexed values throw on access\n        for (let i = 0; i < result.length; i++) {\n            const value = result[i];\n            if (value instanceof Error) {\n                Object.defineProperty(result, i, {\n                    enumerable: true,\n                    get: () => { throw wrapAccessError(`index ${ i }`, value); }\n                });\n            }\n        }\n\n        return Object.freeze(result);\n    }\n\n    // Given a transaction, find the matching function fragment (if any) and\n    // determine all its properties and call parameters\n    parseTransaction(tx: { data: string, value?: BigNumberish }): TransactionDescription {\n        let fragment = this.getFunction(tx.data.substring(0, 10).toLowerCase())\n\n        if (!fragment) { return null; }\n\n        return new TransactionDescription({\n            args: this._abiCoder.decode(fragment.inputs, \"0x\" + tx.data.substring(10)),\n            functionFragment: fragment,\n            name: fragment.name,\n            signature: fragment.format(),\n            sighash: this.getSighash(fragment),\n            value: BigNumber.from(tx.value || \"0\"),\n        });\n    }\n\n    // @TODO\n    //parseCallResult(data: BytesLike): ??\n\n    // Given an event log, find the matching event fragment (if any) and\n    // determine all its properties and values\n    parseLog(log: { topics: Array<string>, data: string}): LogDescription {\n        let fragment = this.getEvent(log.topics[0]);\n\n        if (!fragment || fragment.anonymous) { return null; }\n\n        // @TODO: If anonymous, and the only method, and the input count matches, should we parse?\n        //        Probably not, because just because it is the only event in the ABI does\n        //        not mean we have the full ABI; maybe just a fragment?\n\n\n       return new LogDescription({\n            eventFragment: fragment,\n            name: fragment.name,\n            signature: fragment.format(),\n            topic: this.getEventTopic(fragment),\n            args: this.decodeEventLog(fragment, log.data, log.topics)\n        });\n    }\n\n    parseError(data: BytesLike): ErrorDescription {\n        const hexData = hexlify(data);\n        let fragment = this.getError(hexData.substring(0, 10).toLowerCase())\n\n        if (!fragment) { return null; }\n\n        return new ErrorDescription({\n            args: this._abiCoder.decode(fragment.inputs, \"0x\" + hexData.substring(10)),\n            errorFragment: fragment,\n            name: fragment.name,\n            signature: fragment.format(),\n            sighash: this.getSighash(fragment),\n        });\n    }\n\n\n    /*\n    static from(value: Array<Fragment | string | JsonAbi> | string | Interface) {\n        if (Interface.isInterface(value)) {\n            return value;\n        }\n        if (typeof(value) === \"string\") {\n            return new Interface(JSON.parse(value));\n        }\n        return new Interface(value);\n    }\n    */\n\n    static isInterface(value: any): value is Interface {\n        return !!(value && value._isInterface);\n    }\n}\n\n","\"use strict\";\n\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { BytesLike, isHexString } from \"@ethersproject/bytes\";\nimport { Network } from \"@ethersproject/networks\";\nimport { Deferrable, Description, defineReadOnly, resolveProperties } from \"@ethersproject/properties\";\nimport { AccessListish, Transaction } from \"@ethersproject/transactions\";\nimport { OnceBlockable } from \"@ethersproject/web\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\n\nexport type TransactionRequest = {\n    to?: string,\n    from?: string,\n    nonce?: BigNumberish,\n\n    gasLimit?: BigNumberish,\n    gasPrice?: BigNumberish,\n\n    data?: BytesLike,\n    value?: BigNumberish,\n    chainId?: number\n\n    type?: number;\n    accessList?: AccessListish;\n\n    maxPriorityFeePerGas?: BigNumberish;\n    maxFeePerGas?: BigNumberish;\n\n    customData?: Record<string, any>;\n}\n\nexport interface TransactionResponse extends Transaction {\n    hash: string;\n\n    // Only if a transaction has been mined\n    blockNumber?: number,\n    blockHash?: string,\n    timestamp?: number,\n\n    confirmations: number,\n\n    // Not optional (as it is in Transaction)\n    from: string;\n\n    // The raw transaction\n    raw?: string,\n\n    // This function waits until the transaction has been mined\n    wait: (confirmations?: number) => Promise<TransactionReceipt>\n};\n\nexport type BlockTag = string | number;\n\nexport interface _Block {\n    hash: string;\n    parentHash: string;\n    number: number;\n\n    timestamp: number;\n    nonce: string;\n    difficulty: number;\n    _difficulty: BigNumber;\n\n    gasLimit: BigNumber;\n    gasUsed: BigNumber;\n\n    miner: string;\n    extraData: string;\n\n    baseFeePerGas?: null | BigNumber;\n}\n\nexport interface Block extends _Block {\n    transactions: Array<string>;\n}\n\nexport interface BlockWithTransactions extends _Block {\n    transactions: Array<TransactionResponse>;\n}\n\n\nexport interface Log {\n    blockNumber: number;\n    blockHash: string;\n    transactionIndex: number;\n\n    removed: boolean;\n\n    address: string;\n    data: string;\n\n    topics: Array<string>;\n\n    transactionHash: string;\n    logIndex: number;\n}\n\nexport interface TransactionReceipt {\n    to: string;\n    from: string;\n    contractAddress: string,\n    transactionIndex: number,\n    root?: string,\n    gasUsed: BigNumber,\n    logsBloom: string,\n    blockHash: string,\n    transactionHash: string,\n    logs: Array<Log>,\n    blockNumber: number,\n    confirmations: number,\n    cumulativeGasUsed: BigNumber,\n    effectiveGasPrice: BigNumber,\n    byzantium: boolean,\n    type: number;\n    status?: number\n};\n\nexport interface FeeData {\n    maxFeePerGas: null | BigNumber;\n    maxPriorityFeePerGas: null | BigNumber;\n    gasPrice: null | BigNumber;\n}\n\nexport interface EventFilter {\n    address?: string;\n    topics?: Array<string | Array<string> | null>;\n}\n\nexport interface Filter extends EventFilter {\n    fromBlock?: BlockTag,\n    toBlock?: BlockTag,\n}\n\nexport interface FilterByBlockHash extends EventFilter {\n    blockHash?: string;\n}\n\n//export type CallTransactionable = {\n//    call(transaction: TransactionRequest): Promise<TransactionResponse>;\n//};\n\nexport abstract class ForkEvent extends Description {\n    readonly expiry: number;\n\n    readonly _isForkEvent?: boolean;\n\n    static isForkEvent(value: any): value is ForkEvent {\n        return !!(value && value._isForkEvent);\n    }\n}\n\nexport class BlockForkEvent extends ForkEvent {\n    readonly blockHash: string;\n\n    readonly _isBlockForkEvent?: boolean;\n\n    constructor(blockHash: string, expiry?: number) {\n        if (!isHexString(blockHash, 32)) {\n            logger.throwArgumentError(\"invalid blockHash\", \"blockHash\", blockHash);\n        }\n\n        super({\n            _isForkEvent: true,\n            _isBlockForkEvent: true,\n            expiry: (expiry || 0),\n            blockHash: blockHash\n        });\n    }\n}\n\nexport class TransactionForkEvent extends ForkEvent {\n    readonly hash: string;\n\n    readonly _isTransactionOrderForkEvent?: boolean;\n\n    constructor(hash: string, expiry?: number) {\n        if (!isHexString(hash, 32)) {\n            logger.throwArgumentError(\"invalid transaction hash\", \"hash\", hash);\n        }\n\n        super({\n            _isForkEvent: true,\n            _isTransactionForkEvent: true,\n            expiry: (expiry || 0),\n            hash: hash\n        });\n    }\n}\n\nexport class TransactionOrderForkEvent extends ForkEvent {\n    readonly beforeHash: string;\n    readonly afterHash: string;\n\n    constructor(beforeHash: string, afterHash: string, expiry?: number) {\n        if (!isHexString(beforeHash, 32)) {\n            logger.throwArgumentError(\"invalid transaction hash\", \"beforeHash\", beforeHash);\n        }\n        if (!isHexString(afterHash, 32)) {\n            logger.throwArgumentError(\"invalid transaction hash\", \"afterHash\", afterHash);\n        }\n\n        super({\n            _isForkEvent: true,\n            _isTransactionOrderForkEvent: true,\n            expiry: (expiry || 0),\n            beforeHash: beforeHash,\n            afterHash: afterHash\n        });\n    }\n}\n\nexport type EventType = string | Array<string | Array<string>> | EventFilter | ForkEvent;\n\nexport type Listener = (...args: Array<any>) => void;\n\n///////////////////////////////\n// Exported Abstracts\nexport abstract class Provider implements OnceBlockable {\n\n    // Network\n    abstract getNetwork(): Promise<Network>;\n\n    // Latest State\n    abstract getBlockNumber(): Promise<number>;\n    abstract getGasPrice(): Promise<BigNumber>;\n    async getFeeData(): Promise<FeeData> {\n        const { block, gasPrice } = await resolveProperties({\n            block: this.getBlock(\"latest\"),\n            gasPrice: this.getGasPrice().catch((error) => {\n                // @TODO: Why is this now failing on Calaveras?\n                //console.log(error);\n                return null;\n            })\n        });\n\n        let maxFeePerGas = null, maxPriorityFeePerGas = null;\n\n        if (block && block.baseFeePerGas) {\n            // We may want to compute this more accurately in the future,\n            // using the formula \"check if the base fee is correct\".\n            // See: https://eips.ethereum.org/EIPS/eip-1559\n            maxPriorityFeePerGas = BigNumber.from(\"2500000000\");\n            maxFeePerGas = block.baseFeePerGas.mul(2).add(maxPriorityFeePerGas);\n        }\n\n        return { maxFeePerGas, maxPriorityFeePerGas, gasPrice };\n    }\n\n    // Account\n    abstract getBalance(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<BigNumber>;\n    abstract getTransactionCount(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<number>;\n    abstract getCode(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string> ;\n    abstract getStorageAt(addressOrName: string | Promise<string>, position: BigNumberish | Promise<BigNumberish>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string>;\n\n    // Execution\n    abstract sendTransaction(signedTransaction: string | Promise<string>): Promise<TransactionResponse>;\n    abstract call(transaction: Deferrable<TransactionRequest>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string>;\n    abstract estimateGas(transaction: Deferrable<TransactionRequest>): Promise<BigNumber>;\n\n    // Queries\n    abstract getBlock(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>): Promise<Block>;\n    abstract getBlockWithTransactions(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>): Promise<BlockWithTransactions>;\n    abstract getTransaction(transactionHash: string): Promise<TransactionResponse>;\n    abstract getTransactionReceipt(transactionHash: string): Promise<TransactionReceipt>;\n\n    // Bloom-filter Queries\n    abstract getLogs(filter: Filter): Promise<Array<Log>>;\n\n    // ENS\n    abstract resolveName(name: string | Promise<string>): Promise<null | string>;\n    abstract lookupAddress(address: string | Promise<string>): Promise<null | string>;\n\n    // Event Emitter (ish)\n    abstract on(eventName: EventType, listener: Listener): Provider;\n    abstract once(eventName: EventType, listener: Listener): Provider;\n    abstract emit(eventName: EventType, ...args: Array<any>): boolean\n    abstract listenerCount(eventName?: EventType): number;\n    abstract listeners(eventName?: EventType): Array<Listener>;\n    abstract off(eventName: EventType, listener?: Listener): Provider;\n    abstract removeAllListeners(eventName?: EventType): Provider;\n\n    // Alias for \"on\"\n    addListener(eventName: EventType, listener: Listener): Provider {\n        return this.on(eventName, listener);\n    }\n\n    // Alias for \"off\"\n    removeListener(eventName: EventType, listener: Listener): Provider {\n        return this.off(eventName, listener);\n    }\n\n    // @TODO: This *could* be implemented here, but would pull in events...\n    abstract waitForTransaction(transactionHash: string, confirmations?: number, timeout?: number): Promise<TransactionReceipt>;\n\n    readonly _isProvider: boolean;\n\n    constructor() {\n        logger.checkAbstract(new.target, Provider);\n        defineReadOnly(this, \"_isProvider\", true);\n    }\n\n    static isProvider(value: any): value is Provider {\n        return !!(value && value._isProvider);\n    }\n\n/*\n    static getResolver(network: Network, callable: CallTransactionable, namehash: string): string {\n        // No ENS...\n        if (!network.ensAddress) {\n            errors.throwError(\n                \"network does support ENS\",\n                errors.UNSUPPORTED_OPERATION,\n                { operation: \"ENS\", network: network.name }\n            );\n        }\n\n        // Not a namehash\n        if (!isHexString(namehash, 32)) {\n            errors.throwArgumentError(\"invalid name hash\", \"namehash\", namehash);\n        }\n\n        // keccak256(\"resolver(bytes32)\")\n        let data = \"0x0178b8bf\" + namehash.substring(2);\n        let transaction = { to: network.ensAddress, data: data };\n\n        return provider.call(transaction).then((data) => {\n            return provider.formatter.callAddress(data);\n        });\n    }\n\n    static resolveNamehash(network: Network, callable: CallTransactionable, namehash: string): string {\n        return this.getResolver(network, callable, namehash).then((resolverAddress) => {\n            if (!resolverAddress) { return null; }\n\n            // keccak256(\"addr(bytes32)\")\n            let data = \"0x3b3b57de\" + namehash(name).substring(2);\n            let transaction = { to: resolverAddress, data: data };\n            return callable.call(transaction).then((data) => {\n                return this.formatter.callAddress(data);\n            });\n\n        })\n    }\n*/\n}\n","export const version = \"abstract-provider/5.5.1\";\n","\"use strict\";\n\nimport { BlockTag, FeeData, Provider, TransactionRequest, TransactionResponse } from \"@ethersproject/abstract-provider\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { Bytes, BytesLike } from \"@ethersproject/bytes\";\nimport { Deferrable, defineReadOnly, resolveProperties, shallowCopy } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst allowedTransactionKeys: Array<string> = [\n    \"accessList\", \"chainId\", \"customData\", \"data\", \"from\", \"gasLimit\", \"gasPrice\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"nonce\", \"to\", \"type\", \"value\"\n];\n\nconst forwardErrors = [\n    Logger.errors.INSUFFICIENT_FUNDS,\n    Logger.errors.NONCE_EXPIRED,\n    Logger.errors.REPLACEMENT_UNDERPRICED,\n];\n\n// EIP-712 Typed Data\n// See: https://eips.ethereum.org/EIPS/eip-712\n\nexport interface TypedDataDomain {\n    name?: string;\n    version?: string;\n    chainId?: BigNumberish;\n    verifyingContract?: string;\n    salt?: BytesLike;\n};\n\nexport interface TypedDataField {\n    name: string;\n    type: string;\n};\n\n// Sub-classes of Signer may optionally extend this interface to indicate\n// they have a private key available synchronously\nexport interface ExternallyOwnedAccount {\n    readonly address: string;\n    readonly privateKey: string;\n}\n\n// Sub-Class Notes:\n//  - A Signer MUST always make sure, that if present, the \"from\" field\n//    matches the Signer, before sending or signing a transaction\n//  - A Signer SHOULD always wrap private information (such as a private\n//    key or mnemonic) in a function, so that console.log does not leak\n//    the data\n\n// @TODO: This is a temporary measure to preserve backwards compatibility\n//        In v6, the method on TypedDataSigner will be added to Signer\nexport interface TypedDataSigner {\n    _signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): Promise<string>;\n}\n\nexport abstract class Signer {\n    readonly provider?: Provider;\n\n    ///////////////////\n    // Sub-classes MUST implement these\n\n    // Returns the checksum address\n    abstract getAddress(): Promise<string>\n\n    // Returns the signed prefixed-message. This MUST treat:\n    // - Bytes as a binary message\n    // - string as a UTF8-message\n    // i.e. \"0x1234\" is a SIX (6) byte string, NOT 2 bytes of data\n    abstract signMessage(message: Bytes | string): Promise<string>;\n\n    // Signs a transaction and returns the fully serialized, signed transaction.\n    // The EXACT transaction MUST be signed, and NO additional properties to be added.\n    // - This MAY throw if signing transactions is not supports, but if\n    //   it does, sentTransaction MUST be overridden.\n    abstract signTransaction(transaction: Deferrable<TransactionRequest>): Promise<string>;\n\n    // Returns a new instance of the Signer, connected to provider.\n    // This MAY throw if changing providers is not supported.\n    abstract connect(provider: Provider): Signer;\n\n    readonly _isSigner: boolean;\n\n\n    ///////////////////\n    // Sub-classes MUST call super\n    constructor() {\n        logger.checkAbstract(new.target, Signer);\n        defineReadOnly(this, \"_isSigner\", true);\n    }\n\n\n    ///////////////////\n    // Sub-classes MAY override these\n\n    async getBalance(blockTag?: BlockTag): Promise<BigNumber> {\n        this._checkProvider(\"getBalance\");\n        return await this.provider.getBalance(this.getAddress(), blockTag);\n    }\n\n    async getTransactionCount(blockTag?: BlockTag): Promise<number> {\n        this._checkProvider(\"getTransactionCount\");\n        return await this.provider.getTransactionCount(this.getAddress(), blockTag);\n    }\n\n    // Populates \"from\" if unspecified, and estimates the gas for the transaction\n    async estimateGas(transaction: Deferrable<TransactionRequest>): Promise<BigNumber> {\n        this._checkProvider(\"estimateGas\");\n        const tx = await resolveProperties(this.checkTransaction(transaction));\n        return await this.provider.estimateGas(tx);\n    }\n\n    // Populates \"from\" if unspecified, and calls with the transaction\n    async call(transaction: Deferrable<TransactionRequest>, blockTag?: BlockTag): Promise<string> {\n        this._checkProvider(\"call\");\n        const tx = await resolveProperties(this.checkTransaction(transaction));\n        return await this.provider.call(tx, blockTag);\n    }\n\n    // Populates all fields in a transaction, signs it and sends it to the network\n    async sendTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionResponse> {\n        this._checkProvider(\"sendTransaction\");\n        const tx = await this.populateTransaction(transaction);\n        const signedTx = await this.signTransaction(tx);\n        return await this.provider.sendTransaction(signedTx);\n    }\n\n    async getChainId(): Promise<number> {\n        this._checkProvider(\"getChainId\");\n        const network = await this.provider.getNetwork();\n        return network.chainId;\n    }\n\n    async getGasPrice(): Promise<BigNumber> {\n        this._checkProvider(\"getGasPrice\");\n        return await this.provider.getGasPrice();\n    }\n\n    async getFeeData(): Promise<FeeData> {\n        this._checkProvider(\"getFeeData\");\n        return await this.provider.getFeeData();\n    }\n\n\n    async resolveName(name: string): Promise<string> {\n        this._checkProvider(\"resolveName\");\n        return await this.provider.resolveName(name);\n    }\n\n\n\n    // Checks a transaction does not contain invalid keys and if\n    // no \"from\" is provided, populates it.\n    // - does NOT require a provider\n    // - adds \"from\" is not present\n    // - returns a COPY (safe to mutate the result)\n    // By default called from: (overriding these prevents it)\n    //   - call\n    //   - estimateGas\n    //   - populateTransaction (and therefor sendTransaction)\n    checkTransaction(transaction: Deferrable<TransactionRequest>): Deferrable<TransactionRequest> {\n        for (const key in transaction) {\n            if (allowedTransactionKeys.indexOf(key) === -1) {\n                logger.throwArgumentError(\"invalid transaction key: \" + key, \"transaction\", transaction);\n            }\n        }\n\n        const tx = shallowCopy(transaction);\n\n        if (tx.from == null) {\n            tx.from = this.getAddress();\n\n        } else {\n            // Make sure any provided address matches this signer\n            tx.from = Promise.all([\n                Promise.resolve(tx.from),\n                this.getAddress()\n            ]).then((result) => {\n                if (result[0].toLowerCase() !== result[1].toLowerCase()) {\n                    logger.throwArgumentError(\"from address mismatch\", \"transaction\", transaction);\n                }\n                return result[0];\n            });\n        }\n\n        return tx;\n    }\n\n    // Populates ALL keys for a transaction and checks that \"from\" matches\n    // this Signer. Should be used by sendTransaction but NOT by signTransaction.\n    // By default called from: (overriding these prevents it)\n    //   - sendTransaction\n    //\n    // Notes:\n    //  - We allow gasPrice for EIP-1559 as long as it matches maxFeePerGas\n    async populateTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionRequest> {\n\n        const tx: Deferrable<TransactionRequest> = await resolveProperties(this.checkTransaction(transaction))\n\n        if (tx.to != null) {\n            tx.to = Promise.resolve(tx.to).then(async (to) => {\n                if (to == null) { return null; }\n                const address = await this.resolveName(to);\n                if (address == null) {\n                    logger.throwArgumentError(\"provided ENS name resolves to null\", \"tx.to\", to);\n                }\n                return address;\n            });\n\n            // Prevent this error from causing an UnhandledPromiseException\n            tx.to.catch((error) => {  });\n        }\n\n        // Do not allow mixing pre-eip-1559 and eip-1559 properties\n        const hasEip1559 = (tx.maxFeePerGas != null || tx.maxPriorityFeePerGas != null);\n        if (tx.gasPrice != null && (tx.type === 2 || hasEip1559)) {\n            logger.throwArgumentError(\"eip-1559 transaction do not support gasPrice\", \"transaction\", transaction);\n        } else if ((tx.type === 0 || tx.type === 1) && hasEip1559) {\n            logger.throwArgumentError(\"pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas\", \"transaction\", transaction);\n        }\n\n        if ((tx.type === 2 || tx.type == null) && (tx.maxFeePerGas != null && tx.maxPriorityFeePerGas != null)) {\n            // Fully-formed EIP-1559 transaction (skip getFeeData)\n            tx.type = 2;\n\n        } else if (tx.type === 0 || tx.type === 1) {\n            // Explicit Legacy or EIP-2930 transaction\n\n            // Populate missing gasPrice\n            if (tx.gasPrice == null) { tx.gasPrice = this.getGasPrice(); }\n\n        } else {\n\n            // We need to get fee data to determine things\n            const feeData = await this.getFeeData();\n\n            if (tx.type == null) {\n                // We need to auto-detect the intended type of this transaction...\n\n                if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {\n                    // The network supports EIP-1559!\n\n                    // Upgrade transaction from null to eip-1559\n                    tx.type = 2;\n\n                    if (tx.gasPrice != null) {\n                        // Using legacy gasPrice property on an eip-1559 network,\n                        // so use gasPrice as both fee properties\n                        const gasPrice = tx.gasPrice;\n                        delete tx.gasPrice;\n                        tx.maxFeePerGas = gasPrice;\n                        tx.maxPriorityFeePerGas = gasPrice;\n\n                    } else {\n                        // Populate missing fee data\n                        if (tx.maxFeePerGas == null) { tx.maxFeePerGas = feeData.maxFeePerGas; }\n                        if (tx.maxPriorityFeePerGas == null) { tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas; }\n                    }\n\n                } else if (feeData.gasPrice != null) {\n                    // Network doesn't support EIP-1559...\n\n                    // ...but they are trying to use EIP-1559 properties\n                    if (hasEip1559) {\n                        logger.throwError(\"network does not support EIP-1559\", Logger.errors.UNSUPPORTED_OPERATION, {\n                            operation: \"populateTransaction\"\n                        });\n                    }\n\n                    // Populate missing fee data\n                    if (tx.gasPrice == null) { tx.gasPrice = feeData.gasPrice; }\n\n                    // Explicitly set untyped transaction to legacy\n                    tx.type = 0;\n\n                } else {\n                    // getFeeData has failed us.\n                    logger.throwError(\"failed to get consistent fee data\", Logger.errors.UNSUPPORTED_OPERATION, {\n                        operation: \"signer.getFeeData\"\n                    });\n                }\n\n            } else if (tx.type === 2) {\n                // Explicitly using EIP-1559\n\n                // Populate missing fee data\n                if (tx.maxFeePerGas == null) { tx.maxFeePerGas = feeData.maxFeePerGas; }\n                if (tx.maxPriorityFeePerGas == null) { tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas; }\n            }\n        }\n\n        if (tx.nonce == null) { tx.nonce = this.getTransactionCount(\"pending\"); }\n\n        if (tx.gasLimit == null) {\n            tx.gasLimit = this.estimateGas(tx).catch((error) => {\n                if (forwardErrors.indexOf(error.code) >= 0) {\n                    throw error;\n                }\n\n                return logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n                    error: error,\n                    tx: tx\n                });\n            });\n        }\n\n        if (tx.chainId == null) {\n            tx.chainId = this.getChainId();\n        } else {\n            tx.chainId = Promise.all([\n                Promise.resolve(tx.chainId),\n                this.getChainId()\n            ]).then((results) => {\n                if (results[1] !== 0 && results[0] !== results[1]) {\n                    logger.throwArgumentError(\"chainId address mismatch\", \"transaction\", transaction);\n                }\n                return results[0];\n            });\n        }\n\n        return await resolveProperties(tx);\n    }\n\n\n    ///////////////////\n    // Sub-classes SHOULD leave these alone\n\n    _checkProvider(operation?: string): void {\n        if (!this.provider) { logger.throwError(\"missing provider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: (operation || \"_checkProvider\") });\n        }\n    }\n\n    static isSigner(value: any): value is Signer {\n        return !!(value && value._isSigner);\n    }\n}\n\nexport class VoidSigner extends Signer implements TypedDataSigner {\n    readonly address: string;\n\n    constructor(address: string, provider?: Provider) {\n        logger.checkNew(new.target, VoidSigner);\n        super();\n        defineReadOnly(this, \"address\", address);\n        defineReadOnly(this, \"provider\", provider || null);\n    }\n\n    getAddress(): Promise<string> {\n        return Promise.resolve(this.address);\n    }\n\n    _fail(message: string, operation: string): Promise<any> {\n        return Promise.resolve().then(() => {\n            logger.throwError(message, Logger.errors.UNSUPPORTED_OPERATION, { operation: operation });\n        });\n    }\n\n    signMessage(message: Bytes | string): Promise<string> {\n        return this._fail(\"VoidSigner cannot sign messages\", \"signMessage\");\n    }\n\n    signTransaction(transaction: Deferrable<TransactionRequest>): Promise<string> {\n        return this._fail(\"VoidSigner cannot sign transactions\", \"signTransaction\");\n    }\n\n    _signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): Promise<string> {\n        return this._fail(\"VoidSigner cannot sign typed data\", \"signTypedData\");\n    }\n\n    connect(provider: Provider): VoidSigner {\n        return new VoidSigner(this.address, provider);\n    }\n}\n\n","export const version = \"abstract-signer/5.5.0\";\n","\"use strict\";\n\nimport { checkResultErrors, EventFragment, Fragment, FunctionFragment, Indexed, Interface, JsonFragment, LogDescription, ParamType, Result } from \"@ethersproject/abi\";\nimport { Block, BlockTag, Filter, FilterByBlockHash, Listener, Log, Provider, TransactionReceipt, TransactionRequest, TransactionResponse } from \"@ethersproject/abstract-provider\";\nimport { Signer, VoidSigner } from \"@ethersproject/abstract-signer\";\nimport { getAddress, getContractAddress } from \"@ethersproject/address\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { arrayify, BytesLike, concat, hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\nimport { Deferrable, defineReadOnly, deepCopy, getStatic, resolveProperties, shallowCopy } from \"@ethersproject/properties\";\nimport { AccessList, accessListify, AccessListish } from \"@ethersproject/transactions\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\n\nconst logger = new Logger(version);\n\nexport interface Overrides {\n    gasLimit?: BigNumberish | Promise<BigNumberish>;\n    gasPrice?: BigNumberish | Promise<BigNumberish>;\n    maxFeePerGas?: BigNumberish | Promise<BigNumberish>;\n    maxPriorityFeePerGas?: BigNumberish | Promise<BigNumberish>;\n    nonce?: BigNumberish | Promise<BigNumberish>;\n    type?: number;\n    accessList?: AccessListish;\n    customData?: Record<string, any>;\n};\n\nexport interface PayableOverrides extends Overrides {\n    value?: BigNumberish | Promise<BigNumberish>;\n}\n\nexport interface CallOverrides extends PayableOverrides {\n    blockTag?: BlockTag | Promise<BlockTag>;\n    from?: string | Promise<string>;\n}\n\n// @TODO: Better hierarchy with: (in v6)\n//  - abstract-provider:TransactionRequest\n//  - transactions:Transaction\n//  - transaction:UnsignedTransaction\n\nexport interface PopulatedTransaction {\n    to?: string;\n    from?: string;\n    nonce?: number;\n\n    gasLimit?: BigNumber;\n    gasPrice?: BigNumber;\n\n    data?: string;\n    value?: BigNumber;\n    chainId?: number;\n\n    type?: number;\n    accessList?: AccessList;\n\n    maxFeePerGas?: BigNumber;\n    maxPriorityFeePerGas?: BigNumber;\n\n    customData?: Record<string, any>;\n};\n\nexport type EventFilter = {\n    address?: string;\n    topics?: Array<string|Array<string>>;\n};\n\n\nexport type ContractFunction<T = any> = (...args: Array<any>) => Promise<T>;\n\n\n// The (n + 1)th parameter passed to contract event callbacks\nexport interface Event extends Log {\n\n    // The event name\n    event?: string;\n\n    // The event signature\n    eventSignature?: string;\n\n    // The parsed arguments to the event\n    args?: Result;\n\n    // If parsing the arguments failed, this is the error\n    decodeError?: Error;\n\n    // A function that can be used to decode event data and topics\n    decode?: (data: string, topics?: Array<string>) => any;\n\n    // A function that will remove the listener responsible for this event (if any)\n    removeListener: () => void;\n\n    // Get blockchain details about this event's block and transaction\n    getBlock: () => Promise<Block>;\n    getTransaction: () => Promise<TransactionResponse>;\n    getTransactionReceipt: () => Promise<TransactionReceipt>;\n}\n\nexport interface ContractReceipt extends TransactionReceipt {\n    events?: Array<Event>;\n}\n\nexport interface ContractTransaction extends TransactionResponse {\n    wait(confirmations?: number): Promise<ContractReceipt>;\n}\n\n///////////////////////////////\n\nconst allowedTransactionKeys: { [ key: string ]: boolean } = {\n    chainId: true, data: true, from: true, gasLimit: true, gasPrice:true, nonce: true, to: true, value: true,\n    type: true, accessList: true,\n    maxFeePerGas: true, maxPriorityFeePerGas: true,\n    customData: true\n}\n\nasync function resolveName(resolver: Signer | Provider, nameOrPromise: string | Promise<string>): Promise<string> {\n    const name = await nameOrPromise;\n\n    if (typeof(name) !== \"string\") {\n        logger.throwArgumentError(\"invalid address or ENS name\", \"name\", name);\n    }\n\n    // If it is already an address, just use it (after adding checksum)\n    try {\n        return getAddress(name);\n    } catch (error) { }\n\n    if (!resolver) {\n        logger.throwError(\"a provider or signer is needed to resolve ENS names\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"resolveName\"\n        });\n    }\n\n    const address = await resolver.resolveName(name);\n\n    if (address == null) {\n        logger.throwArgumentError(\"resolver or addr is not configured for ENS name\", \"name\", name);\n    }\n\n    return address;\n}\n\n// Recursively replaces ENS names with promises to resolve the name and resolves all properties\nasync function resolveAddresses(resolver: Signer | Provider, value: any, paramType: ParamType | Array<ParamType>): Promise<any> {\n    if (Array.isArray(paramType)) {\n        return await Promise.all(paramType.map((paramType, index) => {\n            return resolveAddresses(\n                resolver,\n                ((Array.isArray(value)) ? value[index]: value[paramType.name]),\n                paramType\n            );\n        }));\n    }\n\n    if (paramType.type === \"address\") {\n        return await resolveName(resolver, value);\n    }\n\n    if (paramType.type === \"tuple\") {\n        return await resolveAddresses(resolver, value, paramType.components);\n    }\n\n    if (paramType.baseType === \"array\") {\n        if (!Array.isArray(value)) {\n            return Promise.reject(logger.makeError(\"invalid value for array\", Logger.errors.INVALID_ARGUMENT, {\n                argument: \"value\",\n                value\n            }));\n        }\n        return await Promise.all(value.map((v) => resolveAddresses(resolver, v, paramType.arrayChildren)));\n    }\n\n    return value;\n}\n\nasync function populateTransaction(contract: Contract, fragment: FunctionFragment, args: Array<any>): Promise<PopulatedTransaction> {\n    // If an extra argument is given, it is overrides\n    let overrides: CallOverrides = { };\n    if (args.length === fragment.inputs.length + 1 && typeof(args[args.length - 1]) === \"object\") {\n        overrides = shallowCopy(args.pop());\n    }\n\n    // Make sure the parameter count matches\n    logger.checkArgumentCount(args.length, fragment.inputs.length, \"passed to contract\");\n\n    // Populate \"from\" override (allow promises)\n    if (contract.signer) {\n        if (overrides.from) {\n            // Contracts with a Signer are from the Signer's frame-of-reference;\n            // but we allow overriding \"from\" if it matches the signer\n            overrides.from = resolveProperties({\n                override: resolveName(contract.signer, overrides.from),\n                signer: contract.signer.getAddress()\n            }).then(async (check) => {\n                if (getAddress(check.signer) !== check.override) {\n                    logger.throwError(\"Contract with a Signer cannot override from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                        operation: \"overrides.from\"\n                    });\n                }\n\n                return check.override;\n            });\n\n        } else {\n            overrides.from = contract.signer.getAddress();\n        }\n\n    } else if (overrides.from) {\n        overrides.from = resolveName(contract.provider, overrides.from);\n\n    //} else {\n        // Contracts without a signer can override \"from\", and if\n        // unspecified the zero address is used\n        //overrides.from = AddressZero;\n    }\n\n    // Wait for all dependencies to be resolved (prefer the signer over the provider)\n    const resolved = await resolveProperties({\n        args: resolveAddresses(contract.signer || contract.provider, args, fragment.inputs),\n        address: contract.resolvedAddress,\n        overrides: (resolveProperties(overrides) || { })\n    });\n\n    // The ABI coded transaction\n    const data = contract.interface.encodeFunctionData(fragment, resolved.args);\n    const tx: PopulatedTransaction = {\n      data: data,\n      to: resolved.address\n    };\n\n    // Resolved Overrides\n    const ro = resolved.overrides;\n\n    // Populate simple overrides\n    if (ro.nonce != null) { tx.nonce = BigNumber.from(ro.nonce).toNumber(); }\n    if (ro.gasLimit != null) { tx.gasLimit = BigNumber.from(ro.gasLimit); }\n    if (ro.gasPrice != null) { tx.gasPrice = BigNumber.from(ro.gasPrice); }\n    if (ro.maxFeePerGas != null) { tx.maxFeePerGas = BigNumber.from(ro.maxFeePerGas); }\n    if (ro.maxPriorityFeePerGas != null) { tx.maxPriorityFeePerGas = BigNumber.from(ro.maxPriorityFeePerGas); }\n    if (ro.from != null) { tx.from = ro.from; }\n\n    if (ro.type != null) { tx.type = ro.type; }\n    if (ro.accessList != null) { tx.accessList = accessListify(ro.accessList); }\n\n    // If there was no \"gasLimit\" override, but the ABI specifies a default, use it\n    if (tx.gasLimit == null && fragment.gas != null) {\n        // Compute the intrinsic gas cost for this transaction\n        // @TODO: This is based on the yellow paper as of Petersburg; this is something\n        // we may wish to parameterize in v6 as part of the Network object. Since this\n        // is always a non-nil to address, we can ignore G_create, but may wish to add\n        // similar logic to the ContractFactory.\n        let intrinsic = 21000;\n        const bytes = arrayify(data);\n        for (let i = 0; i < bytes.length; i++) {\n            intrinsic += 4;\n            if (bytes[i]) { intrinsic += 64; }\n        }\n        tx.gasLimit = BigNumber.from(fragment.gas).add(intrinsic);\n    }\n\n    // Populate \"value\" override\n    if (ro.value) {\n        const roValue = BigNumber.from(ro.value);\n        if (!roValue.isZero() && !fragment.payable) {\n            logger.throwError(\"non-payable method cannot override value\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"overrides.value\",\n                value: overrides.value\n            });\n        }\n        tx.value = roValue;\n    }\n\n    if (ro.customData) {\n        tx.customData = shallowCopy(ro.customData);\n    }\n\n    // Remove the overrides\n    delete overrides.nonce;\n    delete overrides.gasLimit;\n    delete overrides.gasPrice;\n    delete overrides.from;\n    delete overrides.value;\n\n    delete overrides.type;\n    delete overrides.accessList;\n\n    delete overrides.maxFeePerGas;\n    delete overrides.maxPriorityFeePerGas;\n\n    delete overrides.customData;\n\n    // Make sure there are no stray overrides, which may indicate a\n    // typo or using an unsupported key.\n    const leftovers = Object.keys(overrides).filter((key) => ((<any>overrides)[key] != null));\n    if (leftovers.length) {\n        logger.throwError(`cannot override ${ leftovers.map((l) => JSON.stringify(l)).join(\",\") }`, Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"overrides\",\n            overrides: leftovers\n        });\n    }\n\n    return tx;\n}\n\n\nfunction buildPopulate(contract: Contract, fragment: FunctionFragment): ContractFunction<PopulatedTransaction> {\n    return function(...args: Array<any>): Promise<PopulatedTransaction> {\n        return populateTransaction(contract, fragment, args);\n    };\n}\n\nfunction buildEstimate(contract: Contract, fragment: FunctionFragment): ContractFunction<BigNumber> {\n    const signerOrProvider = (contract.signer || contract.provider);\n    return async function(...args: Array<any>): Promise<BigNumber> {\n        if (!signerOrProvider) {\n            logger.throwError(\"estimate require a provider or signer\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"estimateGas\"\n            })\n        }\n\n        const tx = await populateTransaction(contract, fragment, args);\n        return await signerOrProvider.estimateGas(tx);\n    };\n}\n\nfunction addContractWait(contract: Contract, tx: TransactionResponse) {\n    const wait = tx.wait.bind(tx);\n    tx.wait = (confirmations?: number) => {\n        return wait(confirmations).then((receipt: ContractReceipt) => {\n            receipt.events = receipt.logs.map((log) => {\n                let event: Event = (<Event>deepCopy(log));\n                let parsed: LogDescription = null;\n                try {\n                    parsed = contract.interface.parseLog(log);\n                } catch (e){ }\n\n                // Successfully parsed the event log; include it\n                if (parsed) {\n                    event.args = parsed.args;\n                    event.decode = (data: BytesLike, topics?: Array<any>) => {\n                        return contract.interface.decodeEventLog(parsed.eventFragment, data, topics);\n                    };\n                    event.event = parsed.name;\n                    event.eventSignature = parsed.signature;\n                }\n\n                // Useful operations\n                event.removeListener = () => { return contract.provider; }\n                event.getBlock = () => {\n                    return contract.provider.getBlock(receipt.blockHash);\n                }\n                event.getTransaction = () => {\n                    return contract.provider.getTransaction(receipt.transactionHash);\n                }\n                event.getTransactionReceipt = () => {\n                    return Promise.resolve(receipt);\n                }\n\n                return event;\n            });\n\n            return receipt;\n        });\n    };\n}\n\nfunction buildCall(contract: Contract, fragment: FunctionFragment, collapseSimple: boolean): ContractFunction {\n    const signerOrProvider = (contract.signer || contract.provider);\n\n    return async function(...args: Array<any>): Promise<any> {\n        // Extract the \"blockTag\" override if present\n        let blockTag = undefined;\n        if (args.length === fragment.inputs.length + 1 && typeof(args[args.length - 1]) === \"object\") {\n            const overrides = shallowCopy(args.pop());\n            if (overrides.blockTag != null) {\n                blockTag = await overrides.blockTag;\n            }\n            delete overrides.blockTag;\n            args.push(overrides);\n        }\n\n        // If the contract was just deployed, wait until it is mined\n        if (contract.deployTransaction != null) {\n            await contract._deployed(blockTag);\n        }\n\n        // Call a node and get the result\n        const tx = await populateTransaction(contract, fragment, args);\n        const result = await signerOrProvider.call(tx, blockTag);\n\n        try {\n            let value = contract.interface.decodeFunctionResult(fragment, result);\n            if (collapseSimple && fragment.outputs.length === 1) {\n                value = value[0];\n            }\n            return value;\n\n        } catch (error) {\n            if (error.code === Logger.errors.CALL_EXCEPTION) {\n                error.address = contract.address;\n                error.args = args;\n                error.transaction = tx;\n            }\n            throw error;\n         }\n    };\n}\n\nfunction buildSend(contract: Contract, fragment: FunctionFragment): ContractFunction<TransactionResponse> {\n    return async function(...args: Array<any>): Promise<TransactionResponse> {\n        if (!contract.signer) {\n            logger.throwError(\"sending a transaction requires a signer\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"sendTransaction\"\n            })\n        }\n\n        // If the contract was just deployed, wait until it is mined\n        if (contract.deployTransaction != null) {\n            await contract._deployed();\n        }\n\n        const txRequest = await populateTransaction(contract, fragment, args);\n\n        const tx = await contract.signer.sendTransaction(txRequest);\n\n        // Tweak the tx.wait so the receipt has extra properties\n        addContractWait(contract, tx);\n\n        return tx;\n    };\n}\n\nfunction buildDefault(contract: Contract, fragment: FunctionFragment, collapseSimple: boolean): ContractFunction {\n    if (fragment.constant) {\n        return buildCall(contract, fragment, collapseSimple);\n    }\n    return buildSend(contract, fragment);\n}\n\nfunction getEventTag(filter: EventFilter): string {\n    if (filter.address && (filter.topics == null || filter.topics.length === 0)) {\n        return \"*\";\n    }\n\n    return (filter.address || \"*\") + \"@\" + (filter.topics ? filter.topics.map((topic) => {\n        if (Array.isArray(topic)) {\n            return topic.join(\"|\");\n        }\n        return topic;\n    }).join(\":\"): \"\");\n}\n\nclass RunningEvent {\n    readonly tag: string;\n    readonly filter: EventFilter;\n    private _listeners: Array<{ listener: Listener, once: boolean }>;\n\n    constructor(tag: string, filter: EventFilter) {\n        defineReadOnly(this, \"tag\", tag);\n        defineReadOnly(this, \"filter\", filter);\n        this._listeners = [ ];\n    }\n\n    addListener(listener: Listener, once: boolean): void {\n        this._listeners.push({ listener: listener, once: once });\n    }\n\n    removeListener(listener: Listener): void {\n        let done = false;\n        this._listeners = this._listeners.filter((item) => {\n            if (done || item.listener !== listener) { return true; }\n            done = true;\n            return false;\n        });\n    }\n\n    removeAllListeners(): void {\n        this._listeners = [];\n    }\n\n    listeners(): Array<Listener> {\n        return this._listeners.map((i) => i.listener);\n    }\n\n    listenerCount(): number {\n        return this._listeners.length;\n    }\n\n    run(args: Array<any>): number {\n        const listenerCount = this.listenerCount();\n        this._listeners = this._listeners.filter((item) => {\n\n            const argsCopy = args.slice();\n\n            // Call the callback in the next event loop\n            setTimeout(() => {\n                item.listener.apply(this, argsCopy);\n            }, 0);\n\n            // Reschedule it if it not \"once\"\n            return !(item.once);\n        });\n\n        return listenerCount;\n    }\n\n    prepareEvent(event: Event): void {\n    }\n\n    // Returns the array that will be applied to an emit\n    getEmit(event: Event): Array<any> {\n        return [ event ];\n    }\n}\n\nclass ErrorRunningEvent extends RunningEvent {\n    constructor() {\n        super(\"error\", null);\n    }\n}\n\n\n// @TODO Fragment should inherit Wildcard? and just override getEmit?\n//       or have a common abstract super class, with enough constructor\n//       options to configure both.\n\n// A Fragment Event will populate all the properties that Wildcard\n// will, and additionally dereference the arguments when emitting\nclass FragmentRunningEvent extends RunningEvent {\n    readonly address: string;\n    readonly interface: Interface;\n    readonly fragment: EventFragment;\n\n    constructor(address: string, contractInterface: Interface, fragment: EventFragment, topics?: Array<string|Array<string>>) {\n        const filter: EventFilter = {\n            address: address\n        }\n\n        let topic = contractInterface.getEventTopic(fragment);\n        if (topics) {\n            if (topic !== topics[0]) { logger.throwArgumentError(\"topic mismatch\", \"topics\", topics); }\n            filter.topics = topics.slice();\n        } else {\n            filter.topics = [ topic ];\n        }\n\n        super(getEventTag(filter), filter);\n        defineReadOnly(this, \"address\", address);\n        defineReadOnly(this, \"interface\", contractInterface);\n        defineReadOnly(this, \"fragment\", fragment);\n    }\n\n\n    prepareEvent(event: Event): void {\n        super.prepareEvent(event);\n\n        event.event = this.fragment.name;\n        event.eventSignature = this.fragment.format();\n\n        event.decode = (data: BytesLike, topics?: Array<string>) => {\n            return this.interface.decodeEventLog(this.fragment, data, topics);\n        };\n\n        try {\n            event.args = this.interface.decodeEventLog(this.fragment, event.data, event.topics);\n        } catch (error) {\n            event.args = null;\n            event.decodeError = error;\n        }\n    }\n\n    getEmit(event: Event): Array<any> {\n        const errors = checkResultErrors(event.args);\n        if (errors.length) { throw errors[0].error; }\n\n        const args = (event.args || []).slice();\n        args.push(event);\n        return args;\n    }\n}\n\n// A Wildcard Event will attempt to populate:\n//  - event            The name of the event name\n//  - eventSignature   The full signature of the event\n//  - decode           A function to decode data and topics\n//  - args             The decoded data and topics\nclass WildcardRunningEvent extends RunningEvent {\n    readonly address: string;\n    readonly interface: Interface;\n\n    constructor(address: string, contractInterface: Interface) {\n        super(\"*\", { address: address });\n        defineReadOnly(this, \"address\", address);\n        defineReadOnly(this, \"interface\", contractInterface);\n    }\n\n    prepareEvent(event: Event): void {\n        super.prepareEvent(event);\n\n        try {\n            const parsed = this.interface.parseLog(event);\n            event.event = parsed.name;\n            event.eventSignature = parsed.signature;\n\n            event.decode = (data: BytesLike, topics?: Array<string>) => {\n                return this.interface.decodeEventLog(parsed.eventFragment, data, topics);\n            };\n\n            event.args = parsed.args;\n        } catch (error) {\n            // No matching event\n        }\n    }\n}\n\nexport type ContractInterface = string | ReadonlyArray<Fragment | JsonFragment | string> | Interface;\n\ntype InterfaceFunc = (contractInterface: ContractInterface) => Interface;\n\n\nexport class BaseContract {\n    readonly address: string;\n    readonly interface: Interface;\n\n    readonly signer: Signer;\n    readonly provider: Provider;\n\n    readonly functions: { [ name: string ]: ContractFunction };\n\n    readonly callStatic: { [ name: string ]: ContractFunction };\n    readonly estimateGas: { [ name: string ]: ContractFunction<BigNumber> };\n    readonly populateTransaction: { [ name: string ]: ContractFunction<PopulatedTransaction> };\n\n    readonly filters: { [ name: string ]: (...args: Array<any>) => EventFilter };\n\n    // This will always be an address. This will only differ from\n    // address if an ENS name was used in the constructor\n    readonly resolvedAddress: Promise<string>;\n\n    // This is only set if the contract was created with a call to deploy\n    readonly deployTransaction: TransactionResponse;\n\n    _deployedPromise: Promise<Contract>;\n\n    // A list of RunningEvents to track listeners for each event tag\n    _runningEvents: { [ eventTag: string ]: RunningEvent };\n\n    // Wrapped functions to call emit and allow deregistration from the provider\n    _wrappedEmits: { [ eventTag: string ]: (...args: Array<any>) => void };\n\n    constructor(addressOrName: string, contractInterface: ContractInterface, signerOrProvider?: Signer | Provider) {\n        logger.checkNew(new.target, Contract);\n\n        // @TODO: Maybe still check the addressOrName looks like a valid address or name?\n        //address = getAddress(address);\n        defineReadOnly(this, \"interface\", getStatic<InterfaceFunc>(new.target, \"getInterface\")(contractInterface));\n\n        if (signerOrProvider == null) {\n            defineReadOnly(this, \"provider\", null);\n            defineReadOnly(this, \"signer\", null);\n        } else if (Signer.isSigner(signerOrProvider)) {\n            defineReadOnly(this, \"provider\", signerOrProvider.provider || null);\n            defineReadOnly(this, \"signer\", signerOrProvider);\n        } else if (Provider.isProvider(signerOrProvider)) {\n            defineReadOnly(this, \"provider\", signerOrProvider);\n            defineReadOnly(this, \"signer\", null);\n        } else {\n            logger.throwArgumentError(\"invalid signer or provider\", \"signerOrProvider\", signerOrProvider);\n        }\n\n        defineReadOnly(this, \"callStatic\", { });\n        defineReadOnly(this, \"estimateGas\", { });\n        defineReadOnly(this, \"functions\", { });\n        defineReadOnly(this, \"populateTransaction\", { });\n\n        defineReadOnly(this, \"filters\", { });\n\n        {\n            const uniqueFilters: { [ name: string ]: Array<string> } = { };\n            Object.keys(this.interface.events).forEach((eventSignature) => {\n                const event = this.interface.events[eventSignature];\n                defineReadOnly(this.filters, eventSignature, (...args: Array<any>) => {\n                    return {\n                        address: this.address,\n                        topics: this.interface.encodeFilterTopics(event, args)\n                   }\n                });\n                if (!uniqueFilters[event.name]) { uniqueFilters[event.name] = [ ]; }\n                uniqueFilters[event.name].push(eventSignature);\n            });\n\n            Object.keys(uniqueFilters).forEach((name) => {\n                const filters = uniqueFilters[name];\n                if (filters.length === 1) {\n                    defineReadOnly(this.filters, name, this.filters[filters[0]]);\n                } else {\n                    logger.warn(`Duplicate definition of ${ name } (${ filters.join(\", \")})`);\n                }\n            });\n        }\n\n        defineReadOnly(this, \"_runningEvents\", { });\n        defineReadOnly(this, \"_wrappedEmits\", { });\n\n        if (addressOrName == null) {\n            logger.throwArgumentError(\"invalid contract address or ENS name\", \"addressOrName\", addressOrName);\n        }\n\n        defineReadOnly(this, \"address\", addressOrName);\n        if (this.provider) {\n            defineReadOnly(this, \"resolvedAddress\", resolveName(this.provider, addressOrName));\n        } else {\n            try {\n                defineReadOnly(this, \"resolvedAddress\", Promise.resolve(getAddress(addressOrName)));\n            } catch (error) {\n                // Without a provider, we cannot use ENS names\n                logger.throwError(\"provider is required to use ENS name as contract address\", Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"new Contract\"\n                });\n            }\n        }\n\n        const uniqueNames: { [ name: string ]: Array<string> } = { };\n        const uniqueSignatures: { [ signature: string ]: boolean } = { };\n        Object.keys(this.interface.functions).forEach((signature) => {\n            const fragment = this.interface.functions[signature];\n\n            // Check that the signature is unique; if not the ABI generation has\n            // not been cleaned or may be incorrectly generated\n            if (uniqueSignatures[signature]) {\n                logger.warn(`Duplicate ABI entry for ${ JSON.stringify(signature) }`);\n                return;\n            }\n            uniqueSignatures[signature] = true;\n\n            // Track unique names; we only expose bare named functions if they\n            // are ambiguous\n            {\n                const name = fragment.name;\n                if (!uniqueNames[`%${ name }`]) { uniqueNames[`%${ name }`] = [ ]; }\n                uniqueNames[`%${ name }`].push(signature);\n            }\n\n            if ((<Contract>this)[signature] == null) {\n                defineReadOnly<any, any>(this, signature, buildDefault(this, fragment, true));\n            }\n\n            // We do not collapse simple calls on this bucket, which allows\n            // frameworks to safely use this without introspection as well as\n            // allows decoding error recovery.\n            if (this.functions[signature] == null) {\n                defineReadOnly(this.functions, signature, buildDefault(this, fragment, false));\n            }\n\n            if (this.callStatic[signature] == null) {\n                defineReadOnly(this.callStatic, signature, buildCall(this, fragment, true));\n            }\n\n            if (this.populateTransaction[signature] == null) {\n                defineReadOnly(this.populateTransaction, signature, buildPopulate(this, fragment));\n            }\n\n            if (this.estimateGas[signature] == null) {\n                defineReadOnly(this.estimateGas, signature, buildEstimate(this, fragment));\n            }\n        });\n\n        Object.keys(uniqueNames).forEach((name) => {\n            // Ambiguous names to not get attached as bare names\n            const signatures = uniqueNames[name];\n            if (signatures.length > 1) { return; }\n\n            // Strip off the leading \"%\" used for prototype protection\n            name = name.substring(1);\n\n            const signature = signatures[0];\n\n            // If overwriting a member property that is null, swallow the error\n            try {\n                if ((<Contract>this)[name] == null) {\n                    defineReadOnly(<Contract>this, name, (<Contract>this)[signature]);\n                }\n            } catch (e) { }\n\n            if (this.functions[name] == null) {\n                defineReadOnly(this.functions, name, this.functions[signature]);\n            }\n\n            if (this.callStatic[name] == null) {\n                defineReadOnly(this.callStatic, name, this.callStatic[signature]);\n            }\n\n            if (this.populateTransaction[name] == null) {\n                defineReadOnly(this.populateTransaction, name, this.populateTransaction[signature]);\n            }\n\n            if (this.estimateGas[name] == null) {\n                defineReadOnly(this.estimateGas, name, this.estimateGas[signature]);\n            }\n        });\n    }\n\n    static getContractAddress(transaction: { from: string, nonce: BigNumberish }): string {\n        return getContractAddress(transaction);\n    }\n\n    static getInterface(contractInterface: ContractInterface): Interface {\n        if (Interface.isInterface(contractInterface)) {\n            return contractInterface;\n        }\n        return new Interface(contractInterface);\n    }\n\n    // @TODO: Allow timeout?\n    deployed(): Promise<Contract> {\n        return this._deployed();\n    }\n\n    _deployed(blockTag?: BlockTag): Promise<Contract> {\n        if (!this._deployedPromise) {\n\n            // If we were just deployed, we know the transaction we should occur in\n            if (this.deployTransaction) {\n                this._deployedPromise = this.deployTransaction.wait().then(() => {\n                    return this;\n                });\n\n            } else {\n                // @TODO: Once we allow a timeout to be passed in, we will wait\n                // up to that many blocks for getCode\n\n                // Otherwise, poll for our code to be deployed\n                this._deployedPromise = this.provider.getCode(this.address, blockTag).then((code) => {\n                    if (code === \"0x\") {\n                        logger.throwError(\"contract not deployed\", Logger.errors.UNSUPPORTED_OPERATION, {\n                            contractAddress: this.address,\n                            operation: \"getDeployed\"\n                        });\n                    }\n                    return this;\n                });\n            }\n        }\n\n        return this._deployedPromise;\n    }\n\n    // @TODO:\n    // estimateFallback(overrides?: TransactionRequest): Promise<BigNumber>\n\n    // @TODO:\n    // estimateDeploy(bytecode: string, ...args): Promise<BigNumber>\n\n    fallback(overrides?: TransactionRequest): Promise<TransactionResponse> {\n        if (!this.signer) {\n            logger.throwError(\"sending a transactions require a signer\", Logger.errors.UNSUPPORTED_OPERATION, { operation: \"sendTransaction(fallback)\" })\n        }\n\n        const tx: Deferrable<TransactionRequest> = shallowCopy(overrides || {});\n\n        [\"from\", \"to\"].forEach(function(key) {\n            if ((<any>tx)[key] == null) { return; }\n            logger.throwError(\"cannot override \" + key, Logger.errors.UNSUPPORTED_OPERATION, { operation: key })\n        });\n\n        tx.to = this.resolvedAddress;\n        return this.deployed().then(() => {\n            return this.signer.sendTransaction(tx);\n        });\n    }\n\n    // Reconnect to a different signer or provider\n    connect(signerOrProvider: Signer | Provider | string): Contract {\n        if (typeof(signerOrProvider) === \"string\") {\n            signerOrProvider = new VoidSigner(signerOrProvider, this.provider);\n        }\n\n        const contract = new (<{ new(...args: any[]): Contract }>(this.constructor))(this.address, this.interface, signerOrProvider);\n        if (this.deployTransaction) {\n            defineReadOnly(contract, \"deployTransaction\", this.deployTransaction);\n        }\n        return contract;\n    }\n\n    // Re-attach to a different on-chain instance of this contract\n    attach(addressOrName: string): Contract {\n        return new (<{ new(...args: any[]): Contract }>(this.constructor))(addressOrName, this.interface, this.signer || this.provider);\n    }\n\n    static isIndexed(value: any): value is Indexed {\n        return Indexed.isIndexed(value);\n    }\n\n    private _normalizeRunningEvent(runningEvent: RunningEvent): RunningEvent {\n        // Already have an instance of this event running; we can re-use it\n        if (this._runningEvents[runningEvent.tag]) {\n            return this._runningEvents[runningEvent.tag];\n         }\n         return runningEvent\n    }\n\n    private _getRunningEvent(eventName: EventFilter | string): RunningEvent {\n        if (typeof(eventName) === \"string\") {\n\n            // Listen for \"error\" events (if your contract has an error event, include\n            // the full signature to bypass this special event keyword)\n            if (eventName === \"error\") {\n                return this._normalizeRunningEvent(new ErrorRunningEvent());\n            }\n\n            // Listen for any event that is registered\n            if (eventName === \"event\") {\n                return this._normalizeRunningEvent(new RunningEvent(\"event\", null));\n            }\n\n            // Listen for any event\n            if (eventName === \"*\") {\n                return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));\n            }\n\n            // Get the event Fragment (throws if ambiguous/unknown event)\n            const fragment = this.interface.getEvent(eventName)\n            return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment));\n        }\n\n        // We have topics to filter by...\n        if (eventName.topics && eventName.topics.length > 0) {\n\n            // Is it a known topichash? (throws if no matching topichash)\n            try {\n                const topic = eventName.topics[0];\n                if (typeof(topic) !== \"string\") {\n                    throw new Error(\"invalid topic\"); // @TODO: May happen for anonymous events\n                }\n                const fragment = this.interface.getEvent(topic);\n                return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment, eventName.topics));\n            } catch (error) { }\n\n            // Filter by the unknown topichash\n            const filter: EventFilter = {\n                address: this.address,\n                topics: eventName.topics\n            }\n\n            return this._normalizeRunningEvent(new RunningEvent(getEventTag(filter), filter));\n        }\n\n        return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));\n    }\n\n    _checkRunningEvents(runningEvent: RunningEvent): void {\n        if (runningEvent.listenerCount() === 0) {\n            delete this._runningEvents[runningEvent.tag];\n\n            // If we have a poller for this, remove it\n            const emit = this._wrappedEmits[runningEvent.tag];\n            if (emit && runningEvent.filter) {\n                this.provider.off(runningEvent.filter, emit);\n                delete this._wrappedEmits[runningEvent.tag];\n            }\n        }\n    }\n\n    // Subclasses can override this to gracefully recover\n    // from parse errors if they wish\n    _wrapEvent(runningEvent: RunningEvent, log: Log, listener: Listener): Event {\n        const event = <Event>deepCopy(log);\n\n        event.removeListener = () => {\n            if (!listener) { return; }\n            runningEvent.removeListener(listener);\n            this._checkRunningEvents(runningEvent);\n        };\n\n        event.getBlock = () => { return this.provider.getBlock(log.blockHash); }\n        event.getTransaction = () => { return this.provider.getTransaction(log.transactionHash); }\n        event.getTransactionReceipt = () => { return this.provider.getTransactionReceipt(log.transactionHash); }\n\n        // This may throw if the topics and data mismatch the signature\n        runningEvent.prepareEvent(event);\n\n        return event;\n    }\n\n    private _addEventListener(runningEvent: RunningEvent, listener: Listener, once: boolean): void {\n        if (!this.provider) {\n            logger.throwError(\"events require a provider or a signer with a provider\", Logger.errors.UNSUPPORTED_OPERATION, { operation: \"once\" })\n        }\n\n        runningEvent.addListener(listener, once);\n\n        // Track this running event and its listeners (may already be there; but no hard in updating)\n        this._runningEvents[runningEvent.tag] = runningEvent;\n\n        // If we are not polling the provider, start polling\n        if (!this._wrappedEmits[runningEvent.tag]) {\n            const wrappedEmit = (log: Log) => {\n                let event = this._wrapEvent(runningEvent, log, listener);\n\n                // Try to emit the result for the parameterized event...\n                if (event.decodeError == null) {\n                    try {\n                        const args = runningEvent.getEmit(event);\n                        this.emit(runningEvent.filter, ...args);\n                    } catch (error) {\n                        event.decodeError = error.error;\n                    }\n                }\n\n                // Always emit \"event\" for fragment-base events\n                if (runningEvent.filter != null) {\n                    this.emit(\"event\", event);\n                }\n\n                // Emit \"error\" if there was an error\n                if (event.decodeError != null) {\n                    this.emit(\"error\", event.decodeError, event);\n                }\n            };\n            this._wrappedEmits[runningEvent.tag] = wrappedEmit;\n\n            // Special events, like \"error\" do not have a filter\n            if (runningEvent.filter != null) {\n                this.provider.on(runningEvent.filter, wrappedEmit);\n            }\n        }\n    }\n\n    queryFilter(event: EventFilter, fromBlockOrBlockhash?: BlockTag | string, toBlock?: BlockTag): Promise<Array<Event>> {\n        const runningEvent = this._getRunningEvent(event);\n        const filter = shallowCopy(runningEvent.filter);\n\n        if (typeof(fromBlockOrBlockhash) === \"string\" && isHexString(fromBlockOrBlockhash, 32)) {\n            if (toBlock != null) {\n                logger.throwArgumentError(\"cannot specify toBlock with blockhash\", \"toBlock\", toBlock);\n            }\n            (<FilterByBlockHash>filter).blockHash = fromBlockOrBlockhash;\n        } else {\n             (<Filter>filter).fromBlock = ((fromBlockOrBlockhash != null) ? fromBlockOrBlockhash: 0);\n             (<Filter>filter).toBlock = ((toBlock != null) ? toBlock: \"latest\");\n        }\n\n        return this.provider.getLogs(filter).then((logs) => {\n            return logs.map((log) => this._wrapEvent(runningEvent, log, null));\n        });\n    }\n\n    on(event: EventFilter | string, listener: Listener): this {\n        this._addEventListener(this._getRunningEvent(event), listener, false);\n        return this;\n    }\n\n    once(event: EventFilter | string, listener: Listener): this {\n        this._addEventListener(this._getRunningEvent(event), listener, true);\n        return this;\n    }\n\n    emit(eventName: EventFilter | string, ...args: Array<any>): boolean {\n        if (!this.provider) { return false; }\n\n        const runningEvent = this._getRunningEvent(eventName);\n        const result = (runningEvent.run(args) > 0);\n\n        // May have drained all the \"once\" events; check for living events\n        this._checkRunningEvents(runningEvent);\n\n        return result;\n    }\n\n    listenerCount(eventName?: EventFilter | string): number {\n        if (!this.provider) { return 0; }\n        if (eventName == null) {\n            return Object.keys(this._runningEvents).reduce((accum, key) => {\n                return accum + this._runningEvents[key].listenerCount();\n            }, 0);\n        }\n        return this._getRunningEvent(eventName).listenerCount();\n    }\n\n    listeners(eventName?: EventFilter | string): Array<Listener> {\n        if (!this.provider) { return []; }\n\n        if (eventName == null) {\n            const result: Array<Listener> = [ ];\n            for (let tag in this._runningEvents) {\n                this._runningEvents[tag].listeners().forEach((listener) => {\n                    result.push(listener)\n                });\n            }\n            return result;\n        }\n\n        return this._getRunningEvent(eventName).listeners();\n    }\n\n    removeAllListeners(eventName?: EventFilter | string): this {\n        if (!this.provider) { return this; }\n\n        if (eventName == null) {\n            for (const tag in this._runningEvents) {\n                const runningEvent = this._runningEvents[tag];\n                runningEvent.removeAllListeners();\n                this._checkRunningEvents(runningEvent);\n            }\n            return this;\n        }\n\n        // Delete any listeners\n        const runningEvent = this._getRunningEvent(eventName);\n        runningEvent.removeAllListeners();\n        this._checkRunningEvents(runningEvent);\n\n        return this;\n    }\n\n    off(eventName: EventFilter | string, listener: Listener): this {\n        if (!this.provider) { return this; }\n        const runningEvent = this._getRunningEvent(eventName);\n        runningEvent.removeListener(listener);\n        this._checkRunningEvents(runningEvent);\n        return this;\n    }\n\n    removeListener(eventName: EventFilter | string, listener: Listener): this {\n        return this.off(eventName, listener);\n    }\n\n}\n\nexport class Contract extends BaseContract {\n    // The meta-class properties\n    readonly [ key: string ]: ContractFunction | any;\n}\n\nexport class ContractFactory {\n\n    readonly interface: Interface;\n    readonly bytecode: string;\n    readonly signer: Signer;\n\n    constructor(contractInterface: ContractInterface, bytecode: BytesLike | { object: string }, signer?: Signer) {\n\n        let bytecodeHex: string = null;\n\n        if (typeof(bytecode) === \"string\") {\n            bytecodeHex = bytecode;\n        } else if (isBytes(bytecode)) {\n            bytecodeHex = hexlify(bytecode);\n        } else if (bytecode && typeof(bytecode.object) === \"string\") {\n            // Allow the bytecode object from the Solidity compiler\n            bytecodeHex = (<any>bytecode).object;\n        } else {\n            // Crash in the next verification step\n            bytecodeHex = \"!\";\n        }\n\n        // Make sure it is 0x prefixed\n        if (bytecodeHex.substring(0, 2) !== \"0x\") { bytecodeHex = \"0x\" + bytecodeHex; }\n\n        // Make sure the final result is valid bytecode\n        if (!isHexString(bytecodeHex) || (bytecodeHex.length % 2)) {\n            logger.throwArgumentError(\"invalid bytecode\", \"bytecode\", bytecode);\n        }\n\n        // If we have a signer, make sure it is valid\n        if (signer && !Signer.isSigner(signer)) {\n            logger.throwArgumentError(\"invalid signer\", \"signer\", signer);\n        }\n\n        defineReadOnly(this, \"bytecode\", bytecodeHex);\n        defineReadOnly(this, \"interface\", getStatic<InterfaceFunc>(new.target, \"getInterface\")(contractInterface));\n        defineReadOnly(this, \"signer\", signer || null);\n    }\n\n    // @TODO: Future; rename to populateTransaction?\n    getDeployTransaction(...args: Array<any>): TransactionRequest {\n        let tx: TransactionRequest = { };\n\n        // If we have 1 additional argument, we allow transaction overrides\n        if (args.length === this.interface.deploy.inputs.length + 1 && typeof(args[args.length - 1]) === \"object\") {\n            tx = shallowCopy(args.pop());\n            for (const key in tx) {\n                if (!allowedTransactionKeys[key]) {\n                    throw new Error(\"unknown transaction override \" + key);\n                }\n            }\n        }\n\n        // Do not allow these to be overridden in a deployment transaction\n        [\"data\", \"from\", \"to\"].forEach((key) => {\n            if ((<any>tx)[key] == null) { return; }\n            logger.throwError(\"cannot override \" + key, Logger.errors.UNSUPPORTED_OPERATION, { operation: key })\n        });\n\n        if (tx.value) {\n            const value = BigNumber.from(tx.value);\n            if (!value.isZero() && !this.interface.deploy.payable) {\n                logger.throwError(\"non-payable constructor cannot override value\", Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"overrides.value\",\n                    value: tx.value\n                });\n            }\n        }\n\n        // Make sure the call matches the constructor signature\n        logger.checkArgumentCount(args.length, this.interface.deploy.inputs.length, \" in Contract constructor\");\n\n        // Set the data to the bytecode + the encoded constructor arguments\n        tx.data = hexlify(concat([\n            this.bytecode,\n            this.interface.encodeDeploy(args)\n        ]));\n\n        return tx\n    }\n\n    async deploy(...args: Array<any>): Promise<Contract> {\n\n        let overrides: any = { };\n\n        // If 1 extra parameter was passed in, it contains overrides\n        if (args.length === this.interface.deploy.inputs.length + 1) {\n            overrides = args.pop();\n        }\n\n        // Make sure the call matches the constructor signature\n        logger.checkArgumentCount(args.length, this.interface.deploy.inputs.length, \" in Contract constructor\");\n\n        // Resolve ENS names and promises in the arguments\n        const params = await resolveAddresses(this.signer, args, this.interface.deploy.inputs);\n        params.push(overrides);\n\n        // Get the deployment transaction (with optional overrides)\n        const unsignedTx = this.getDeployTransaction(...params);\n\n        // Send the deployment transaction\n        const tx = await this.signer.sendTransaction(unsignedTx);\n\n        const address = getStatic<(tx: TransactionResponse) => string>(this.constructor, \"getContractAddress\")(tx);\n        const contract = getStatic<(address: string, contractInterface: ContractInterface, signer?: Signer) => Contract>(this.constructor, \"getContract\")(address, this.interface, this.signer);\n\n        // Add the modified wait that wraps events\n        addContractWait(contract, tx);\n\n        defineReadOnly(contract, \"deployTransaction\", tx);\n        return contract;\n    }\n\n    attach(address: string): Contract {\n        return (<any>(this.constructor)).getContract(address, this.interface, this.signer);\n    }\n\n    connect(signer: Signer) {\n        return new (<{ new(...args: any[]): ContractFactory }>(this.constructor))(this.interface, this.bytecode, signer);\n    }\n\n    static fromSolidity(compilerOutput: any, signer?: Signer): ContractFactory {\n        if (compilerOutput == null) {\n            logger.throwError(\"missing compiler output\", Logger.errors.MISSING_ARGUMENT, { argument: \"compilerOutput\" });\n        }\n\n        if (typeof(compilerOutput) === \"string\") {\n            compilerOutput = JSON.parse(compilerOutput);\n        }\n\n        const abi = compilerOutput.abi;\n\n        let bytecode: any = null;\n        if (compilerOutput.bytecode) {\n            bytecode = compilerOutput.bytecode;\n        } else if (compilerOutput.evm && compilerOutput.evm.bytecode) {\n            bytecode = compilerOutput.evm.bytecode;\n        }\n\n        return new this(abi, bytecode, signer);\n    }\n\n    static getInterface(contractInterface: ContractInterface) {\n        return Contract.getInterface(contractInterface);\n    }\n\n    static getContractAddress(tx: { from: string, nonce: BytesLike | BigNumber | number }): string {\n        return getContractAddress(tx);\n    }\n\n    static getContract(address: string, contractInterface: ContractInterface, signer?: Signer): Contract {\n        return new Contract(address, contractInterface, signer);\n    }\n}\n","export const version = \"contracts/5.5.0\";\n","\"use strict\";\n\nimport { arrayify, BytesLike, hexZeroPad, isBytes } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { BigNumber, BigNumberish, isBigNumberish } from \"./bignumber\";\n\nconst _constructorGuard = { };\n\nconst Zero = BigNumber.from(0);\nconst NegativeOne = BigNumber.from(-1);\n\nfunction throwFault(message: string, fault: string, operation: string, value?: any): never {\n    const params: any = { fault: fault, operation: operation };\n    if (value !== undefined) { params.value = value; }\n    return logger.throwError(message, Logger.errors.NUMERIC_FAULT, params);\n}\n\n// Constant to pull zeros from for multipliers\nlet zeros = \"0\";\nwhile (zeros.length < 256) { zeros += zeros; }\n\n// Returns a string \"1\" followed by decimal \"0\"s\nfunction getMultiplier(decimals: BigNumberish): string {\n\n    if (typeof(decimals) !== \"number\") {\n        try {\n            decimals = BigNumber.from(decimals).toNumber();\n        } catch (e) { }\n    }\n\n    if (typeof(decimals) === \"number\" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {\n        return (\"1\" + zeros.substring(0, decimals));\n    }\n\n    return logger.throwArgumentError(\"invalid decimal size\", \"decimals\", decimals);\n}\n\nexport function formatFixed(value: BigNumberish, decimals?: string | BigNumberish): string {\n    if (decimals == null) { decimals = 0; }\n    const multiplier = getMultiplier(decimals);\n\n    // Make sure wei is a big number (convert as necessary)\n    value = BigNumber.from(value);\n\n    const negative = value.lt(Zero);\n    if (negative) { value = value.mul(NegativeOne); }\n\n    let fraction = value.mod(multiplier).toString();\n    while (fraction.length < multiplier.length - 1) { fraction = \"0\" + fraction; }\n\n    // Strip training 0\n    fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];\n\n    const whole = value.div(multiplier).toString();\n    if (multiplier.length === 1) {\n        value = whole;\n    } else {\n        value = whole + \".\" + fraction;\n    }\n\n    if (negative) { value = \"-\" + value; }\n\n    return value;\n}\n\nexport function parseFixed(value: string, decimals?: BigNumberish): BigNumber {\n\n    if (decimals == null) { decimals = 0; }\n    const multiplier = getMultiplier(decimals);\n\n    if (typeof(value) !== \"string\" || !value.match(/^-?[0-9.]+$/)) {\n        logger.throwArgumentError(\"invalid decimal value\", \"value\", value);\n    }\n\n    // Is it negative?\n    const negative = (value.substring(0, 1) === \"-\");\n    if (negative) { value = value.substring(1); }\n\n    if (value === \".\") {\n        logger.throwArgumentError(\"missing value\", \"value\", value);\n    }\n\n    // Split it into a whole and fractional part\n    const comps = value.split(\".\");\n    if (comps.length > 2) {\n        logger.throwArgumentError(\"too many decimal points\", \"value\", value);\n    }\n\n    let whole = comps[0], fraction = comps[1];\n    if (!whole) { whole = \"0\"; }\n    if (!fraction) { fraction = \"0\"; }\n\n    // Trim trailing zeros\n    while (fraction[fraction.length - 1] === \"0\") {\n        fraction = fraction.substring(0, fraction.length - 1);\n    }\n\n    // Check the fraction doesn't exceed our decimals size\n    if (fraction.length > multiplier.length - 1) {\n        throwFault(\"fractional component exceeds decimals\", \"underflow\", \"parseFixed\");\n    }\n\n    // If decimals is 0, we have an empty string for fraction\n    if (fraction === \"\") { fraction = \"0\"; }\n\n    // Fully pad the string with zeros to get to wei\n    while (fraction.length < multiplier.length - 1) { fraction += \"0\"; }\n\n    const wholeValue = BigNumber.from(whole);\n    const fractionValue = BigNumber.from(fraction);\n\n    let wei = (wholeValue.mul(multiplier)).add(fractionValue);\n\n    if (negative) { wei = wei.mul(NegativeOne); }\n\n    return wei;\n}\n\n\nexport class FixedFormat {\n    readonly signed: boolean;\n    readonly width: number;\n    readonly decimals: number;\n    readonly name: string;\n    readonly _multiplier: string;\n\n    constructor(constructorGuard: any, signed: boolean, width: number, decimals: number) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot use FixedFormat constructor; use FixedFormat.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new FixedFormat\"\n            });\n        }\n\n        this.signed = signed;\n        this.width = width;\n        this.decimals = decimals;\n\n        this.name = (signed ? \"\": \"u\") + \"fixed\" + String(width) + \"x\" + String(decimals);\n\n        this._multiplier = getMultiplier(decimals);\n\n        Object.freeze(this);\n    }\n\n    static from(value: any): FixedFormat {\n        if (value instanceof FixedFormat) { return value; }\n\n        if (typeof(value) === \"number\") {\n            value = `fixed128x${value}`\n        }\n\n        let signed = true;\n        let width = 128;\n        let decimals = 18;\n\n        if (typeof(value) === \"string\") {\n            if (value === \"fixed\") {\n                // defaults...\n            } else if (value === \"ufixed\") {\n                signed = false;\n            } else {\n                const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);\n                if (!match) { logger.throwArgumentError(\"invalid fixed format\", \"format\", value); }\n                signed = (match[1] !== \"u\");\n                width = parseInt(match[2]);\n                decimals = parseInt(match[3]);\n            }\n        } else if (value) {\n            const check = (key: string, type: string, defaultValue: any): any => {\n                if (value[key] == null) { return defaultValue; }\n                if (typeof(value[key]) !== type) {\n                    logger.throwArgumentError(\"invalid fixed format (\" + key + \" not \" + type +\")\", \"format.\" + key, value[key]);\n                }\n                return value[key];\n            }\n            signed = check(\"signed\", \"boolean\", signed);\n            width = check(\"width\", \"number\", width);\n            decimals = check(\"decimals\", \"number\", decimals);\n        }\n\n        if (width % 8) {\n            logger.throwArgumentError(\"invalid fixed format width (not byte aligned)\", \"format.width\", width);\n        }\n\n        if (decimals > 80) {\n            logger.throwArgumentError(\"invalid fixed format (decimals too large)\", \"format.decimals\", decimals);\n        }\n\n        return new FixedFormat(_constructorGuard, signed, width, decimals);\n    }\n}\n\nexport class FixedNumber {\n    readonly format: FixedFormat;\n    readonly _hex: string;\n    readonly _value: string;\n\n    readonly _isFixedNumber: boolean;\n\n    constructor(constructorGuard: any, hex: string, value: string, format?: FixedFormat) {\n        logger.checkNew(new.target, FixedNumber);\n\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot use FixedNumber constructor; use FixedNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new FixedFormat\"\n            });\n        }\n\n        this.format = format;\n        this._hex = hex;\n        this._value = value;\n\n        this._isFixedNumber = true;\n\n        Object.freeze(this);\n    }\n\n    _checkFormat(other: FixedNumber): void {\n        if (this.format.name !== other.format.name) {\n            logger.throwArgumentError(\"incompatible format; use fixedNumber.toFormat\", \"other\", other);\n        }\n    }\n\n    addUnsafe(other: FixedNumber): FixedNumber {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.add(b), this.format.decimals, this.format);\n    }\n\n    subUnsafe(other: FixedNumber): FixedNumber {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.sub(b), this.format.decimals, this.format);\n    }\n\n    mulUnsafe(other: FixedNumber): FixedNumber {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.mul(b).div(this.format._multiplier), this.format.decimals, this.format);\n    }\n\n    divUnsafe(other: FixedNumber): FixedNumber {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.mul(this.format._multiplier).div(b), this.format.decimals, this.format);\n    }\n\n    floor(): FixedNumber {\n        const comps = this.toString().split(\".\");\n        if (comps.length === 1) { comps.push(\"0\"); }\n\n        let result = FixedNumber.from(comps[0], this.format);\n\n        const hasFraction = !comps[1].match(/^(0*)$/);\n        if (this.isNegative() && hasFraction) {\n            result = result.subUnsafe(ONE.toFormat(result.format));\n        }\n\n        return result;\n    }\n\n    ceiling(): FixedNumber {\n        const comps = this.toString().split(\".\");\n        if (comps.length === 1) { comps.push(\"0\"); }\n\n        let result = FixedNumber.from(comps[0], this.format);\n\n        const hasFraction = !comps[1].match(/^(0*)$/);\n        if (!this.isNegative() && hasFraction) {\n            result = result.addUnsafe(ONE.toFormat(result.format));\n        }\n\n        return result;\n    }\n\n    // @TODO: Support other rounding algorithms\n    round(decimals?: number): FixedNumber {\n        if (decimals == null) { decimals = 0; }\n\n        // If we are already in range, we're done\n        const comps = this.toString().split(\".\");\n        if (comps.length === 1) { comps.push(\"0\"); }\n\n        if (decimals < 0 || decimals > 80 || (decimals % 1)) {\n            logger.throwArgumentError(\"invalid decimal count\", \"decimals\", decimals);\n        }\n\n        if (comps[1].length <= decimals) { return this; }\n\n        const factor = FixedNumber.from(\"1\" + zeros.substring(0, decimals), this.format);\n        const bump = BUMP.toFormat(this.format);\n\n        return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);\n    }\n\n    isZero(): boolean {\n        return (this._value === \"0.0\" || this._value === \"0\");\n    }\n\n    isNegative(): boolean {\n        return (this._value[0] === \"-\");\n    }\n\n    toString(): string { return this._value; }\n\n    toHexString(width?: number): string {\n        if (width == null) { return this._hex; }\n        if (width % 8) { logger.throwArgumentError(\"invalid byte width\", \"width\", width); }\n        const hex = BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();\n        return hexZeroPad(hex, width / 8);\n    }\n\n    toUnsafeFloat(): number { return parseFloat(this.toString()); }\n\n    toFormat(format: FixedFormat | string): FixedNumber {\n        return FixedNumber.fromString(this._value, format);\n    }\n\n\n    static fromValue(value: BigNumber, decimals?: BigNumberish, format?: FixedFormat | string | number): FixedNumber {\n        // If decimals looks more like a format, and there is no format, shift the parameters\n        if (format == null && decimals != null && !isBigNumberish(decimals)) {\n            format = decimals;\n            decimals = null;\n        }\n\n        if (decimals == null) { decimals = 0; }\n        if (format == null) { format = \"fixed\"; }\n\n        return FixedNumber.fromString(formatFixed(value, decimals), FixedFormat.from(format));\n    }\n\n\n    static fromString(value: string, format?: FixedFormat | string | number): FixedNumber {\n        if (format == null) { format = \"fixed\"; }\n\n        const fixedFormat = FixedFormat.from(format);\n\n        const numeric = parseFixed(value, fixedFormat.decimals);\n\n        if (!fixedFormat.signed && numeric.lt(Zero)) {\n            throwFault(\"unsigned value cannot be negative\", \"overflow\", \"value\", value);\n        }\n\n        let hex: string = null;\n        if (fixedFormat.signed) {\n            hex = numeric.toTwos(fixedFormat.width).toHexString();\n        } else {\n            hex = numeric.toHexString();\n            hex = hexZeroPad(hex, fixedFormat.width / 8);\n        }\n\n        const decimal = formatFixed(numeric, fixedFormat.decimals);\n\n        return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);\n    }\n\n    static fromBytes(value: BytesLike, format?: FixedFormat | string | number): FixedNumber {\n        if (format == null) { format = \"fixed\"; }\n\n        const fixedFormat = FixedFormat.from(format);\n\n        if (arrayify(value).length > fixedFormat.width / 8) {\n            throw new Error(\"overflow\");\n        }\n\n        let numeric = BigNumber.from(value);\n        if (fixedFormat.signed) { numeric = numeric.fromTwos(fixedFormat.width); }\n\n        const hex = numeric.toTwos((fixedFormat.signed ? 0: 1) + fixedFormat.width).toHexString();\n        const decimal = formatFixed(numeric, fixedFormat.decimals);\n\n        return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);\n    }\n\n    static from(value: any, format?: FixedFormat | string | number) {\n        if (typeof(value) === \"string\") {\n            return FixedNumber.fromString(value, format);\n        }\n\n        if (isBytes(value)) {\n            return FixedNumber.fromBytes(value, format);\n        }\n\n        try {\n            return FixedNumber.fromValue(value, 0, format);\n        } catch (error) {\n            // Allow NUMERIC_FAULT to bubble up\n            if (error.code !== Logger.errors.INVALID_ARGUMENT) {\n                throw error;\n            }\n        }\n\n        return logger.throwArgumentError(\"invalid FixedNumber value\", \"value\", value);\n    }\n\n    static isFixedNumber(value: any): value is FixedNumber {\n        return !!(value && value._isFixedNumber);\n    }\n}\n\nconst ONE = FixedNumber.from(1);\nconst BUMP = FixedNumber.from(\"0.5\");\n","import { Bytes, concat } from \"@ethersproject/bytes\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { toUtf8Bytes } from \"@ethersproject/strings\";\n\nexport const messagePrefix = \"\\x19Ethereum Signed Message:\\n\";\n\nexport function hashMessage(message: Bytes | string): string {\n    if (typeof(message) === \"string\") { message = toUtf8Bytes(message); }\n    return keccak256(concat([\n        toUtf8Bytes(messagePrefix),\n        toUtf8Bytes(String(message.length)),\n        message\n    ]));\n}\n\n","export const version = \"hash/5.5.0\";\n","import { TypedDataDomain, TypedDataField } from \"@ethersproject/abstract-signer\";\nimport { getAddress } from \"@ethersproject/address\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { arrayify, BytesLike, hexConcat, hexlify, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { deepCopy, defineReadOnly, shallowCopy } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { id } from \"./id\";\n\nconst padding = new Uint8Array(32);\npadding.fill(0);\n\nconst NegativeOne: BigNumber = BigNumber.from(-1);\nconst Zero: BigNumber = BigNumber.from(0);\nconst One: BigNumber = BigNumber.from(1);\nconst MaxUint256: BigNumber = BigNumber.from(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n\nfunction hexPadRight(value: BytesLike) {\n    const bytes = arrayify(value);\n    const padOffset = bytes.length % 32\n    if (padOffset) {\n        return hexConcat([ bytes, padding.slice(padOffset) ]);\n    }\n    return hexlify(bytes);\n}\n\nconst hexTrue = hexZeroPad(One.toHexString(), 32);\nconst hexFalse = hexZeroPad(Zero.toHexString(), 32);\n\nconst domainFieldTypes: Record<string, string> = {\n    name: \"string\",\n    version: \"string\",\n    chainId: \"uint256\",\n    verifyingContract: \"address\",\n    salt: \"bytes32\"\n};\n\nconst domainFieldNames: Array<string> = [\n    \"name\", \"version\", \"chainId\", \"verifyingContract\", \"salt\"\n];\n\nfunction checkString(key: string): (value: any) => string {\n    return function (value: any){\n        if (typeof(value) !== \"string\") {\n            logger.throwArgumentError(`invalid domain value for ${ JSON.stringify(key) }`, `domain.${ key }`, value);\n        }\n        return value;\n    }\n}\n\nconst domainChecks: Record<string, (value: any) => any> = {\n    name: checkString(\"name\"),\n    version: checkString(\"version\"),\n    chainId: function(value: any) {\n        try {\n            return BigNumber.from(value).toString()\n        } catch (error) { }\n        return logger.throwArgumentError(`invalid domain value for \"chainId\"`, \"domain.chainId\", value);\n    },\n    verifyingContract: function(value: any) {\n        try {\n            return getAddress(value).toLowerCase();\n        } catch (error) { }\n        return logger.throwArgumentError(`invalid domain value \"verifyingContract\"`, \"domain.verifyingContract\", value);\n    },\n    salt: function(value: any) {\n        try {\n            const bytes = arrayify(value);\n            if (bytes.length !== 32) { throw new Error(\"bad length\"); }\n            return hexlify(bytes);\n        } catch (error) { }\n        return logger.throwArgumentError(`invalid domain value \"salt\"`, \"domain.salt\", value);\n    }\n}\n\nfunction getBaseEncoder(type: string): (value: any) => string {\n    // intXX and uintXX\n    {\n        const match = type.match(/^(u?)int(\\d*)$/);\n        if (match) {\n            const signed = (match[1] === \"\");\n\n            const width = parseInt(match[2] || \"256\");\n            if (width % 8 !== 0 || width > 256 || (match[2] && match[2] !== String(width))) {\n                logger.throwArgumentError(\"invalid numeric width\", \"type\", type);\n            }\n\n            const boundsUpper = MaxUint256.mask(signed ? (width - 1): width);\n            const boundsLower = signed ? boundsUpper.add(One).mul(NegativeOne): Zero;\n\n            return function(value: BigNumberish) {\n                const v = BigNumber.from(value);\n\n                if (v.lt(boundsLower) || v.gt(boundsUpper)) {\n                    logger.throwArgumentError(`value out-of-bounds for ${ type }`, \"value\", value);\n                }\n\n                return hexZeroPad(v.toTwos(256).toHexString(), 32);\n            };\n        }\n    }\n\n    // bytesXX\n    {\n        const match = type.match(/^bytes(\\d+)$/);\n        if (match) {\n            const width = parseInt(match[1]);\n            if (width === 0 || width > 32 || match[1] !== String(width)) {\n                logger.throwArgumentError(\"invalid bytes width\", \"type\", type);\n            }\n\n            return function(value: BytesLike) {\n                const bytes = arrayify(value);\n                if (bytes.length !== width) {\n                    logger.throwArgumentError(`invalid length for ${ type }`, \"value\", value);\n                }\n                return hexPadRight(value);\n            };\n        }\n    }\n\n    switch (type) {\n        case \"address\": return function(value: string) {\n            return hexZeroPad(getAddress(value), 32);\n        };\n        case \"bool\": return function(value: boolean) {\n            return ((!value) ? hexFalse: hexTrue);\n        };\n        case \"bytes\": return function(value: BytesLike) {\n            return keccak256(value);\n        };\n        case \"string\": return function(value: string) {\n            return id(value);\n        };\n    }\n\n    return null;\n}\n\nfunction encodeType(name: string, fields: Array<TypedDataField>): string {\n    return `${ name }(${ fields.map(({ name, type }) => (type + \" \" + name)).join(\",\") })`;\n}\n\nexport class TypedDataEncoder {\n    readonly primaryType: string;\n    readonly types: Record<string, Array<TypedDataField>>;\n\n    readonly _encoderCache: Record<string, (value: any) => string>;\n    readonly _types: Record<string, string>;\n\n    constructor(types: Record<string, Array<TypedDataField>>) {\n        defineReadOnly(this, \"types\", Object.freeze(deepCopy(types)));\n\n        defineReadOnly(this, \"_encoderCache\", { });\n        defineReadOnly(this, \"_types\", { });\n\n        // Link struct types to their direct child structs\n        const links: Record<string, Record<string, boolean>> = { };\n\n        // Link structs to structs which contain them as a child\n        const parents: Record<string, Array<string>> = { };\n\n        // Link all subtypes within a given struct\n        const subtypes: Record<string, Record<string, boolean>> = { };\n\n        Object.keys(types).forEach((type) => {\n            links[type] = { };\n            parents[type] = [ ];\n            subtypes[type] = { }\n        });\n\n        for (const name in types) {\n\n            const uniqueNames: Record<string, boolean> = { };\n\n            types[name].forEach((field) => {\n\n                // Check each field has a unique name\n                if (uniqueNames[field.name]) {\n                    logger.throwArgumentError(`duplicate variable name ${ JSON.stringify(field.name) } in ${ JSON.stringify(name) }`, \"types\", types);\n                }\n                uniqueNames[field.name] = true;\n\n                // Get the base type (drop any array specifiers)\n                const baseType = field.type.match(/^([^\\x5b]*)(\\x5b|$)/)[1];\n                if (baseType === name) {\n                    logger.throwArgumentError(`circular type reference to ${ JSON.stringify(baseType) }`, \"types\", types);\n                }\n\n                // Is this a base encoding type?\n                const encoder = getBaseEncoder(baseType);\n                if (encoder) { return ;}\n\n                if (!parents[baseType]) {\n                    logger.throwArgumentError(`unknown type ${ JSON.stringify(baseType) }`, \"types\", types);\n                }\n\n                // Add linkage\n                parents[baseType].push(name);\n                links[name][baseType] = true;\n            });\n        }\n\n        // Deduce the primary type\n        const primaryTypes = Object.keys(parents).filter((n) => (parents[n].length === 0));\n\n        if (primaryTypes.length === 0) {\n            logger.throwArgumentError(\"missing primary type\", \"types\", types);\n        } else if (primaryTypes.length > 1) {\n            logger.throwArgumentError(`ambiguous primary types or unused types: ${ primaryTypes.map((t) => (JSON.stringify(t))).join(\", \") }`, \"types\", types);\n        }\n\n        defineReadOnly(this, \"primaryType\", primaryTypes[0]);\n\n        // Check for circular type references\n        function checkCircular(type: string, found: Record<string, boolean>) {\n            if (found[type]) {\n                logger.throwArgumentError(`circular type reference to ${ JSON.stringify(type) }`, \"types\", types);\n            }\n\n            found[type] = true;\n\n            Object.keys(links[type]).forEach((child) => {\n                if (!parents[child]) { return; }\n\n                // Recursively check children\n                checkCircular(child, found);\n\n                // Mark all ancestors as having this decendant\n                Object.keys(found).forEach((subtype) => {\n                    subtypes[subtype][child] = true;\n                });\n            });\n\n            delete found[type];\n        }\n        checkCircular(this.primaryType, { });\n\n        // Compute each fully describe type\n        for (const name in subtypes) {\n            const st = Object.keys(subtypes[name]);\n            st.sort();\n            this._types[name] = encodeType(name, types[name]) + st.map((t) => encodeType(t, types[t])).join(\"\");\n        }\n    }\n\n    getEncoder(type: string): (value: any) => string {\n        let encoder = this._encoderCache[type];\n        if (!encoder) {\n            encoder = this._encoderCache[type] = this._getEncoder(type);\n        }\n        return encoder;\n    }\n\n    _getEncoder(type: string): (value: any) => string {\n\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) { return encoder; }\n        }\n\n        // Array\n        const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n        if (match) {\n            const subtype = match[1];\n            const subEncoder = this.getEncoder(subtype);\n            const length = parseInt(match[3]);\n            return (value: Array<any>) => {\n                if (length >= 0 && value.length !== length) {\n                    logger.throwArgumentError(\"array length mismatch; expected length ${ arrayLength }\", \"value\", value);\n                }\n\n                let result = value.map(subEncoder);\n                if (this._types[subtype]) {\n                    result = result.map(keccak256);\n                }\n\n                return keccak256(hexConcat(result));\n            };\n        }\n\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            const encodedType = id(this._types[type]);\n            return (value: Record<string, any>) => {\n                const values = fields.map(({ name, type }) => {\n                    const result = this.getEncoder(type)(value[name]);\n                    if (this._types[type]) { return keccak256(result); }\n                    return result;\n                });\n                values.unshift(encodedType);\n                return hexConcat(values);\n            }\n        }\n\n        return logger.throwArgumentError(`unknown type: ${ type }`, \"type\", type);\n    }\n\n    encodeType(name: string): string {\n        const result = this._types[name];\n        if (!result) {\n            logger.throwArgumentError(`unknown type: ${ JSON.stringify(name) }`, \"name\", name);\n        }\n        return result;\n    }\n\n    encodeData(type: string, value: any): string {\n        return this.getEncoder(type)(value);\n    }\n\n    hashStruct(name: string, value: Record<string, any>): string {\n        return keccak256(this.encodeData(name, value));\n    }\n\n    encode(value: Record<string, any>): string {\n        return this.encodeData(this.primaryType, value);\n    }\n\n    hash(value: Record<string, any>): string {\n        return this.hashStruct(this.primaryType, value);\n    }\n\n    _visit(type: string, value: any, callback: (type: string, data: any) => any): any {\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) { return callback(type, value); }\n        }\n\n        // Array\n        const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n        if (match) {\n            const subtype = match[1];\n            const length = parseInt(match[3]);\n            if (length >= 0 && value.length !== length) {\n                logger.throwArgumentError(\"array length mismatch; expected length ${ arrayLength }\", \"value\", value);\n            }\n            return value.map((v: any) => this._visit(subtype, v, callback));\n        }\n\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            return fields.reduce((accum, { name, type }) => {\n                accum[name] = this._visit(type, value[name], callback);\n                return accum;\n            }, <Record<string, any>>{});\n        }\n\n        return logger.throwArgumentError(`unknown type: ${ type }`, \"type\", type);\n    }\n\n    visit(value: Record<string, any>, callback: (type: string, data: any) => any): any {\n        return this._visit(this.primaryType, value, callback);\n    }\n\n    static from(types: Record<string, Array<TypedDataField>>): TypedDataEncoder {\n        return new TypedDataEncoder(types);\n    }\n\n    static getPrimaryType(types: Record<string, Array<TypedDataField>>): string {\n        return TypedDataEncoder.from(types).primaryType;\n    }\n\n    static hashStruct(name: string, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): string {\n        return TypedDataEncoder.from(types).hashStruct(name, value);\n    }\n\n    static hashDomain(domain: TypedDataDomain): string {\n        const domainFields: Array<TypedDataField> = [ ];\n        for (const name in domain) {\n            const type = domainFieldTypes[name];\n            if (!type) {\n                logger.throwArgumentError(`invalid typed-data domain key: ${ JSON.stringify(name) }`, \"domain\", domain);\n            }\n            domainFields.push({ name, type });\n        }\n\n        domainFields.sort((a, b) => {\n            return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);\n        });\n\n        return TypedDataEncoder.hashStruct(\"EIP712Domain\", { EIP712Domain: domainFields }, domain);\n    }\n\n    static encode(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): string {\n        return hexConcat([\n            \"0x1901\",\n            TypedDataEncoder.hashDomain(domain),\n            TypedDataEncoder.from(types).hash(value)\n        ]);\n    }\n\n    static hash(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): string {\n        return keccak256(TypedDataEncoder.encode(domain, types, value));\n    }\n\n    // Replaces all address types with ENS names with their looked up address\n    static async resolveNames(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>, resolveName: (name: string) => Promise<string>): Promise<{ domain: TypedDataDomain, value: any }> {\n        // Make a copy to isolate it from the object passed in\n        domain = shallowCopy(domain);\n\n        // Look up all ENS names\n        const ensCache: Record<string, string> = { };\n\n        // Do we need to look up the domain's verifyingContract?\n        if (domain.verifyingContract && !isHexString(domain.verifyingContract, 20)) {\n            ensCache[domain.verifyingContract] = \"0x\";\n        }\n\n        // We are going to use the encoder to visit all the base values\n        const encoder = TypedDataEncoder.from(types);\n\n        // Get a list of all the addresses\n        encoder.visit(value, (type: string, value: any) => {\n            if (type === \"address\" && !isHexString(value, 20)) {\n                ensCache[value] = \"0x\";\n            }\n            return value;\n        });\n\n        // Lookup each name\n        for (const name in ensCache) {\n            ensCache[name] = await resolveName(name);\n        }\n\n        // Replace the domain verifyingContract if needed\n        if (domain.verifyingContract && ensCache[domain.verifyingContract]) {\n            domain.verifyingContract = ensCache[domain.verifyingContract];\n        }\n\n        // Replace all ENS names with their address\n        value = encoder.visit(value, (type: string, value: any) => {\n            if (type === \"address\" && ensCache[value]) { return ensCache[value]; }\n            return value;\n        });\n\n        return { domain, value };\n    }\n\n    static getPayload(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): any {\n        // Validate the domain fields\n        TypedDataEncoder.hashDomain(domain);\n\n        // Derive the EIP712Domain Struct reference type\n        const domainValues: Record<string, any> = { };\n        const domainTypes: Array<{ name: string, type:string }> = [ ];\n\n        domainFieldNames.forEach((name) => {\n            const value = (<any>domain)[name];\n            if (value == null) { return; }\n            domainValues[name] = domainChecks[name](value);\n            domainTypes.push({ name, type: domainFieldTypes[name] });\n        });\n\n        const encoder = TypedDataEncoder.from(types);\n\n        const typesWithDomain = shallowCopy(types);\n        if (typesWithDomain.EIP712Domain) {\n            logger.throwArgumentError(\"types must not contain EIP712Domain type\", \"types.EIP712Domain\", types);\n        } else {\n            typesWithDomain.EIP712Domain = domainTypes;\n        }\n\n        // Validate the data structures and types\n        encoder.encode(value);\n\n        return {\n            types: typesWithDomain,\n            domain: domainValues,\n            primaryType: encoder.primaryType,\n            message: encoder.visit(value, (type: string, value: any) => {\n\n                // bytes\n                if (type.match(/^bytes(\\d*)/)) {\n                    return hexlify(arrayify(value));\n                }\n\n                // uint or int\n                if (type.match(/^u?int/)) {\n                    return BigNumber.from(value).toString();\n                }\n\n                switch (type) {\n                    case \"address\":\n                        return value.toLowerCase();\n                    case \"bool\":\n                        return !!value;\n                    case \"string\":\n                        if (typeof(value) !== \"string\") {\n                            logger.throwArgumentError(`invalid string`, \"value\", value);\n                        }\n                        return value;\n                }\n\n                return logger.throwArgumentError(\"unsupported type\", \"type\", type);\n            })\n        };\n    }\n}\n\n","/**\n * var basex = require(\"base-x\");\n *\n * This implementation is heavily based on base-x. The main reason to\n * deviate was to prevent the dependency of Buffer.\n *\n * Contributors:\n *\n * base-x encoding\n * Forked from https://github.com/cryptocoinjs/bs58\n * Originally written by Mike Hearn for BitcoinJ\n * Copyright (c) 2011 Google Inc\n * Ported to JavaScript by Stefan Thomas\n * Merged Buffer refactorings from base58-native by Stephen Pair\n * Copyright (c) 2013 BitPay Inc\n *\n * The MIT License (MIT)\n *\n * Copyright base-x contributors (c) 2016\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n *\n */\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nexport class BaseX {\n    readonly alphabet: string;\n    readonly base: number;\n\n    _alphabetMap: { [ character: string ]: number };\n    _leader: string;\n\n    constructor(alphabet: string) {\n        defineReadOnly(this, \"alphabet\", alphabet);\n        defineReadOnly(this, \"base\", alphabet.length);\n\n        defineReadOnly(this, \"_alphabetMap\", { });\n        defineReadOnly(this, \"_leader\", alphabet.charAt(0));\n\n        // pre-compute lookup table\n        for (let i = 0; i < alphabet.length; i++) {\n            this._alphabetMap[alphabet.charAt(i)] = i;\n        }\n    }\n\n    encode(value: BytesLike): string {\n        let source = arrayify(value);\n\n        if (source.length === 0) { return \"\"; }\n\n        let digits = [ 0 ]\n        for (let i = 0; i < source.length; ++i) {\n            let carry = source[i];\n            for (let j = 0; j < digits.length; ++j) {\n                carry += digits[j] << 8;\n                digits[j] = carry % this.base;\n                carry = (carry / this.base) | 0;\n            }\n\n            while (carry > 0) {\n                digits.push(carry % this.base);\n                carry = (carry / this.base) | 0;\n            }\n        }\n\n        let string = \"\"\n\n        // deal with leading zeros\n        for (let k = 0; source[k] === 0 && k < source.length - 1; ++k) {\n            string += this._leader;\n        }\n\n        // convert digits to a string\n        for (let q = digits.length - 1; q >= 0; --q) {\n            string += this.alphabet[digits[q]];\n        }\n\n        return string;\n    }\n\n    decode(value: string): Uint8Array {\n        if (typeof(value) !== \"string\") {\n            throw new TypeError(\"Expected String\");\n        }\n\n        let bytes: Array<number> = [];\n        if (value.length === 0) { return new Uint8Array(bytes); }\n\n        bytes.push(0);\n        for (let i = 0; i < value.length; i++) {\n            let byte = this._alphabetMap[value[i]];\n\n            if (byte === undefined) {\n                throw new Error(\"Non-base\" + this.base + \" character\");\n            }\n\n            let carry = byte;\n            for (let j = 0; j < bytes.length; ++j) {\n                carry += bytes[j] * this.base;\n                bytes[j] = carry & 0xff;\n                carry >>= 8;\n            }\n\n            while (carry > 0) {\n                bytes.push(carry & 0xff);\n                carry >>= 8;\n            }\n        }\n\n        // deal with leading zeros\n        for (let k = 0; value[k] === this._leader && k < value.length - 1; ++k) {\n            bytes.push(0)\n        }\n\n        return arrayify(new Uint8Array(bytes.reverse()))\n    }\n}\n\nconst Base32 = new BaseX(\"abcdefghijklmnopqrstuvwxyz234567\");\nconst Base58 = new BaseX(\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\");\n\nexport { Base32, Base58 };\n\n//console.log(Base58.decode(\"Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj\"))\n//console.log(Base58.encode(Base58.decode(\"Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj\")))\n","\"use strict\";\n\nimport { arrayify, BytesLike, hexlify } from \"@ethersproject/bytes\";\nimport { computeHmac, SupportedAlgorithm } from \"@ethersproject/sha2\";\n\nexport function pbkdf2(password: BytesLike, salt: BytesLike, iterations: number, keylen: number, hashAlgorithm: string): string {\n    password = arrayify(password);\n    salt = arrayify(salt);\n    let hLen;\n    let l = 1;\n    const DK = new Uint8Array(keylen)\n    const block1 = new Uint8Array(salt.length + 4)\n    block1.set(salt);\n    //salt.copy(block1, 0, 0, salt.length)\n\n    let r: number;\n    let T: Uint8Array;\n\n    for (let i = 1; i <= l; i++) {\n        //block1.writeUInt32BE(i, salt.length)\n        block1[salt.length] = (i >> 24) & 0xff;\n        block1[salt.length + 1] = (i >> 16) & 0xff;\n        block1[salt.length + 2] = (i >> 8) & 0xff;\n        block1[salt.length + 3] = i & 0xff;\n\n        //let U = createHmac(password).update(block1).digest();\n        let U = arrayify(computeHmac(<SupportedAlgorithm>hashAlgorithm, password, block1));\n\n        if (!hLen) {\n            hLen = U.length\n            T = new Uint8Array(hLen)\n            l = Math.ceil(keylen / hLen)\n            r = keylen - (l - 1) * hLen\n        }\n\n        //U.copy(T, 0, 0, hLen)\n        T.set(U);\n\n\n        for (let j = 1; j < iterations; j++) {\n            //U = createHmac(password).update(U).digest();\n            U = arrayify(computeHmac(<SupportedAlgorithm>hashAlgorithm, password, U));\n            for (let k = 0; k < hLen; k++) T[k] ^= U[k]\n        }\n\n\n        const destPos = (i - 1) * hLen\n        const len = (i === l ? r : hLen)\n        //T.copy(DK, destPos, 0, len)\n        DK.set(arrayify(T).slice(0, len), destPos);\n    }\n\n    return hexlify(DK)\n}\n\n","\"use strict\";\n\n// This gets overridden by rollup\nconst exportWordlist = false;\n\nimport { id } from \"@ethersproject/hash\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nexport const logger = new Logger(version);\n\nexport abstract class Wordlist {\n    readonly locale: string;\n\n    constructor(locale: string) {\n        logger.checkAbstract(new.target, Wordlist);\n        defineReadOnly(this, \"locale\", locale);\n    }\n\n    abstract getWord(index: number): string;\n    abstract getWordIndex(word: string): number;\n\n    // Subclasses may override this\n    split(mnemonic: string): Array<string> {\n        return mnemonic.toLowerCase().split(/ +/g)\n    }\n\n    // Subclasses may override this\n    join(words: Array<string>): string {\n        return words.join(\" \");\n    }\n\n    static check(wordlist: Wordlist): string {\n        const words = [];\n        for (let i = 0; i < 2048; i++) {\n            const word = wordlist.getWord(i);\n            /* istanbul ignore if */\n            if (i !== wordlist.getWordIndex(word)) { return \"0x\"; }\n            words.push(word);\n        }\n        return id(words.join(\"\\n\") + \"\\n\");\n    }\n\n    static register(lang: Wordlist, name?: string): void {\n        if (!name) { name = lang.locale; }\n\n        /* istanbul ignore if */\n        if (exportWordlist) {\n            try {\n                const anyGlobal = (window as any)\n                if (anyGlobal._ethers && anyGlobal._ethers.wordlists) {\n                    if (!anyGlobal._ethers.wordlists[name]) {\n                         defineReadOnly(anyGlobal._ethers.wordlists, name, lang);\n                    }\n                }\n            } catch (error) { }\n        }\n    }\n\n}\n\n","export const version = \"wordlists/5.5.0\";\n","\"use strict\";\n\nimport { Wordlist } from \"./wordlist\";\n\n\nconst words = \"AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo\";\n\nlet wordlist: Array<string> = null;\n\n\nfunction loadWords(lang: Wordlist): void {\n    if (wordlist != null) { return; }\n    wordlist = words.replace(/([A-Z])/g, \" $1\").toLowerCase().substring(1).split(\" \");\n\n    // Verify the computed list matches the official list\n    /* istanbul ignore if */\n    if (Wordlist.check(lang) !== \"0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60\") {\n        wordlist = null;\n        throw new Error(\"BIP39 Wordlist for en (English) FAILED\");\n    }\n}\n\nclass LangEn extends Wordlist {\n    constructor() {\n        super(\"en\");\n    }\n\n    getWord(index: number): string {\n        loadWords(this);\n        return wordlist[index];\n    }\n\n    getWordIndex(word: string): number {\n        loadWords(this);\n        return wordlist.indexOf(word);\n    }\n}\n\nconst langEn = new LangEn();\nWordlist.register(langEn);\n\nexport { langEn };\n","\"use strict\";\n\n// Wordlists\n// See: https://github.com/bitcoin/bips/blob/master/bip-0039/bip-0039-wordlists.md\n\n// Browser; only include English by default\n\nimport { Wordlist } from \"./wordlist\";\n\nimport { langEn as en } from \"./lang-en\";\n\nexport const wordlists: { [ locale: string ]: Wordlist } = {\n  en: en\n}\n","\"use strict\";\n\n// See: https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki\n// See: https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki\n\n\nimport { ExternallyOwnedAccount } from \"@ethersproject/abstract-signer\";\nimport { Base58 } from \"@ethersproject/basex\";\nimport { arrayify, BytesLike, concat, hexDataSlice, hexZeroPad, hexlify } from \"@ethersproject/bytes\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { toUtf8Bytes, UnicodeNormalizationForm } from \"@ethersproject/strings\";\nimport { pbkdf2 } from \"@ethersproject/pbkdf2\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { SigningKey } from \"@ethersproject/signing-key\";\nimport { computeHmac, ripemd160, sha256, SupportedAlgorithm } from \"@ethersproject/sha2\";\nimport { computeAddress } from \"@ethersproject/transactions\";\nimport { Wordlist, wordlists } from \"@ethersproject/wordlists\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst N = BigNumber.from(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\");\n\n\n// \"Bitcoin seed\"\nconst MasterSecret = toUtf8Bytes(\"Bitcoin seed\");\n\nconst HardenedBit = 0x80000000;\n\n// Returns a byte with the MSB bits set\nfunction getUpperMask(bits: number): number {\n   return ((1 << bits) - 1) << (8 - bits);\n}\n\n// Returns a byte with the LSB bits set\nfunction getLowerMask(bits: number): number {\n   return (1 << bits) - 1;\n}\n\nfunction bytes32(value: BigNumber | Uint8Array): string {\n    return hexZeroPad(hexlify(value), 32);\n}\n\nfunction base58check(data: Uint8Array): string {\n    return Base58.encode(concat([ data, hexDataSlice(sha256(sha256(data)), 0, 4) ]));\n}\n\nfunction getWordlist(wordlist: string | Wordlist): Wordlist {\n    if (wordlist == null) {\n        return wordlists[\"en\"];\n    }\n\n    if (typeof(wordlist) === \"string\") {\n        const words = wordlists[wordlist];\n        if (words == null) {\n            logger.throwArgumentError(\"unknown locale\", \"wordlist\", wordlist);\n        }\n        return words;\n    }\n\n    return wordlist;\n}\n\nconst _constructorGuard: any = {};\n\nexport const defaultPath = \"m/44'/60'/0'/0/0\";\n\nexport interface Mnemonic {\n    readonly phrase: string;\n    readonly path: string;\n    readonly locale: string;\n};\n\nexport class HDNode implements ExternallyOwnedAccount {\n    readonly privateKey: string;\n    readonly publicKey: string;\n\n    readonly fingerprint: string;\n    readonly parentFingerprint: string;\n\n    readonly address: string;\n\n    readonly mnemonic?: Mnemonic;\n    readonly path: string;\n\n    readonly chainCode: string;\n\n    readonly index: number;\n    readonly depth: number;\n\n    /**\n     *  This constructor should not be called directly.\n     *\n     *  Please use:\n     *   - fromMnemonic\n     *   - fromSeed\n     */\n    constructor(constructorGuard: any, privateKey: string, publicKey: string, parentFingerprint: string, chainCode: string, index: number, depth: number, mnemonicOrPath: Mnemonic | string) {\n        logger.checkNew(new.target, HDNode);\n\n        /* istanbul ignore if */\n        if (constructorGuard !== _constructorGuard) {\n            throw new Error(\"HDNode constructor cannot be called directly\");\n        }\n\n        if (privateKey) {\n            const signingKey = new SigningKey(privateKey);\n            defineReadOnly(this, \"privateKey\", signingKey.privateKey);\n            defineReadOnly(this, \"publicKey\", signingKey.compressedPublicKey);\n        } else {\n            defineReadOnly(this, \"privateKey\", null);\n            defineReadOnly(this, \"publicKey\", hexlify(publicKey));\n        }\n\n        defineReadOnly(this, \"parentFingerprint\", parentFingerprint);\n        defineReadOnly(this, \"fingerprint\", hexDataSlice(ripemd160(sha256(this.publicKey)), 0, 4));\n\n        defineReadOnly(this, \"address\", computeAddress(this.publicKey));\n\n        defineReadOnly(this, \"chainCode\", chainCode);\n\n        defineReadOnly(this, \"index\", index);\n        defineReadOnly(this, \"depth\", depth);\n\n        if (mnemonicOrPath == null) {\n            // From a source that does not preserve the path (e.g. extended keys)\n            defineReadOnly(this, \"mnemonic\", null);\n            defineReadOnly(this, \"path\", null);\n\n        } else if (typeof(mnemonicOrPath) === \"string\") {\n            // From a source that does not preserve the mnemonic (e.g. neutered)\n            defineReadOnly(this, \"mnemonic\", null);\n            defineReadOnly(this, \"path\", mnemonicOrPath);\n\n        } else {\n            // From a fully qualified source\n            defineReadOnly(this, \"mnemonic\", mnemonicOrPath);\n            defineReadOnly(this, \"path\", mnemonicOrPath.path);\n        }\n    }\n\n    get extendedKey(): string {\n        // We only support the mainnet values for now, but if anyone needs\n        // testnet values, let me know. I believe current sentiment is that\n        // we should always use mainnet, and use BIP-44 to derive the network\n        //   - Mainnet: public=0x0488B21E, private=0x0488ADE4\n        //   - Testnet: public=0x043587CF, private=0x04358394\n\n        if (this.depth >= 256) { throw new Error(\"Depth too large!\"); }\n\n        return base58check(concat([\n            ((this.privateKey != null) ? \"0x0488ADE4\": \"0x0488B21E\"),\n            hexlify(this.depth),\n            this.parentFingerprint,\n            hexZeroPad(hexlify(this.index), 4),\n            this.chainCode,\n            ((this.privateKey != null) ? concat([ \"0x00\", this.privateKey ]): this.publicKey),\n        ]));\n    }\n\n    neuter(): HDNode {\n        return new HDNode(_constructorGuard, null, this.publicKey, this.parentFingerprint, this.chainCode, this.index, this.depth, this.path);\n    }\n\n    private _derive(index: number): HDNode {\n        if (index > 0xffffffff) { throw new Error(\"invalid index - \" + String(index)); }\n\n        // Base path\n        let path = this.path;\n        if (path) { path += \"/\" + (index & ~HardenedBit); }\n\n        const data = new Uint8Array(37);\n\n        if (index & HardenedBit) {\n            if (!this.privateKey) {\n                throw new Error(\"cannot derive child of neutered node\");\n            }\n\n            // Data = 0x00 || ser_256(k_par)\n            data.set(arrayify(this.privateKey), 1);\n\n            // Hardened path\n            if (path) { path += \"'\"; }\n\n        } else {\n            // Data = ser_p(point(k_par))\n            data.set(arrayify(this.publicKey));\n        }\n\n        // Data += ser_32(i)\n        for (let i = 24; i >= 0; i -= 8) { data[33 + (i >> 3)] = ((index >> (24 - i)) & 0xff); }\n\n        const I = arrayify(computeHmac(SupportedAlgorithm.sha512, this.chainCode, data));\n        const IL = I.slice(0, 32);\n        const IR = I.slice(32);\n\n        // The private key\n        let ki: string = null\n\n        // The public key\n        let Ki: string = null;\n\n        if (this.privateKey) {\n            ki = bytes32(BigNumber.from(IL).add(this.privateKey).mod(N));\n        } else {\n            const ek = new SigningKey(hexlify(IL));\n            Ki = ek._addPoint(this.publicKey);\n        }\n\n        let mnemonicOrPath: Mnemonic | string = path;\n\n        const srcMnemonic =  this.mnemonic;\n        if (srcMnemonic) {\n            mnemonicOrPath = Object.freeze({\n                phrase: srcMnemonic.phrase,\n                path: path,\n                locale: (srcMnemonic.locale || \"en\")\n            });\n        }\n\n        return new HDNode(_constructorGuard, ki, Ki, this.fingerprint, bytes32(IR), index, this.depth + 1, mnemonicOrPath);\n    }\n\n    derivePath(path: string): HDNode {\n        const components = path.split(\"/\");\n\n        if (components.length === 0 || (components[0] === \"m\" && this.depth !== 0)) {\n            throw new Error(\"invalid path - \" + path);\n        }\n\n        if (components[0] === \"m\") { components.shift(); }\n\n        let result: HDNode = this;\n        for (let i = 0; i < components.length; i++) {\n            const component = components[i];\n            if (component.match(/^[0-9]+'$/)) {\n                const index = parseInt(component.substring(0, component.length - 1));\n                if (index >= HardenedBit) { throw new Error(\"invalid path index - \" + component); }\n                result = result._derive(HardenedBit + index);\n            } else if (component.match(/^[0-9]+$/)) {\n                const index = parseInt(component);\n                if (index >= HardenedBit) { throw new Error(\"invalid path index - \" + component); }\n                result = result._derive(index);\n            } else {\n                throw new Error(\"invalid path component - \" + component);\n            }\n        }\n\n        return result;\n    }\n\n\n    static _fromSeed(seed: BytesLike, mnemonic: Mnemonic): HDNode {\n        const seedArray: Uint8Array = arrayify(seed);\n        if (seedArray.length < 16 || seedArray.length > 64) { throw new Error(\"invalid seed\"); }\n\n        const I: Uint8Array = arrayify(computeHmac(SupportedAlgorithm.sha512, MasterSecret, seedArray));\n\n        return new HDNode(_constructorGuard, bytes32(I.slice(0, 32)), null, \"0x00000000\", bytes32(I.slice(32)), 0, 0, mnemonic);\n    }\n\n    static fromMnemonic(mnemonic: string, password?: string, wordlist?: string | Wordlist): HDNode {\n\n        // If a locale name was passed in, find the associated wordlist\n        wordlist = getWordlist(wordlist);\n\n        // Normalize the case and spacing in the mnemonic (throws if the mnemonic is invalid)\n        mnemonic = entropyToMnemonic(mnemonicToEntropy(mnemonic, wordlist), wordlist);\n\n        return HDNode._fromSeed(mnemonicToSeed(mnemonic, password), {\n            phrase: mnemonic,\n            path: \"m\",\n            locale: wordlist.locale\n        });\n    }\n\n    static fromSeed(seed: BytesLike): HDNode {\n        return HDNode._fromSeed(seed, null);\n    }\n\n    static fromExtendedKey(extendedKey: string): HDNode {\n        const bytes = Base58.decode(extendedKey);\n\n        if (bytes.length !== 82 || base58check(bytes.slice(0, 78)) !== extendedKey) {\n            logger.throwArgumentError(\"invalid extended key\", \"extendedKey\", \"[REDACTED]\");\n        }\n\n        const depth = bytes[4];\n        const parentFingerprint = hexlify(bytes.slice(5, 9));\n        const index = parseInt(hexlify(bytes.slice(9, 13)).substring(2), 16);\n        const chainCode = hexlify(bytes.slice(13, 45));\n        const key = bytes.slice(45, 78);\n\n        switch (hexlify(bytes.slice(0, 4))) {\n            // Public Key\n            case \"0x0488b21e\": case \"0x043587cf\":\n                return new HDNode(_constructorGuard, null, hexlify(key), parentFingerprint, chainCode, index, depth, null);\n\n            // Private Key\n            case \"0x0488ade4\": case \"0x04358394 \":\n                if (key[0] !== 0) { break; }\n                return new HDNode(_constructorGuard, hexlify(key.slice(1)), null, parentFingerprint, chainCode, index, depth, null);\n        }\n\n        return logger.throwArgumentError(\"invalid extended key\", \"extendedKey\", \"[REDACTED]\");\n    }\n}\n\nexport function mnemonicToSeed(mnemonic: string, password?: string): string {\n    if (!password) { password = \"\"; }\n\n    const salt = toUtf8Bytes(\"mnemonic\" + password, UnicodeNormalizationForm.NFKD);\n\n    return pbkdf2(toUtf8Bytes(mnemonic, UnicodeNormalizationForm.NFKD), salt, 2048, 64, \"sha512\");\n}\n\nexport function mnemonicToEntropy(mnemonic: string, wordlist?: string | Wordlist): string {\n    wordlist = getWordlist(wordlist);\n\n    logger.checkNormalize();\n\n    const words = wordlist.split(mnemonic);\n    if ((words.length % 3) !== 0) { throw new Error(\"invalid mnemonic\"); }\n\n    const entropy = arrayify(new Uint8Array(Math.ceil(11 * words.length / 8)));\n\n    let offset = 0;\n    for (let i = 0; i < words.length; i++) {\n        let index = wordlist.getWordIndex(words[i].normalize(\"NFKD\"));\n        if (index === -1) { throw new Error(\"invalid mnemonic\"); }\n\n        for (let bit = 0; bit < 11; bit++) {\n            if (index & (1 << (10 - bit))) {\n                entropy[offset >> 3] |= (1 << (7 - (offset % 8)));\n            }\n            offset++;\n        }\n    }\n\n    const entropyBits = 32 * words.length / 3;\n\n    const checksumBits = words.length / 3;\n    const checksumMask = getUpperMask(checksumBits);\n\n    const checksum = arrayify(sha256(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;\n\n    if (checksum !== (entropy[entropy.length - 1] & checksumMask)) {\n        throw new Error(\"invalid checksum\");\n    }\n\n    return hexlify(entropy.slice(0, entropyBits / 8));\n}\n\nexport function entropyToMnemonic(entropy: BytesLike, wordlist?: string | Wordlist): string {\n    wordlist = getWordlist(wordlist);\n\n    entropy = arrayify(entropy);\n\n    if ((entropy.length % 4) !== 0 || entropy.length < 16 || entropy.length > 32) {\n        throw new Error(\"invalid entropy\");\n    }\n\n    const indices: Array<number> = [ 0 ];\n\n    let remainingBits = 11;\n    for (let i = 0; i < entropy.length; i++) {\n\n        // Consume the whole byte (with still more to go)\n        if (remainingBits > 8) {\n            indices[indices.length - 1] <<= 8;\n            indices[indices.length - 1] |= entropy[i];\n\n            remainingBits -= 8;\n\n        // This byte will complete an 11-bit index\n        } else {\n            indices[indices.length - 1] <<= remainingBits;\n            indices[indices.length - 1] |= entropy[i] >> (8 - remainingBits);\n\n            // Start the next word\n            indices.push(entropy[i] & getLowerMask(8 - remainingBits));\n\n            remainingBits += 3;\n        }\n    }\n\n    // Compute the checksum bits\n    const checksumBits = entropy.length / 4;\n    const checksum = arrayify(sha256(entropy))[0] & getUpperMask(checksumBits);\n\n    // Shift the checksum into the word indices\n    indices[indices.length - 1] <<= checksumBits;\n    indices[indices.length - 1] |= (checksum >> (8 - checksumBits));\n\n    return wordlist.join(indices.map((index) => (<Wordlist>wordlist).getWord(index)));\n}\n\nexport function isValidMnemonic(mnemonic: string, wordlist?: Wordlist): boolean {\n    try {\n        mnemonicToEntropy(mnemonic, wordlist);\n        return true;\n    } catch (error) { }\n    return false;\n}\n\nexport function getAccountPath(index: number): string {\n    if (typeof(index) !== \"number\" || index < 0 || index >= HardenedBit || index % 1) {\n        logger.throwArgumentError(\"invalid account index\", \"index\", index);\n    }\n    return `m/44'/60'/${ index }'/0/0`;\n}\n","export const version = \"hdnode/5.5.0\";\n","export const version = \"random/5.5.1\";\n","\"use strict\";\n\nimport { arrayify } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n// Debugging line for testing browser lib in node\n//const window = { crypto: { getRandomValues: () => { } } };\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis\nfunction getGlobal(): any {\n  if (typeof self !== 'undefined') { return self; }\n  if (typeof window !== 'undefined') { return window; }\n  if (typeof global !== 'undefined') { return global; }\n  throw new Error('unable to locate global object');\n};\n\nconst anyGlobal = getGlobal();\n\nlet crypto: any = anyGlobal.crypto || anyGlobal.msCrypto;\nif (!crypto || !crypto.getRandomValues) {\n\n    logger.warn(\"WARNING: Missing strong random number source\");\n\n    crypto = {\n        getRandomValues: function(buffer: Uint8Array): Uint8Array {\n            return logger.throwError(\"no secure random source avaialble\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"crypto.getRandomValues\"\n            });\n        }\n    };\n}\n\nexport function randomBytes(length: number): Uint8Array {\n    if (length <= 0 || length > 1024 || (length % 1) || length != length) {\n        logger.throwArgumentError(\"invalid length\", \"length\", length);\n    }\n\n    const result = new Uint8Array(length);\n    crypto.getRandomValues(result);\n    return arrayify(result);\n};\n","export const version = \"json-wallets/5.5.0\";\n","\"use strict\";\n\nimport { arrayify, Bytes, BytesLike, hexlify } from \"@ethersproject/bytes\";\nimport { toUtf8Bytes, UnicodeNormalizationForm } from '@ethersproject/strings';\n\nexport function looseArrayify(hexString: string): Uint8Array {\n    if (typeof(hexString) === 'string' && hexString.substring(0, 2) !== '0x') {\n        hexString = '0x' + hexString;\n    }\n    return arrayify(hexString);\n}\n\nexport function zpad(value: String | number, length: number): String {\n    value = String(value);\n    while (value.length < length) { value = '0' + value; }\n    return value;\n}\n\nexport function getPassword(password: Bytes | string): Uint8Array {\n    if (typeof(password) === 'string') {\n        return toUtf8Bytes(password, UnicodeNormalizationForm.NFKC);\n    }\n    return arrayify(password);\n}\n\nexport function searchPath(object: any, path: string): string {\n    let currentChild = object;\n\n    const comps = path.toLowerCase().split('/');\n    for (let i = 0; i < comps.length; i++) {\n\n        // Search for a child object with a case-insensitive matching key\n        let matchingChild = null;\n        for (const key in currentChild) {\n             if (key.toLowerCase() === comps[i]) {\n                 matchingChild = currentChild[key];\n                 break;\n             }\n        }\n\n        // Didn't find one. :'(\n        if (matchingChild === null) {\n            return null;\n        }\n\n        // Now check this child...\n        currentChild = matchingChild;\n    }\n\n    return currentChild;\n}\n\n// See: https://www.ietf.org/rfc/rfc4122.txt (Section 4.4)\nexport function uuidV4(randomBytes: BytesLike): string {\n    const bytes = arrayify(randomBytes);\n\n    // Section: 4.1.3:\n    // - time_hi_and_version[12:16] = 0b0100\n    bytes[6] = (bytes[6] & 0x0f) | 0x40;\n\n    // Section 4.4\n    // - clock_seq_hi_and_reserved[6] = 0b0\n    // - clock_seq_hi_and_reserved[7] = 0b1\n    bytes[8] = (bytes[8] & 0x3f) | 0x80;\n\n    const value = hexlify(bytes);\n\n    return [\n       value.substring(2, 10),\n       value.substring(10, 14),\n       value.substring(14, 18),\n       value.substring(18, 22),\n       value.substring(22, 34),\n    ].join(\"-\");\n}\n\n","\"use strict\";\n\nimport aes from \"aes-js\";\n\nimport { ExternallyOwnedAccount } from \"@ethersproject/abstract-signer\";\nimport { getAddress } from \"@ethersproject/address\";\nimport { arrayify, Bytes } from \"@ethersproject/bytes\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { pbkdf2 } from \"@ethersproject/pbkdf2\";\nimport { toUtf8Bytes } from \"@ethersproject/strings\";\nimport { Description } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { getPassword, looseArrayify, searchPath } from \"./utils\";\n\nexport interface _CrowdsaleAccount {\n    address: string;\n    privateKey: string;\n\n    _isCrowdsaleAccount: boolean;\n}\n\nexport class CrowdsaleAccount extends Description<_CrowdsaleAccount> implements ExternallyOwnedAccount {\n    readonly address: string;\n    readonly privateKey: string;\n    readonly mnemonic?: string;\n    readonly path?: string;\n\n    readonly _isCrowdsaleAccount: boolean;\n\n    isCrowdsaleAccount(value: any): value is CrowdsaleAccount {\n        return !!(value && value._isCrowdsaleAccount);\n    }\n}\n\n// See: https://github.com/ethereum/pyethsaletool\nexport function decrypt(json: string, password: Bytes | string): ExternallyOwnedAccount {\n    const data = JSON.parse(json);\n\n    password = getPassword(password);\n\n    // Ethereum Address\n    const ethaddr = getAddress(searchPath(data, \"ethaddr\"));\n\n    // Encrypted Seed\n    const encseed = looseArrayify(searchPath(data, \"encseed\"));\n    if (!encseed || (encseed.length % 16) !== 0) {\n        logger.throwArgumentError(\"invalid encseed\", \"json\", json);\n    }\n\n    const key = arrayify(pbkdf2(password, password, 2000, 32, \"sha256\")).slice(0, 16);\n\n    const iv = encseed.slice(0, 16);\n    const encryptedSeed = encseed.slice(16);\n\n    // Decrypt the seed\n    const aesCbc = new aes.ModeOfOperation.cbc(key, iv);\n    const seed = aes.padding.pkcs7.strip(arrayify(aesCbc.decrypt(encryptedSeed)));\n\n    // This wallet format is weird... Convert the binary encoded hex to a string.\n    let seedHex = \"\";\n    for (let i = 0; i < seed.length; i++) {\n        seedHex += String.fromCharCode(seed[i]);\n    }\n\n    const seedHexBytes = toUtf8Bytes(seedHex);\n\n    const privateKey = keccak256(seedHexBytes);\n\n    return new CrowdsaleAccount ({\n        _isCrowdsaleAccount: true,\n        address: ethaddr,\n        privateKey: privateKey\n    });\n}\n\n","\"use strict\";\n\nimport { getAddress } from \"@ethersproject/address\";\n\n\nexport function isCrowdsaleWallet(json: string): boolean {\n    let data: any = null;\n    try {\n        data = JSON.parse(json);\n    } catch (error) { return false; }\n\n    return (data.encseed && data.ethaddr);\n}\n\nexport function isKeystoreWallet(json: string): boolean {\n    let data: any = null;\n    try {\n        data = JSON.parse(json);\n    } catch (error) { return false; }\n\n    if (!data.version || parseInt(data.version) !== data.version || parseInt(data.version) !== 3) {\n        return false;\n    }\n\n    // @TODO: Put more checks to make sure it has kdf, iv and all that good stuff\n    return true;\n}\n\n//export function isJsonWallet(json: string): boolean {\n//    return (isSecretStorageWallet(json) || isCrowdsaleWallet(json));\n//}\n\nexport function getJsonWalletAddress(json: string): string {\n    if (isCrowdsaleWallet(json)) {\n        try {\n            return getAddress(JSON.parse(json).ethaddr);\n        } catch (error) { return null; }\n    }\n\n    if (isKeystoreWallet(json)) {\n        try {\n            return getAddress(JSON.parse(json).address);\n        } catch (error) { return null; }\n    }\n\n    return null;\n}\n\n","\"use strict\";\n\nimport aes from \"aes-js\";\nimport scrypt from \"scrypt-js\";\n\nimport { ExternallyOwnedAccount } from \"@ethersproject/abstract-signer\";\nimport { getAddress } from \"@ethersproject/address\";\nimport { arrayify, Bytes, BytesLike, concat, hexlify } from \"@ethersproject/bytes\";\nimport { defaultPath, entropyToMnemonic, HDNode, Mnemonic, mnemonicToEntropy } from \"@ethersproject/hdnode\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { pbkdf2 as _pbkdf2 } from \"@ethersproject/pbkdf2\";\nimport { randomBytes } from \"@ethersproject/random\";\nimport { Description } from \"@ethersproject/properties\";\nimport { computeAddress } from \"@ethersproject/transactions\";\n\nimport { getPassword, looseArrayify, searchPath, uuidV4, zpad } from \"./utils\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n// Exported Types\n\nfunction hasMnemonic(value: any): value is { mnemonic: Mnemonic } {\n    return (value != null && value.mnemonic && value.mnemonic.phrase);\n}\n\nexport interface _KeystoreAccount {\n    address: string;\n    privateKey: string;\n    mnemonic?: Mnemonic;\n\n    _isKeystoreAccount: boolean;\n}\n\nexport class KeystoreAccount extends Description<_KeystoreAccount> implements ExternallyOwnedAccount {\n    readonly address: string;\n    readonly privateKey: string;\n    readonly mnemonic?: Mnemonic;\n\n    readonly _isKeystoreAccount: boolean;\n\n    isKeystoreAccount(value: any): value is KeystoreAccount {\n        return !!(value && value._isKeystoreAccount);\n    }\n}\n\nexport type ProgressCallback = (percent: number) => void;\n\nexport type EncryptOptions = {\n   iv?: BytesLike;\n   entropy?: BytesLike;\n   client?: string;\n   salt?: BytesLike;\n   uuid?: string;\n   scrypt?: {\n       N?: number;\n       r?: number;\n       p?: number;\n   }\n}\n\nfunction _decrypt(data: any, key: Uint8Array, ciphertext: Uint8Array): Uint8Array {\n    const cipher = searchPath(data, \"crypto/cipher\");\n    if (cipher === \"aes-128-ctr\") {\n        const iv = looseArrayify(searchPath(data, \"crypto/cipherparams/iv\"))\n        const counter = new aes.Counter(iv);\n\n        const aesCtr = new aes.ModeOfOperation.ctr(key, counter);\n\n        return arrayify(aesCtr.decrypt(ciphertext));\n    }\n\n    return null;\n}\n\nfunction _getAccount(data: any, key: Uint8Array): KeystoreAccount {\n    const ciphertext = looseArrayify(searchPath(data, \"crypto/ciphertext\"));\n\n    const computedMAC = hexlify(keccak256(concat([ key.slice(16, 32), ciphertext ]))).substring(2);\n    if (computedMAC !== searchPath(data, \"crypto/mac\").toLowerCase()) {\n        throw new Error(\"invalid password\");\n    }\n\n    const privateKey = _decrypt(data, key.slice(0, 16), ciphertext);\n\n    if (!privateKey) {\n        logger.throwError(\"unsupported cipher\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"decrypt\"\n        });\n    }\n\n    const mnemonicKey = key.slice(32, 64);\n\n    const address = computeAddress(privateKey);\n    if (data.address) {\n        let check = data.address.toLowerCase();\n        if (check.substring(0, 2) !== \"0x\") { check = \"0x\" + check; }\n\n        if (getAddress(check) !== address) {\n            throw new Error(\"address mismatch\");\n        }\n    }\n\n    const account: _KeystoreAccount = {\n        _isKeystoreAccount: true,\n        address: address,\n        privateKey: hexlify(privateKey)\n    };\n\n    // Version 0.1 x-ethers metadata must contain an encrypted mnemonic phrase\n    if (searchPath(data, \"x-ethers/version\") === \"0.1\") {\n        const mnemonicCiphertext = looseArrayify(searchPath(data, \"x-ethers/mnemonicCiphertext\"));\n        const mnemonicIv = looseArrayify(searchPath(data, \"x-ethers/mnemonicCounter\"));\n\n        const mnemonicCounter = new aes.Counter(mnemonicIv);\n        const mnemonicAesCtr = new aes.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);\n\n        const path = searchPath(data, \"x-ethers/path\") || defaultPath;\n        const locale = searchPath(data, \"x-ethers/locale\") || \"en\";\n\n        const entropy = arrayify(mnemonicAesCtr.decrypt(mnemonicCiphertext));\n\n        try {\n            const mnemonic = entropyToMnemonic(entropy, locale);\n            const node = HDNode.fromMnemonic(mnemonic, null, locale).derivePath(path);\n\n            if (node.privateKey != account.privateKey) {\n                throw new Error(\"mnemonic mismatch\");\n            }\n\n            account.mnemonic = node.mnemonic;\n\n        } catch (error) {\n            // If we don't have the locale wordlist installed to\n            // read this mnemonic, just bail and don't set the\n            // mnemonic\n            if (error.code !== Logger.errors.INVALID_ARGUMENT || error.argument !== \"wordlist\") {\n                throw error;\n            }\n        }\n    }\n\n    return new KeystoreAccount(account);\n}\n\ntype ScryptFunc<T> = (pw: Uint8Array, salt: Uint8Array, n: number, r: number, p: number, dkLen: number, callback?: ProgressCallback) => T;\ntype Pbkdf2Func<T> = (pw: Uint8Array, salt: Uint8Array, c: number, dkLen: number, prfFunc: string) => T;\n\nfunction pbkdf2Sync(passwordBytes: Uint8Array, salt: Uint8Array, count: number, dkLen: number, prfFunc: string): Uint8Array {\n    return arrayify(_pbkdf2(passwordBytes, salt, count, dkLen, prfFunc));\n}\n\nfunction pbkdf2(passwordBytes: Uint8Array, salt: Uint8Array, count: number, dkLen: number, prfFunc: string): Promise<Uint8Array> {\n    return Promise.resolve(pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc));\n}\n\nfunction _computeKdfKey<T>(data: any, password: Bytes | string, pbkdf2Func: Pbkdf2Func<T>, scryptFunc: ScryptFunc<T>, progressCallback?: ProgressCallback): T {\n    const passwordBytes = getPassword(password);\n\n    const kdf = searchPath(data, \"crypto/kdf\");\n\n    if (kdf && typeof(kdf) === \"string\") {\n        const throwError = function(name: string, value: any): never {\n            return logger.throwArgumentError(\"invalid key-derivation function parameters\", name, value);\n        }\n\n        if (kdf.toLowerCase() === \"scrypt\") {\n            const salt = looseArrayify(searchPath(data, \"crypto/kdfparams/salt\"));\n            const N = parseInt(searchPath(data, \"crypto/kdfparams/n\"));\n            const r = parseInt(searchPath(data, \"crypto/kdfparams/r\"));\n            const p = parseInt(searchPath(data, \"crypto/kdfparams/p\"));\n\n            // Check for all required parameters\n            if (!N || !r || !p) { throwError(\"kdf\", kdf); }\n\n            // Make sure N is a power of 2\n            if ((N & (N - 1)) !== 0) { throwError(\"N\", N); }\n\n            const dkLen = parseInt(searchPath(data, \"crypto/kdfparams/dklen\"));\n            if (dkLen !== 32) { throwError(\"dklen\", dkLen); }\n\n            return scryptFunc(passwordBytes, salt, N, r, p, 64, progressCallback);\n\n        } else if (kdf.toLowerCase() === \"pbkdf2\") {\n\n            const salt = looseArrayify(searchPath(data, \"crypto/kdfparams/salt\"));\n\n            let prfFunc: string = null;\n            const prf = searchPath(data, \"crypto/kdfparams/prf\");\n            if (prf === \"hmac-sha256\") {\n                prfFunc = \"sha256\";\n            } else if (prf === \"hmac-sha512\") {\n                prfFunc = \"sha512\";\n            } else {\n                throwError(\"prf\", prf);\n            }\n\n            const count = parseInt(searchPath(data, \"crypto/kdfparams/c\"));\n\n            const dkLen = parseInt(searchPath(data, \"crypto/kdfparams/dklen\"));\n            if (dkLen !== 32) { throwError(\"dklen\", dkLen); }\n\n            return pbkdf2Func(passwordBytes, salt, count, dkLen, prfFunc);\n        }\n    }\n\n    return logger.throwArgumentError(\"unsupported key-derivation function\", \"kdf\", kdf);\n}\n\n\nexport function decryptSync(json: string, password: Bytes | string): KeystoreAccount {\n    const data = JSON.parse(json);\n\n    const key = _computeKdfKey(data, password, pbkdf2Sync, scrypt.syncScrypt);\n    return _getAccount(data, key);\n}\n\nexport async function decrypt(json: string, password: Bytes | string, progressCallback?: ProgressCallback): Promise<KeystoreAccount> {\n    const data = JSON.parse(json);\n\n    const key = await _computeKdfKey(data, password, pbkdf2, scrypt.scrypt, progressCallback);\n    return _getAccount(data, key);\n}\n\n\nexport function encrypt(account: ExternallyOwnedAccount, password: Bytes | string, options?: EncryptOptions, progressCallback?: ProgressCallback): Promise<string> {\n\n    try {\n        // Check the address matches the private key\n        if (getAddress(account.address) !== computeAddress(account.privateKey)) {\n            throw new Error(\"address/privateKey mismatch\");\n        }\n\n        // Check the mnemonic (if any) matches the private key\n        if (hasMnemonic(account)) {\n            const mnemonic = account.mnemonic;\n            const node = HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path || defaultPath);\n\n            if (node.privateKey != account.privateKey) {\n                throw new Error(\"mnemonic mismatch\");\n            }\n        }\n\n    } catch (e) {\n        return Promise.reject(e);\n    }\n\n    // The options are optional, so adjust the call as needed\n    if (typeof(options) === \"function\" && !progressCallback) {\n        progressCallback = options;\n        options = {};\n    }\n    if (!options) { options = {}; }\n\n    const privateKey: Uint8Array = arrayify(account.privateKey);\n    const passwordBytes = getPassword(password);\n\n    let entropy: Uint8Array = null\n    let path: string = null;\n    let locale: string = null;\n    if (hasMnemonic(account)) {\n        const srcMnemonic = account.mnemonic;\n        entropy = arrayify(mnemonicToEntropy(srcMnemonic.phrase, srcMnemonic.locale || \"en\"));\n        path = srcMnemonic.path || defaultPath;\n        locale = srcMnemonic.locale || \"en\";\n    }\n\n    let client = options.client;\n    if (!client) { client = \"ethers.js\"; }\n\n    // Check/generate the salt\n    let salt: Uint8Array = null;\n    if (options.salt) {\n        salt = arrayify(options.salt);\n    } else {\n        salt = randomBytes(32);;\n    }\n\n    // Override initialization vector\n    let iv: Uint8Array = null;\n    if (options.iv) {\n        iv = arrayify(options.iv);\n        if (iv.length !== 16) { throw new Error(\"invalid iv\"); }\n    } else {\n       iv = randomBytes(16);\n    }\n\n    // Override the uuid\n    let uuidRandom: Uint8Array = null;\n    if (options.uuid) {\n        uuidRandom = arrayify(options.uuid);\n        if (uuidRandom.length !== 16) { throw new Error(\"invalid uuid\"); }\n    } else {\n        uuidRandom = randomBytes(16);\n    }\n\n    // Override the scrypt password-based key derivation function parameters\n    let N = (1 << 17), r = 8, p = 1;\n    if (options.scrypt) {\n        if (options.scrypt.N) { N = options.scrypt.N; }\n        if (options.scrypt.r) { r = options.scrypt.r; }\n        if (options.scrypt.p) { p = options.scrypt.p; }\n    }\n\n    // We take 64 bytes:\n    //   - 32 bytes   As normal for the Web3 secret storage (derivedKey, macPrefix)\n    //   - 32 bytes   AES key to encrypt mnemonic with (required here to be Ethers Wallet)\n    return scrypt.scrypt(passwordBytes, salt, N, r, p, 64, progressCallback).then((key) => {\n        key = arrayify(key);\n\n        // This will be used to encrypt the wallet (as per Web3 secret storage)\n        const derivedKey = key.slice(0, 16);\n        const macPrefix = key.slice(16, 32);\n\n        // This will be used to encrypt the mnemonic phrase (if any)\n        const mnemonicKey = key.slice(32, 64);\n\n        // Encrypt the private key\n        const counter = new aes.Counter(iv);\n        const aesCtr = new aes.ModeOfOperation.ctr(derivedKey, counter);\n        const ciphertext = arrayify(aesCtr.encrypt(privateKey));\n\n        // Compute the message authentication code, used to check the password\n        const mac = keccak256(concat([macPrefix, ciphertext]))\n\n        // See: https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition\n        const data: { [key: string]: any } = {\n            address: account.address.substring(2).toLowerCase(),\n            id: uuidV4(uuidRandom),\n            version: 3,\n            Crypto: {\n                cipher: \"aes-128-ctr\",\n                cipherparams: {\n                    iv: hexlify(iv).substring(2),\n                },\n                ciphertext: hexlify(ciphertext).substring(2),\n                kdf: \"scrypt\",\n                kdfparams: {\n                    salt: hexlify(salt).substring(2),\n                    n: N,\n                    dklen: 32,\n                    p: p,\n                    r: r\n                },\n                mac: mac.substring(2)\n            }\n        };\n\n        // If we have a mnemonic, encrypt it into the JSON wallet\n        if (entropy) {\n            const mnemonicIv = randomBytes(16);\n            const mnemonicCounter = new aes.Counter(mnemonicIv);\n            const mnemonicAesCtr = new aes.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);\n            const mnemonicCiphertext = arrayify(mnemonicAesCtr.encrypt(entropy));\n            const now = new Date();\n            const timestamp = (now.getUTCFullYear() + \"-\" +\n                               zpad(now.getUTCMonth() + 1, 2) + \"-\" +\n                               zpad(now.getUTCDate(), 2) + \"T\" +\n                               zpad(now.getUTCHours(), 2) + \"-\" +\n                               zpad(now.getUTCMinutes(), 2) + \"-\" +\n                               zpad(now.getUTCSeconds(), 2) + \".0Z\"\n                              );\n            data[\"x-ethers\"] = {\n                client: client,\n                gethFilename: (\"UTC--\" + timestamp + \"--\" + data.address),\n                mnemonicCounter: hexlify(mnemonicIv).substring(2),\n                mnemonicCiphertext: hexlify(mnemonicCiphertext).substring(2),\n                path: path,\n                locale: locale,\n                version: \"0.1\"\n            };\n        }\n\n        return JSON.stringify(data);\n    });\n}\n","\"use strict\";\n\nimport { Bytes } from \"@ethersproject/bytes\";\nimport { ExternallyOwnedAccount } from \"@ethersproject/abstract-signer\";\n\nimport { decrypt as decryptCrowdsale } from \"./crowdsale\";\nimport { getJsonWalletAddress, isCrowdsaleWallet, isKeystoreWallet } from \"./inspect\";\nimport { decrypt as decryptKeystore, decryptSync as decryptKeystoreSync, encrypt as encryptKeystore, EncryptOptions, ProgressCallback } from \"./keystore\";\n\nfunction decryptJsonWallet(json: string, password: Bytes | string, progressCallback?: ProgressCallback): Promise<ExternallyOwnedAccount> {\n    if (isCrowdsaleWallet(json)) {\n        if (progressCallback) { progressCallback(0); }\n        const account = decryptCrowdsale(json, password)\n        if (progressCallback) { progressCallback(1); }\n        return Promise.resolve(account);\n    }\n\n    if (isKeystoreWallet(json)) {\n        return decryptKeystore(json, password, progressCallback);\n    }\n\n    return Promise.reject(new Error(\"invalid JSON wallet\"));\n}\n\nfunction decryptJsonWalletSync(json: string, password: Bytes | string): ExternallyOwnedAccount {\n    if (isCrowdsaleWallet(json)) {\n        return decryptCrowdsale(json, password)\n    }\n\n    if (isKeystoreWallet(json)) {\n        return decryptKeystoreSync(json, password);\n    }\n\n    throw new Error(\"invalid JSON wallet\");\n}\n\nexport {\n    decryptCrowdsale,\n\n    decryptKeystore,\n    decryptKeystoreSync,\n    encryptKeystore,\n\n    isCrowdsaleWallet,\n    isKeystoreWallet,\n    getJsonWalletAddress,\n\n    decryptJsonWallet,\n    decryptJsonWalletSync,\n\n    ProgressCallback,\n    EncryptOptions,\n};\n","export const version = \"wallet/5.5.0\";\n","\"use strict\";\n\nimport { getAddress } from \"@ethersproject/address\";\nimport { Provider, TransactionRequest } from \"@ethersproject/abstract-provider\";\nimport { ExternallyOwnedAccount, Signer, TypedDataDomain, TypedDataField, TypedDataSigner } from \"@ethersproject/abstract-signer\";\nimport { arrayify, Bytes, BytesLike, concat, hexDataSlice, isHexString, joinSignature, SignatureLike } from \"@ethersproject/bytes\";\nimport { hashMessage, _TypedDataEncoder } from \"@ethersproject/hash\";\nimport { defaultPath, HDNode, entropyToMnemonic, Mnemonic } from \"@ethersproject/hdnode\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { defineReadOnly, resolveProperties } from \"@ethersproject/properties\";\nimport { randomBytes } from \"@ethersproject/random\";\nimport { SigningKey } from \"@ethersproject/signing-key\";\nimport { decryptJsonWallet, decryptJsonWalletSync, encryptKeystore, ProgressCallback } from \"@ethersproject/json-wallets\";\nimport { computeAddress, recoverAddress, serialize, UnsignedTransaction } from \"@ethersproject/transactions\";\nimport { Wordlist } from \"@ethersproject/wordlists\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nfunction isAccount(value: any): value is ExternallyOwnedAccount {\n    return (value != null && isHexString(value.privateKey, 32) && value.address != null);\n}\n\nfunction hasMnemonic(value: any): value is { mnemonic: Mnemonic } {\n    const mnemonic = value.mnemonic;\n    return (mnemonic && mnemonic.phrase);\n}\n\nexport class Wallet extends Signer implements ExternallyOwnedAccount, TypedDataSigner {\n\n    readonly address: string;\n    readonly provider: Provider;\n\n    // Wrapping the _signingKey and _mnemonic in a getter function prevents\n    // leaking the private key in console.log; still, be careful! :)\n    readonly _signingKey: () => SigningKey;\n    readonly _mnemonic: () => Mnemonic;\n\n    constructor(privateKey: BytesLike | ExternallyOwnedAccount | SigningKey, provider?: Provider) {\n        logger.checkNew(new.target, Wallet);\n\n        super();\n\n        if (isAccount(privateKey)) {\n            const signingKey = new SigningKey(privateKey.privateKey);\n            defineReadOnly(this, \"_signingKey\", () => signingKey);\n            defineReadOnly(this, \"address\", computeAddress(this.publicKey));\n\n            if (this.address !== getAddress(privateKey.address)) {\n                logger.throwArgumentError(\"privateKey/address mismatch\", \"privateKey\", \"[REDACTED]\");\n            }\n\n            if (hasMnemonic(privateKey)) {\n                const srcMnemonic = privateKey.mnemonic;\n                defineReadOnly(this, \"_mnemonic\", () => (\n                    {\n                        phrase: srcMnemonic.phrase,\n                        path: srcMnemonic.path || defaultPath,\n                        locale: srcMnemonic.locale || \"en\"\n                    }\n                ));\n                const mnemonic = this.mnemonic;\n                const node = HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path);\n                if (computeAddress(node.privateKey) !== this.address) {\n                    logger.throwArgumentError(\"mnemonic/address mismatch\", \"privateKey\", \"[REDACTED]\");\n                }\n            } else {\n                defineReadOnly(this, \"_mnemonic\", (): Mnemonic => null);\n            }\n\n\n        } else {\n            if (SigningKey.isSigningKey(privateKey)) {\n                /* istanbul ignore if */\n                if (privateKey.curve !== \"secp256k1\") {\n                    logger.throwArgumentError(\"unsupported curve; must be secp256k1\", \"privateKey\", \"[REDACTED]\");\n                }\n                defineReadOnly(this, \"_signingKey\", () => (<SigningKey>privateKey));\n\n            } else {\n                // A lot of common tools do not prefix private keys with a 0x (see: #1166)\n                if (typeof(privateKey) === \"string\") {\n                    if (privateKey.match(/^[0-9a-f]*$/i) && privateKey.length === 64) {\n                        privateKey = \"0x\" + privateKey;\n                    }\n                }\n\n                const signingKey = new SigningKey(privateKey);\n                defineReadOnly(this, \"_signingKey\", () => signingKey);\n            }\n\n            defineReadOnly(this, \"_mnemonic\", (): Mnemonic => null);\n            defineReadOnly(this, \"address\", computeAddress(this.publicKey));\n        }\n\n        /* istanbul ignore if */\n        if (provider && !Provider.isProvider(provider)) {\n            logger.throwArgumentError(\"invalid provider\", \"provider\", provider);\n        }\n\n        defineReadOnly(this, \"provider\", provider || null);\n    }\n\n    get mnemonic(): Mnemonic { return this._mnemonic(); }\n    get privateKey(): string { return this._signingKey().privateKey; }\n    get publicKey(): string { return this._signingKey().publicKey; }\n\n    getAddress(): Promise<string> {\n        return Promise.resolve(this.address);\n    }\n\n    connect(provider: Provider): Wallet {\n        return new Wallet(this, provider);\n    }\n\n    signTransaction(transaction: TransactionRequest): Promise<string> {\n        return resolveProperties(transaction).then((tx) => {\n            if (tx.from != null) {\n                if (getAddress(tx.from) !== this.address) {\n                    logger.throwArgumentError(\"transaction from address mismatch\", \"transaction.from\", transaction.from);\n                }\n                delete tx.from;\n            }\n\n            const signature = this._signingKey().signDigest(keccak256(serialize(<UnsignedTransaction>tx)));\n            return serialize(<UnsignedTransaction>tx, signature);\n        });\n    }\n\n    async signMessage(message: Bytes | string): Promise<string> {\n        return joinSignature(this._signingKey().signDigest(hashMessage(message)));\n    }\n\n    async _signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): Promise<string> {\n        // Populate any ENS names\n        const populated = await _TypedDataEncoder.resolveNames(domain, types, value, (name: string) => {\n            if (this.provider == null) {\n                logger.throwError(\"cannot resolve ENS names without a provider\", Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"resolveName\",\n                    value: name\n                });\n            }\n            return this.provider.resolveName(name);\n        });\n\n        return joinSignature(this._signingKey().signDigest(_TypedDataEncoder.hash(populated.domain, types, populated.value)));\n    }\n\n    encrypt(password: Bytes | string, options?: any, progressCallback?: ProgressCallback): Promise<string> {\n        if (typeof(options) === \"function\" && !progressCallback) {\n            progressCallback = options;\n            options = {};\n        }\n\n        if (progressCallback && typeof(progressCallback) !== \"function\") {\n            throw new Error(\"invalid callback\");\n        }\n\n        if (!options) { options = {}; }\n\n        return encryptKeystore(this, password, options, progressCallback);\n    }\n\n\n    /**\n     *  Static methods to create Wallet instances.\n     */\n    static createRandom(options?: any): Wallet {\n        let entropy: Uint8Array = randomBytes(16);\n\n        if (!options) { options = { }; }\n\n        if (options.extraEntropy) {\n            entropy = arrayify(hexDataSlice(keccak256(concat([ entropy, options.extraEntropy ])), 0, 16));\n        }\n\n        const mnemonic = entropyToMnemonic(entropy, options.locale);\n        return Wallet.fromMnemonic(mnemonic, options.path, options.locale);\n    }\n\n    static fromEncryptedJson(json: string, password: Bytes | string, progressCallback?: ProgressCallback): Promise<Wallet> {\n        return decryptJsonWallet(json, password, progressCallback).then((account) => {\n            return new Wallet(account);\n        });\n    }\n\n    static fromEncryptedJsonSync(json: string, password: Bytes | string): Wallet {\n        return new Wallet(decryptJsonWalletSync(json, password));\n    }\n\n    static fromMnemonic(mnemonic: string, path?: string, wordlist?: Wordlist): Wallet {\n        if (!path) { path = defaultPath; }\n        return new Wallet(HDNode.fromMnemonic(mnemonic, null, wordlist).derivePath(path));\n    }\n}\n\nexport function verifyMessage(message: Bytes | string, signature: SignatureLike): string {\n    return recoverAddress(hashMessage(message), signature);\n}\n\nexport function verifyTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>, signature: SignatureLike): string {\n    return recoverAddress(_TypedDataEncoder.hash(domain, types, value), signature);\n}\n","export const AddressZero = \"0x0000000000000000000000000000000000000000\";\n\n","export const HashZero = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\n\n","// NFKC (composed)             // (decomposed)\nexport const EtherSymbol = \"\\u039e\";  // \"\\uD835\\uDF63\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { Network, Networkish } from \"./types\";\n\nexport {\n    Network,\n    Networkish\n};\n\ntype DefaultProviderFunc = (providers: any, options?: any) => any;\n\ninterface Renetworkable extends DefaultProviderFunc {\n    renetwork: (network: Network) => DefaultProviderFunc;\n};\n\nfunction isRenetworkable(value: any): value is Renetworkable {\n    return (value && typeof(value.renetwork) === \"function\");\n}\n\nfunction ethDefaultProvider(network: string | Network): Renetworkable {\n    const func = function(providers: any, options?: any): any {\n        if (options == null) { options = { }; }\n        const providerList: Array<any> = [];\n\n        if (providers.InfuraProvider) {\n            try {\n                providerList.push(new providers.InfuraProvider(network, options.infura));\n            } catch(error) { }\n        }\n\n        if (providers.EtherscanProvider) {\n            try {\n                providerList.push(new providers.EtherscanProvider(network, options.etherscan));\n            } catch(error) { }\n        }\n\n        if (providers.AlchemyProvider) {\n            try {\n                providerList.push(new providers.AlchemyProvider(network, options.alchemy));\n            } catch(error) { }\n        }\n\n        if (providers.PocketProvider) {\n            // These networks are currently faulty on Pocket as their\n            // network does not handle the Berlin hardfork, which is\n            // live on these ones.\n            // @TODO: This goes away once Pocket has upgraded their nodes\n            const skip = [ \"goerli\", \"ropsten\", \"rinkeby\" ];\n            try {\n                const provider = new providers.PocketProvider(network);\n                if (provider.network && skip.indexOf(provider.network.name) === -1) {\n                    providerList.push(provider);\n                }\n            } catch(error) { }\n        }\n\n        if (providers.CloudflareProvider) {\n            try {\n                providerList.push(new providers.CloudflareProvider(network));\n            } catch(error) { }\n        }\n\n        if (providerList.length === 0) { return null; }\n\n        if (providers.FallbackProvider) {\n            let quorum = 1;\n            if (options.quorum != null) {\n                quorum = options.quorum;\n            } else if (network === \"homestead\") {\n                quorum = 2;\n            }\n            return new providers.FallbackProvider(providerList, quorum);\n        }\n\n        return providerList[0];\n    };\n\n    func.renetwork = function(network: Network) {\n        return ethDefaultProvider(network);\n    };\n\n    return func;\n}\n\nfunction etcDefaultProvider(url: string, network: string | Network): Renetworkable {\n    const func = function(providers: any, options?: any): any {\n        if (providers.JsonRpcProvider) {\n            return new providers.JsonRpcProvider(url, network);\n        }\n\n        return null;\n    };\n\n    func.renetwork = function(network: Network) {\n        return etcDefaultProvider(url, network);\n    };\n\n    return func;\n}\n\nconst homestead: Network = {\n    chainId: 1,\n    ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n    name: \"homestead\",\n    _defaultProvider: ethDefaultProvider(\"homestead\")\n};\n\nconst ropsten: Network = {\n    chainId: 3,\n    ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n    name: \"ropsten\",\n    _defaultProvider: ethDefaultProvider(\"ropsten\")\n};\n\nconst classicMordor: Network = {\n    chainId: 63,\n    name: \"classicMordor\",\n    _defaultProvider: etcDefaultProvider(\"https://www.ethercluster.com/mordor\", \"classicMordor\")\n};\n\n// See: https://chainlist.org\nconst networks: { [name: string]: Network } = {\n    unspecified: { chainId: 0, name: \"unspecified\" },\n\n    homestead: homestead,\n    mainnet: homestead,\n\n    morden: { chainId: 2, name: \"morden\" },\n\n    ropsten: ropsten,\n    testnet: ropsten,\n\n    rinkeby: {\n        chainId: 4,\n        ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n        name: \"rinkeby\",\n        _defaultProvider: ethDefaultProvider(\"rinkeby\")\n    },\n\n    kovan: {\n        chainId: 42,\n        name: \"kovan\",\n        _defaultProvider: ethDefaultProvider(\"kovan\")\n    },\n\n    goerli: {\n        chainId: 5,\n        ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n        name: \"goerli\",\n        _defaultProvider: ethDefaultProvider(\"goerli\")\n    },\n\n    kintsugi: { chainId: 1337702, name: \"kintsugi\" },\n\n\n    // ETC (See: #351)\n    classic: {\n        chainId: 61,\n        name: \"classic\",\n        _defaultProvider: etcDefaultProvider(\"https:/\\/www.ethercluster.com/etc\", \"classic\")\n    },\n\n    classicMorden: { chainId: 62, name: \"classicMorden\" },\n\n    classicMordor: classicMordor,\n    classicTestnet: classicMordor,\n\n    classicKotti: {\n        chainId: 6,\n        name: \"classicKotti\",\n        _defaultProvider: etcDefaultProvider(\"https:/\\/www.ethercluster.com/kotti\", \"classicKotti\")\n    },\n\n    xdai: { chainId: 100, name: \"xdai\" },\n\n    matic: { chainId: 137, name: \"matic\" },\n    maticmum: { chainId: 80001, name: \"maticmum\" },\n\n    optimism: { chainId: 10, name: \"optimism\" },\n    \"optimism-kovan\": { chainId: 69, name: \"optimism-kovan\" },\n    \"optimism-goerli\": { chainId: 420, name: \"optimism-goerli\" },\n\n    arbitrum: { chainId: 42161, name: \"arbitrum\" },\n    \"arbitrum-rinkeby\": { chainId: 421611, name: \"arbitrum-rinkeby\" },\n\n    bnb: { chainId: 56, name: \"bnb\" },\n    bnbt: { chainId: 97, name: \"bnbt\" },\n}\n\n/**\n *  getNetwork\n *\n *  Converts a named common networks or chain ID (network ID) to a Network\n *  and verifies a network is a valid Network..\n */\nexport function getNetwork(network: Networkish): Network {\n    // No network (null)\n    if (network == null) { return null; }\n\n    if (typeof(network) === \"number\") {\n        for (const name in networks) {\n            const standard = networks[name];\n            if (standard.chainId === network) {\n                return {\n                    name: standard.name,\n                    chainId: standard.chainId,\n                    ensAddress: (standard.ensAddress || null),\n                    _defaultProvider: (standard._defaultProvider || null)\n                };\n            }\n        }\n\n        return {\n            chainId: network,\n            name: \"unknown\"\n        };\n    }\n\n    if (typeof(network) === \"string\") {\n        const standard = networks[network];\n        if (standard == null) { return null; }\n        return {\n            name: standard.name,\n            chainId: standard.chainId,\n            ensAddress: standard.ensAddress,\n            _defaultProvider: (standard._defaultProvider || null)\n        };\n    }\n\n    const standard  = networks[network.name];\n\n    // Not a standard network; check that it is a valid network in general\n    if (!standard) {\n        if (typeof(network.chainId) !== \"number\") {\n            logger.throwArgumentError(\"invalid network chainId\", \"network\", network);\n        }\n        return network;\n    }\n\n    // Make sure the chainId matches the expected network chainId (or is 0; disable EIP-155)\n    if (network.chainId !== 0 && network.chainId !== standard.chainId) {\n        logger.throwArgumentError(\"network chainId mismatch\", \"network\", network);\n    }\n\n    // @TODO: In the next major version add an attach function to a defaultProvider\n    // class and move the _defaultProvider internal to this file (extend Network)\n    let defaultProvider: DefaultProviderFunc = network._defaultProvider || null;\n    if (defaultProvider == null && standard._defaultProvider) {\n        if (isRenetworkable(standard._defaultProvider)) {\n            defaultProvider = standard._defaultProvider.renetwork(network);\n        } else {\n            defaultProvider = standard._defaultProvider;\n        }\n    }\n\n    // Standard Network (allow overriding the ENS address)\n    return {\n        name: network.name,\n        chainId: standard.chainId,\n        ensAddress: (network.ensAddress || standard.ensAddress || null),\n        _defaultProvider: defaultProvider\n    };\n}\n","export const version = \"networks/5.5.2\";\n","\"use strict\";\n\nimport { toUtf8CodePoints, _toUtf8String, UnicodeNormalizationForm } from \"./utf8\";\n\ntype Ranged = {\n    l: number,          // Lo value\n    h: number,          // High value (less the lo)\n    d?: number,         // Delta/stride (default: 1)\n    s?: number,         // Shift (default: 1)\n    e?: Array<number>   // Exceptions to skip\n};\n\ntype Table = { [ src: number ]: Array<number> };\n\nfunction bytes2(data: string): Array<number> {\n    if ((data.length % 4) !== 0) { throw new Error(\"bad data\"); }\n    let result = [];\n    for (let i = 0; i < data.length; i += 4) {\n        result.push(parseInt(data.substring(i, i + 4), 16));\n    }\n    return result;\n}\n\nfunction createTable(data: string, func?: (value: string) => Array<number>): Table {\n    if (!func) {\n        func = function(value: string) { return [ parseInt(value, 16) ]; }\n    }\n\n    let lo = 0;\n\n    let result: Table = { };\n    data.split(\",\").forEach((pair) => {\n        let comps = pair.split(\":\");\n        lo += parseInt(comps[0], 16);\n        result[lo] = func(comps[1]);\n    });\n\n    return result;\n}\n\nfunction createRangeTable(data: string): Array<Ranged> {\n    let hi = 0;\n    return data.split(\",\").map((v) => {\n        let comps = v.split(\"-\");\n        if (comps.length === 1) {\n            comps[1] = \"0\";\n        } else if (comps[1] === \"\") {\n            comps[1] = \"1\";\n        }\n\n        let lo = hi + parseInt(comps[0], 16);\n        hi = parseInt(comps[1], 16);\n        return { l: lo, h: hi };\n    });\n}\n\nfunction matchMap(value: number, ranges: Array<Ranged>): Ranged {\n    let lo = 0;\n    for (let i = 0; i < ranges.length; i++) {\n        let range = ranges[i];\n        lo += range.l;\n        if (value >= lo && value <= lo + range.h && ((value - lo) % (range.d || 1)) === 0) {\n            if (range.e && range.e.indexOf(value - lo) !== -1) { continue; }\n            return range;\n        }\n    }\n    return null;\n}\n\nconst Table_A_1_ranges = createRangeTable(\"221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d\");\n\n// @TODO: Make this relative...\nconst Table_B_1_flags = \"ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff\".split(\",\").map((v) => parseInt(v, 16));\n\nconst Table_B_2_ranges: Array<Ranged> = [\n    { h: 25, s: 32, l: 65 },\n    { h: 30, s: 32, e: [ 23 ], l: 127 },\n    { h: 54, s: 1, e: [ 48 ], l: 64, d: 2 },\n    { h: 14, s: 1, l: 57, d: 2 },\n    { h: 44, s: 1, l: 17, d: 2 },\n    { h: 10, s: 1, e: [ 2, 6, 8 ], l: 61, d: 2 },\n    { h: 16, s: 1, l: 68, d: 2 },\n    { h: 84, s: 1, e: [ 18, 24, 66 ], l: 19, d: 2 },\n    { h: 26, s: 32, e: [ 17 ], l: 435 },\n    { h: 22, s: 1, l: 71, d: 2 },\n    { h: 15, s: 80, l: 40 },\n    { h: 31, s: 32, l: 16 },\n    { h: 32, s: 1, l: 80, d: 2 },\n    { h: 52, s: 1, l: 42, d: 2 },\n    { h: 12, s: 1, l: 55, d: 2 },\n    { h: 40, s: 1, e: [ 38 ], l: 15, d: 2 },\n    { h: 14, s: 1, l: 48, d: 2 },\n    { h: 37, s: 48, l: 49 },\n    { h: 148, s: 1, l: 6351, d: 2 },\n    { h: 88, s: 1, l: 160, d: 2 },\n    { h: 15, s: 16, l: 704 },\n    { h: 25, s: 26, l: 854 },\n    { h: 25, s: 32, l: 55915 },\n    { h: 37, s: 40, l: 1247 },\n    { h: 25, s: -119711, l: 53248 },\n    { h: 25, s: -119763, l: 52 },\n    { h: 25, s: -119815, l: 52 },\n    { h: 25, s: -119867, e: [ 1, 4, 5, 7, 8, 11, 12, 17 ], l: 52 },\n    { h: 25, s: -119919, l: 52 },\n    { h: 24, s: -119971, e: [ 2, 7, 8, 17 ], l: 52 },\n    { h: 24, s: -120023, e: [ 2, 7, 13, 15, 16, 17 ], l: 52 },\n    { h: 25, s: -120075, l: 52 },\n    { h: 25, s: -120127, l: 52 },\n    { h: 25, s: -120179, l: 52 },\n    { h: 25, s: -120231, l: 52 },\n    { h: 25, s: -120283, l: 52 },\n    { h: 25, s: -120335, l: 52 },\n    { h: 24, s: -119543, e: [ 17 ], l: 56 },\n    { h: 24, s: -119601, e: [ 17 ], l: 58 },\n    { h: 24, s: -119659, e: [ 17 ], l: 58 },\n    { h: 24, s: -119717, e: [ 17 ], l: 58 },\n    { h: 24, s: -119775, e: [ 17 ], l: 58 }\n];\nconst Table_B_2_lut_abs = createTable(\"b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3\");\nconst Table_B_2_lut_rel = createTable(\"179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7\");\nconst Table_B_2_complex = createTable(\"df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D\", bytes2);\n\nconst Table_C_ranges = createRangeTable(\"80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001\");\n\n\nfunction flatten(values: Array<Array<number>>): Array<number> {\n    return values.reduce((accum, value) => {\n        value.forEach((value) => { accum.push(value); });\n        return accum;\n    }, [ ]);\n}\n\nexport function _nameprepTableA1(codepoint: number): boolean {\n    return !!matchMap(codepoint, Table_A_1_ranges);\n}\n\nexport function _nameprepTableB2(codepoint: number): Array<number> {\n    let range = matchMap(codepoint, Table_B_2_ranges);\n    if (range) { return [ codepoint + range.s ]; }\n\n    let codes = Table_B_2_lut_abs[codepoint];\n    if (codes) { return codes; }\n\n    let shift = Table_B_2_lut_rel[codepoint];\n    if (shift) { return [ codepoint + shift[0] ]; }\n\n    let complex = Table_B_2_complex[codepoint];\n    if (complex) { return complex; }\n\n    return null;\n}\n\nexport function _nameprepTableC(codepoint: number): boolean {\n    return !!matchMap(codepoint, Table_C_ranges);\n}\n\nexport function nameprep(value: string): string {\n\n    // This allows platforms with incomplete normalize to bypass\n    // it for very basic names which the built-in toLowerCase\n    // will certainly handle correctly\n    if (value.match(/^[a-z0-9-]*$/i) && value.length <= 59) { return value.toLowerCase(); }\n\n    // Get the code points (keeping the current normalization)\n    let codes = toUtf8CodePoints(value);\n\n    codes = flatten(codes.map((code) => {\n        // Substitute Table B.1 (Maps to Nothing)\n        if (Table_B_1_flags.indexOf(code) >= 0) { return [ ]; }\n        if (code >= 0xfe00 && code <= 0xfe0f) { return [ ]; }\n\n        // Substitute Table B.2 (Case Folding)\n        let codesTableB2 = _nameprepTableB2(code);\n        if (codesTableB2) { return codesTableB2; }\n\n        // No Substitution\n        return [ code ];\n    }));\n\n    // Normalize using form KC\n    codes = toUtf8CodePoints(_toUtf8String(codes), UnicodeNormalizationForm.NFKC);\n\n    // Prohibit Tables C.1.2, C.2.2, C.3, C.4, C.5, C.6, C.7, C.8, C.9\n    codes.forEach((code) => {\n        if (_nameprepTableC(code)) {\n            throw new Error(\"STRINGPREP_CONTAINS_PROHIBITED\");\n        }\n    });\n\n    // Prohibit Unassigned Code Points (Table A.1)\n    codes.forEach((code) => {\n        if (_nameprepTableA1(code)) {\n            throw new Error(\"STRINGPREP_CONTAINS_UNASSIGNED\");\n        }\n    });\n\n    // IDNA extras\n    let name = _toUtf8String(codes);\n\n    // IDNA: 4.2.3.1\n    if (name.substring(0, 1) === \"-\" || name.substring(2, 4) === \"--\" || name.substring(name.length - 1) === \"-\") {\n        throw new Error(\"invalid hyphen\");\n    }\n\n    // IDNA: 4.2.4\n    if (name.length > 63) { throw new Error(\"too long\"); }\n\n\n\n    return name;\n}\n\n","import { concat, hexlify } from \"@ethersproject/bytes\";\nimport { nameprep, toUtf8Bytes } from \"@ethersproject/strings\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst Zeros = new Uint8Array(32);\nZeros.fill(0);\n\nconst Partition = new RegExp(\"^((.*)\\\\.)?([^.]+)$\");\n\nexport function isValidName(name: string): boolean {\n    try {\n        const comps = name.split(\".\");\n        for (let i = 0; i < comps.length; i++) {\n            if (nameprep(comps[i]).length === 0) {\n                throw new Error(\"empty\")\n            }\n        }\n        return true;\n    } catch (error) { }\n    return false;\n}\n\nexport function namehash(name: string): string {\n    /* istanbul ignore if */\n    if (typeof(name) !== \"string\") {\n        logger.throwArgumentError(\"invalid ENS name; not a string\", \"name\", name);\n    }\n\n    let current = name;\n    let result: string | Uint8Array = Zeros;\n    while (current.length) {\n        const partition = current.match(Partition);\n        if (partition == null || partition[2] === \"\") {\n            logger.throwArgumentError(\"invalid ENS address; missing component\", \"name\", name);\n        }\n        const label = toUtf8Bytes(nameprep(partition[3]));\n        result = keccak256(concat([result, keccak256(label)]));\n\n        current = partition[2] || \"\";\n    }\n\n    return hexlify(result);\n}\n\n","\"use strict\";\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nexport function decode(textData: string): Uint8Array {\n    textData = atob(textData);\n    const data = [];\n    for (let i = 0; i < textData.length; i++) {\n        data.push(textData.charCodeAt(i));\n    }\n    return arrayify(data);\n}\n\nexport function encode(data: BytesLike): string {\n    data = arrayify(data);\n    let textData = \"\";\n    for (let i = 0; i < data.length; i++) {\n        textData += String.fromCharCode(data[i]);\n    }\n    return btoa(textData);\n}\n\n\n","export const version = \"web/5.5.1\";\n","\"use strict\";\n\nimport { arrayify } from \"@ethersproject/bytes\";\n\nimport type { GetUrlResponse, Options } from \"./types\";\n\nexport { GetUrlResponse, Options };\n\nexport async function getUrl(href: string, options?: Options): Promise<GetUrlResponse> {\n    if (options == null) { options = { }; }\n\n    const request: RequestInit = {\n        method: (options.method || \"GET\"),\n        headers: (options.headers || { }),\n        body: (options.body || undefined),\n    };\n\n    if (options.skipFetchSetup !== true) {\n        request.mode = <RequestMode>\"cors\";              // no-cors, cors, *same-origin\n        request.cache = <RequestCache>\"no-cache\";        // *default, no-cache, reload, force-cache, only-if-cached\n        request.credentials = <RequestCredentials>\"same-origin\";  // include, *same-origin, omit\n        request.redirect = <RequestRedirect>\"follow\";    // manual, *follow, error\n        request.referrer = \"client\";                     // no-referrer, *client\n    };\n\n    const response = await fetch(href, request);\n    const body = await response.arrayBuffer();\n\n    const headers: { [ name: string ]: string } = { };\n    if (response.headers.forEach) {\n        response.headers.forEach((value, key) => {\n            headers[key.toLowerCase()] = value;\n        });\n    } else {\n        (<() => Array<string>>((<any>(response.headers)).keys))().forEach((key) => {\n            headers[key.toLowerCase()] = response.headers.get(key);\n        });\n    }\n\n    return {\n        headers: headers,\n        statusCode: response.status,\n        statusMessage: response.statusText,\n        body: arrayify(new Uint8Array(body)),\n    }\n}\n","\"use strict\";\n\nimport { decode as base64Decode, encode as base64Encode } from \"@ethersproject/base64\";\nimport { hexlify, isBytesLike } from \"@ethersproject/bytes\";\nimport { shallowCopy } from \"@ethersproject/properties\";\nimport { toUtf8Bytes, toUtf8String } from \"@ethersproject/strings\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { getUrl, GetUrlResponse, Options } from \"./geturl\";\n\nfunction staller(duration: number): Promise<void> {\n    return new Promise((resolve) => {\n        setTimeout(resolve, duration);\n    });\n}\n\nfunction bodyify(value: any, type: string): string {\n    if (value == null) { return null; }\n\n    if (typeof(value) === \"string\") { return value; }\n\n    if (isBytesLike(value)) {\n        if (type && (type.split(\"/\")[0] === \"text\" || type.split(\";\")[0].trim() === \"application/json\")) {\n            try {\n                return toUtf8String(value);\n            } catch (error) { };\n        }\n        return hexlify(value);\n    }\n\n    return value;\n}\n\n// Exported Types\nexport type ConnectionInfo = {\n    url: string,\n    headers?: { [key: string]: string | number }\n\n    user?: string,\n    password?: string,\n\n    allowInsecureAuthentication?: boolean,\n    allowGzip?: boolean,\n\n    throttleLimit?: number,\n    throttleSlotInterval?: number;\n    throttleCallback?: (attempt: number, url: string) => Promise<boolean>,\n\n    timeout?: number,\n};\n\nexport interface OnceBlockable {\n    once(eventName: \"block\", handler: () => void): void;\n}\n\nexport interface OncePollable {\n    once(eventName: \"poll\", handler: () => void): void;\n}\n\nexport type PollOptions = {\n    timeout?: number,\n    floor?: number,\n    ceiling?: number,\n    interval?: number,\n    retryLimit?: number,\n    onceBlock?: OnceBlockable\n    oncePoll?: OncePollable\n};\n\nexport type FetchJsonResponse = {\n    statusCode: number;\n    headers: { [ header: string ]: string };\n};\n\n\ntype Header = { key: string, value: string };\n\n// This API is still a work in progress; the future changes will likely be:\n// - ConnectionInfo => FetchDataRequest<T = any>\n// - FetchDataRequest.body? = string | Uint8Array | { contentType: string, data: string | Uint8Array }\n//   - If string => text/plain, Uint8Array => application/octet-stream (if content-type unspecified)\n// - FetchDataRequest.processFunc = (body: Uint8Array, response: FetchDataResponse) => T\n// For this reason, it should be considered internal until the API is finalized\nexport function _fetchData<T = Uint8Array>(connection: string | ConnectionInfo, body?: Uint8Array, processFunc?: (value: Uint8Array, response: FetchJsonResponse) => T): Promise<T> {\n\n    // How many times to retry in the event of a throttle\n    const attemptLimit = (typeof(connection) === \"object\" && connection.throttleLimit != null) ? connection.throttleLimit: 12;\n    logger.assertArgument((attemptLimit > 0 && (attemptLimit % 1) === 0),\n        \"invalid connection throttle limit\", \"connection.throttleLimit\", attemptLimit);\n\n    const throttleCallback = ((typeof(connection) === \"object\") ? connection.throttleCallback: null);\n    const throttleSlotInterval = ((typeof(connection) === \"object\" && typeof(connection.throttleSlotInterval) === \"number\") ? connection.throttleSlotInterval: 100);\n    logger.assertArgument((throttleSlotInterval > 0 && (throttleSlotInterval % 1) === 0),\n        \"invalid connection throttle slot interval\", \"connection.throttleSlotInterval\", throttleSlotInterval);\n\n    const headers: { [key: string]: Header } = { };\n\n    let url: string = null;\n\n    // @TODO: Allow ConnectionInfo to override some of these values\n    const options: Options = {\n        method: \"GET\",\n    };\n\n    let allow304 = false;\n\n    let timeout = 2 * 60 * 1000;\n\n    if (typeof(connection) === \"string\") {\n        url = connection;\n\n    } else if (typeof(connection) === \"object\") {\n        if (connection == null || connection.url == null) {\n            logger.throwArgumentError(\"missing URL\", \"connection.url\", connection);\n        }\n\n        url = connection.url;\n\n        if (typeof(connection.timeout) === \"number\" && connection.timeout > 0) {\n            timeout = connection.timeout;\n        }\n\n        if (connection.headers) {\n            for (const key in connection.headers) {\n                headers[key.toLowerCase()] = { key: key, value: String(connection.headers[key]) };\n                if ([\"if-none-match\", \"if-modified-since\"].indexOf(key.toLowerCase()) >= 0) {\n                    allow304 = true;\n                }\n            }\n        }\n\n        options.allowGzip = !!connection.allowGzip;\n\n        if (connection.user != null && connection.password != null) {\n            if (url.substring(0, 6) !== \"https:\" && connection.allowInsecureAuthentication !== true) {\n                logger.throwError(\n                    \"basic authentication requires a secure https url\",\n                    Logger.errors.INVALID_ARGUMENT,\n                    { argument: \"url\", url: url, user: connection.user, password: \"[REDACTED]\" }\n                );\n            }\n\n            const authorization = connection.user + \":\" + connection.password;\n            headers[\"authorization\"] = {\n                key: \"Authorization\",\n                value: \"Basic \" + base64Encode(toUtf8Bytes(authorization))\n            };\n        }\n    }\n    const reData = new RegExp(\"^data:([a-z0-9-]+/[a-z0-9-]+);base64,(.*)$\", \"i\");\n    const dataMatch = ((url) ? url.match(reData): null);\n    if (dataMatch) {\n        try {\n            const response = {\n                statusCode: 200,\n                statusMessage: \"OK\",\n                headers: { \"content-type\": dataMatch[1] },\n                body: base64Decode(dataMatch[2])\n            };\n\n            let result: T = <T><unknown>response.body;\n            if (processFunc) {\n                result = processFunc(response.body, response);\n            }\n            return Promise.resolve(<T><unknown>result);\n\n        } catch (error) {\n            logger.throwError(\"processing response error\", Logger.errors.SERVER_ERROR, {\n                body: bodyify(dataMatch[1], dataMatch[2]),\n                error: error,\n                requestBody: null,\n                requestMethod: \"GET\",\n                url: url\n            });\n        }\n    }\n\n    if (body) {\n        options.method = \"POST\";\n        options.body = body;\n        if (headers[\"content-type\"] == null) {\n            headers[\"content-type\"] = { key: \"Content-Type\", value: \"application/octet-stream\" };\n        }\n        if (headers[\"content-length\"] == null) {\n            headers[\"content-length\"] = { key: \"Content-Length\", value: String(body.length) };\n        }\n    }\n\n    const flatHeaders: { [ key: string ]: string } = { };\n    Object.keys(headers).forEach((key) => {\n        const header = headers[key];\n        flatHeaders[header.key] = header.value;\n    });\n    options.headers = flatHeaders;\n\n    const runningTimeout = (function() {\n        let timer: NodeJS.Timer = null;\n        const promise: Promise<never> = new Promise(function(resolve, reject) {\n            if (timeout) {\n                timer = setTimeout(() => {\n                    if (timer == null) { return; }\n                    timer = null;\n\n                    reject(logger.makeError(\"timeout\", Logger.errors.TIMEOUT, {\n                        requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                        requestMethod: options.method,\n                        timeout: timeout,\n                        url: url\n                    }));\n                }, timeout);\n            }\n        });\n\n        const cancel = function() {\n            if (timer == null) { return; }\n            clearTimeout(timer);\n            timer = null;\n        }\n\n        return { promise, cancel };\n    })();\n\n    const runningFetch = (async function() {\n\n        for (let attempt = 0; attempt < attemptLimit; attempt++) {\n            let response: GetUrlResponse = null;\n\n            try {\n                response = await getUrl(url, options);\n\n                if (attempt < attemptLimit) {\n                    if (response.statusCode === 301 || response.statusCode === 302) {\n                        // Redirection; for now we only support absolute locataions\n                        const location = response.headers.location || \"\";\n                        if (options.method === \"GET\" && location.match(/^https:/)) {\n                            url = response.headers.location;\n                            continue;\n                        }\n\n                    } else if (response.statusCode === 429) {\n                        // Exponential back-off throttling\n                        let tryAgain = true;\n                        if (throttleCallback) {\n                            tryAgain = await throttleCallback(attempt, url);\n                        }\n\n                        if (tryAgain) {\n                            let stall = 0;\n\n                            const retryAfter = response.headers[\"retry-after\"];\n                            if (typeof(retryAfter) === \"string\" && retryAfter.match(/^[1-9][0-9]*$/)) {\n                                stall = parseInt(retryAfter) * 1000;\n                            } else {\n                                stall = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));\n                            }\n\n                            //console.log(\"Stalling 429\");\n                            await staller(stall);\n                            continue;\n                        }\n                    }\n                }\n\n            } catch (error) {\n                response = (<any>error).response;\n                if (response == null) {\n                    runningTimeout.cancel();\n                    logger.throwError(\"missing response\", Logger.errors.SERVER_ERROR, {\n                        requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                        requestMethod: options.method,\n                        serverError: error,\n                        url: url\n                    });\n                }\n            }\n\n\n            let body = response.body;\n\n            if (allow304 && response.statusCode === 304) {\n                body = null;\n\n            } else if (response.statusCode < 200 || response.statusCode >= 300) {\n                runningTimeout.cancel();\n                logger.throwError(\"bad response\", Logger.errors.SERVER_ERROR, {\n                    status: response.statusCode,\n                    headers: response.headers,\n                    body: bodyify(body, ((response.headers) ? response.headers[\"content-type\"]: null)),\n                    requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                    requestMethod: options.method,\n                    url: url\n                });\n            }\n\n            if (processFunc) {\n                try {\n                    const result = await processFunc(body, response);\n                    runningTimeout.cancel();\n                    return result;\n\n                } catch (error) {\n                    // Allow the processFunc to trigger a throttle\n                    if (error.throttleRetry && attempt < attemptLimit) {\n                        let tryAgain = true;\n                        if (throttleCallback) {\n                            tryAgain = await throttleCallback(attempt, url);\n                        }\n\n                        if (tryAgain) {\n                            const timeout = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));\n                            //console.log(\"Stalling callback\");\n                            await staller(timeout);\n                            continue;\n                        }\n                    }\n\n                    runningTimeout.cancel();\n                    logger.throwError(\"processing response error\", Logger.errors.SERVER_ERROR, {\n                        body: bodyify(body, ((response.headers) ? response.headers[\"content-type\"]: null)),\n                        error: error,\n                        requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                        requestMethod: options.method,\n                        url: url\n                    });\n                }\n            }\n\n            runningTimeout.cancel();\n\n            // If we had a processFunc, it either returned a T or threw above.\n            // The \"body\" is now a Uint8Array.\n            return <T>(<unknown>body);\n        }\n\n        return logger.throwError(\"failed response\", Logger.errors.SERVER_ERROR, {\n            requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n            requestMethod: options.method,\n            url: url\n        });\n    })();\n\n    return Promise.race([ runningTimeout.promise, runningFetch ]);\n}\n\nexport function fetchJson(connection: string | ConnectionInfo, json?: string, processFunc?: (value: any, response: FetchJsonResponse) => any): Promise<any> {\n    let processJsonFunc = (value: Uint8Array, response: FetchJsonResponse) => {\n        let result: any = null;\n        if (value != null) {\n            try {\n                result = JSON.parse(toUtf8String(value));\n            } catch (error) {\n                logger.throwError(\"invalid JSON\", Logger.errors.SERVER_ERROR, {\n                    body: value,\n                    error: error\n                });\n            }\n        }\n\n        if (processFunc) {\n            result = processFunc(result, response);\n        }\n\n        return result;\n    }\n\n    // If we have json to send, we must\n    // - add content-type of application/json (unless already overridden)\n    // - convert the json to bytes\n    let body: Uint8Array = null;\n    if (json != null) {\n        body = toUtf8Bytes(json);\n\n        // Create a connection with the content-type set for JSON\n        const updated: ConnectionInfo = (typeof(connection) === \"string\") ? ({ url: connection }): shallowCopy(connection);\n        if (updated.headers) {\n            const hasContentType = (Object.keys(updated.headers).filter((k) => (k.toLowerCase() === \"content-type\")).length) !== 0;\n            if (!hasContentType) {\n                updated.headers = shallowCopy(updated.headers);\n                updated.headers[\"content-type\"] = \"application/json\";\n            }\n        } else {\n            updated.headers = { \"content-type\": \"application/json\" };\n        }\n        connection = updated;\n    }\n\n    return _fetchData<any>(connection, body, processJsonFunc);\n}\n\nexport function poll<T>(func: () => Promise<T>, options?: PollOptions): Promise<T> {\n    if (!options) { options = {}; }\n    options = shallowCopy(options);\n    if (options.floor == null) { options.floor = 0; }\n    if (options.ceiling == null) { options.ceiling = 10000; }\n    if (options.interval == null) { options.interval = 250; }\n\n    return new Promise(function(resolve, reject) {\n\n        let timer: NodeJS.Timer = null;\n        let done: boolean = false;\n\n        // Returns true if cancel was successful. Unsuccessful cancel means we're already done.\n        const cancel = (): boolean => {\n            if (done) { return false; }\n            done = true;\n            if (timer) { clearTimeout(timer); }\n            return true;\n        };\n\n        if (options.timeout) {\n            timer = setTimeout(() => {\n                if (cancel()) { reject(new Error(\"timeout\")); }\n            }, options.timeout)\n        }\n\n        const retryLimit = options.retryLimit;\n\n        let attempt = 0;\n        function check() {\n            return func().then(function(result) {\n\n                // If we have a result, or are allowed null then we're done\n                if (result !== undefined) {\n                    if (cancel()) { resolve(result); }\n\n                } else if (options.oncePoll) {\n                    options.oncePoll.once(\"poll\", check);\n\n                } else if (options.onceBlock) {\n                    options.onceBlock.once(\"block\", check);\n\n                // Otherwise, exponential back-off (up to 10s) our next request\n                } else if (!done) {\n                    attempt++;\n                    if (attempt > retryLimit) {\n                        if (cancel()) { reject(new Error(\"retry limit reached\")); }\n                        return;\n                    }\n\n                    let timeout = options.interval * parseInt(String(Math.random() * Math.pow(2, attempt)));\n                    if (timeout < options.floor) { timeout = options.floor; }\n                    if (timeout > options.ceiling) { timeout = options.ceiling; }\n\n                    setTimeout(check, timeout);\n                }\n\n                return null;\n            }, function(error) {\n                if (cancel()) { reject(error); }\n            });\n        }\n        check();\n    });\n}\n\n","export const version = \"providers/5.5.3\";\n","\"use strict\";\n\nimport { Block, TransactionReceipt, TransactionResponse } from \"@ethersproject/abstract-provider\";\nimport { getAddress, getContractAddress } from \"@ethersproject/address\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { hexDataLength, hexDataSlice, hexValue, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { AddressZero } from \"@ethersproject/constants\";\nimport { shallowCopy } from \"@ethersproject/properties\";\nimport { AccessList, accessListify, parse as parseTransaction } from \"@ethersproject/transactions\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport type FormatFunc = (value: any) => any;\n\nexport type FormatFuncs = { [ key: string ]: FormatFunc };\n\nexport type Formats = {\n    transaction: FormatFuncs,\n    transactionRequest: FormatFuncs,\n    receipt: FormatFuncs,\n    receiptLog: FormatFuncs,\n    block: FormatFuncs,\n    blockWithTransactions: FormatFuncs,\n    filter: FormatFuncs,\n    filterLog: FormatFuncs,\n};\n\nexport class Formatter {\n    readonly formats: Formats;\n\n    constructor() {\n        logger.checkNew(new.target, Formatter);\n        this.formats = this.getDefaultFormats();\n    }\n\n    getDefaultFormats(): Formats {\n        const formats: Formats = <Formats>({ });\n\n        const address = this.address.bind(this);\n        const bigNumber = this.bigNumber.bind(this);\n        const blockTag = this.blockTag.bind(this);\n        const data = this.data.bind(this);\n        const hash = this.hash.bind(this);\n        const hex = this.hex.bind(this);\n        const number = this.number.bind(this);\n        const type = this.type.bind(this);\n\n        const strictData = (v: any) => { return this.data(v, true); };\n\n        formats.transaction = {\n            hash: hash,\n\n            type: type,\n            accessList: Formatter.allowNull(this.accessList.bind(this), null),\n\n            blockHash: Formatter.allowNull(hash, null),\n            blockNumber: Formatter.allowNull(number, null),\n            transactionIndex: Formatter.allowNull(number, null),\n\n            confirmations: Formatter.allowNull(number, null),\n\n            from: address,\n\n            // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas)\n            // must be set\n            gasPrice: Formatter.allowNull(bigNumber),\n            maxPriorityFeePerGas: Formatter.allowNull(bigNumber),\n            maxFeePerGas: Formatter.allowNull(bigNumber),\n\n            gasLimit: bigNumber,\n            to: Formatter.allowNull(address, null),\n            value: bigNumber,\n            nonce: number,\n            data: data,\n\n            r: Formatter.allowNull(this.uint256),\n            s: Formatter.allowNull(this.uint256),\n            v: Formatter.allowNull(number),\n\n            creates: Formatter.allowNull(address, null),\n\n            raw: Formatter.allowNull(data),\n        };\n\n        formats.transactionRequest = {\n            from: Formatter.allowNull(address),\n            nonce: Formatter.allowNull(number),\n            gasLimit: Formatter.allowNull(bigNumber),\n            gasPrice: Formatter.allowNull(bigNumber),\n            maxPriorityFeePerGas: Formatter.allowNull(bigNumber),\n            maxFeePerGas: Formatter.allowNull(bigNumber),\n            to: Formatter.allowNull(address),\n            value: Formatter.allowNull(bigNumber),\n            data: Formatter.allowNull(strictData),\n            type: Formatter.allowNull(number),\n            accessList: Formatter.allowNull(this.accessList.bind(this), null),\n        };\n\n        formats.receiptLog = {\n            transactionIndex: number,\n            blockNumber: number,\n            transactionHash: hash,\n            address: address,\n            topics: Formatter.arrayOf(hash),\n            data: data,\n            logIndex: number,\n            blockHash: hash,\n        };\n\n        formats.receipt = {\n            to: Formatter.allowNull(this.address, null),\n            from: Formatter.allowNull(this.address, null),\n            contractAddress: Formatter.allowNull(address, null),\n            transactionIndex: number,\n            // should be allowNull(hash), but broken-EIP-658 support is handled in receipt\n            root: Formatter.allowNull(hex),\n            gasUsed: bigNumber,\n            logsBloom: Formatter.allowNull(data),// @TODO: should this be data?\n            blockHash: hash,\n            transactionHash: hash,\n            logs: Formatter.arrayOf(this.receiptLog.bind(this)),\n            blockNumber: number,\n            confirmations: Formatter.allowNull(number, null),\n            cumulativeGasUsed: bigNumber,\n            effectiveGasPrice: Formatter.allowNull(bigNumber),\n            status: Formatter.allowNull(number),\n            type: type\n        };\n\n        formats.block = {\n            hash: hash,\n            parentHash: hash,\n            number: number,\n\n            timestamp: number,\n            nonce: Formatter.allowNull(hex),\n            difficulty: this.difficulty.bind(this),\n\n            gasLimit: bigNumber,\n            gasUsed: bigNumber,\n\n            miner: address,\n            extraData: data,\n\n            transactions: Formatter.allowNull(Formatter.arrayOf(hash)),\n\n            baseFeePerGas: Formatter.allowNull(bigNumber)\n        };\n\n        formats.blockWithTransactions = shallowCopy(formats.block);\n        formats.blockWithTransactions.transactions = Formatter.allowNull(Formatter.arrayOf(this.transactionResponse.bind(this)));\n\n        formats.filter = {\n            fromBlock: Formatter.allowNull(blockTag, undefined),\n            toBlock: Formatter.allowNull(blockTag, undefined),\n            blockHash: Formatter.allowNull(hash, undefined),\n            address: Formatter.allowNull(address, undefined),\n            topics: Formatter.allowNull(this.topics.bind(this), undefined),\n        };\n\n        formats.filterLog = {\n            blockNumber: Formatter.allowNull(number),\n            blockHash: Formatter.allowNull(hash),\n            transactionIndex: number,\n\n            removed: Formatter.allowNull(this.boolean.bind(this)),\n\n            address: address,\n            data: Formatter.allowFalsish(data, \"0x\"),\n\n            topics: Formatter.arrayOf(hash),\n\n            transactionHash: hash,\n            logIndex: number,\n        };\n\n        return formats;\n    }\n\n    accessList(accessList: Array<any>): AccessList {\n        return accessListify(accessList || []);\n    }\n\n    // Requires a BigNumberish that is within the IEEE754 safe integer range; returns a number\n    // Strict! Used on input.\n    number(number: any): number {\n        if (number === \"0x\") { return 0; }\n        return BigNumber.from(number).toNumber();\n    }\n\n    type(number: any): number {\n        if (number === \"0x\" || number == null) { return 0; }\n        return BigNumber.from(number).toNumber();\n    }\n\n    // Strict! Used on input.\n    bigNumber(value: any): BigNumber {\n        return BigNumber.from(value);\n    }\n\n    // Requires a boolean, \"true\" or  \"false\"; returns a boolean\n    boolean(value: any): boolean {\n        if (typeof(value) === \"boolean\") { return value; }\n        if (typeof(value) === \"string\") {\n            value = value.toLowerCase();\n            if (value === \"true\") { return true; }\n            if (value === \"false\") { return false; }\n        }\n        throw new Error(\"invalid boolean - \" + value);\n    }\n\n    hex(value: any, strict?: boolean): string {\n        if (typeof(value) === \"string\") {\n            if (!strict && value.substring(0, 2) !== \"0x\") { value = \"0x\" + value; }\n            if (isHexString(value)) {\n               return value.toLowerCase();\n            }\n        }\n        return logger.throwArgumentError(\"invalid hash\", \"value\", value);\n    }\n\n    data(value: any, strict?: boolean): string {\n        const result = this.hex(value, strict);\n        if ((result.length % 2) !== 0) {\n            throw new Error(\"invalid data; odd-length - \" + value);\n        }\n        return result;\n    }\n\n    // Requires an address\n    // Strict! Used on input.\n    address(value: any): string {\n        return getAddress(value);\n    }\n\n    callAddress(value: any): string {\n        if (!isHexString(value, 32)) { return null; }\n        const address = getAddress(hexDataSlice(value, 12));\n        return (address === AddressZero) ? null: address;\n    }\n\n    contractAddress(value: any): string {\n        return getContractAddress(value);\n    }\n\n    // Strict! Used on input.\n    blockTag(blockTag: any): string {\n        if (blockTag == null) { return \"latest\"; }\n\n        if (blockTag === \"earliest\") { return \"0x0\"; }\n\n        if (blockTag === \"latest\" || blockTag === \"pending\") {\n            return blockTag;\n        }\n\n        if (typeof(blockTag) === \"number\" || isHexString(blockTag)) {\n            return hexValue(<number | string>blockTag);\n        }\n\n        throw new Error(\"invalid blockTag\");\n    }\n\n    // Requires a hash, optionally requires 0x prefix; returns prefixed lowercase hash.\n    hash(value: any, strict?: boolean): string {\n        const result = this.hex(value, strict);\n        if (hexDataLength(result) !== 32) {\n            return logger.throwArgumentError(\"invalid hash\", \"value\", value);\n        }\n        return result;\n    }\n\n    // Returns the difficulty as a number, or if too large (i.e. PoA network) null\n    difficulty(value: any): number {\n        if (value == null) { return null; }\n\n        const v = BigNumber.from(value);\n\n        try {\n            return v.toNumber();\n        } catch (error) { }\n\n       return null;\n    }\n\n    uint256(value: any): string {\n        if (!isHexString(value)) {\n            throw new Error(\"invalid uint256\");\n        }\n        return hexZeroPad(value, 32);\n    }\n\n    _block(value: any, format: any): Block {\n        if (value.author != null && value.miner == null) {\n            value.miner = value.author;\n        }\n        // The difficulty may need to come from _difficulty in recursed blocks\n        const difficulty = (value._difficulty != null) ? value._difficulty: value.difficulty;\n        const result = Formatter.check(format, value);\n        result._difficulty = ((difficulty == null) ? null: BigNumber.from(difficulty));\n        return result;\n    }\n\n    block(value: any): Block {\n        return this._block(value, this.formats.block);\n    }\n\n    blockWithTransactions(value: any): Block {\n        return this._block(value, this.formats.blockWithTransactions);\n    }\n\n    // Strict! Used on input.\n    transactionRequest(value: any): any {\n        return Formatter.check(this.formats.transactionRequest, value);\n    }\n\n    transactionResponse(transaction: any): TransactionResponse {\n\n        // Rename gas to gasLimit\n        if (transaction.gas != null && transaction.gasLimit == null) {\n            transaction.gasLimit = transaction.gas;\n        }\n\n        // Some clients (TestRPC) do strange things like return 0x0 for the\n        // 0 address; correct this to be a real address\n        if (transaction.to && BigNumber.from(transaction.to).isZero()) {\n            transaction.to = \"0x0000000000000000000000000000000000000000\";\n        }\n\n        // Rename input to data\n        if (transaction.input != null && transaction.data == null) {\n            transaction.data = transaction.input;\n        }\n\n        // If to and creates are empty, populate the creates from the transaction\n        if (transaction.to == null && transaction.creates == null) {\n            transaction.creates = this.contractAddress(transaction);\n        }\n\n        if ((transaction.type === 1 || transaction.type === 2)&& transaction.accessList == null) {\n            transaction.accessList = [ ];\n        }\n\n        const result: TransactionResponse = Formatter.check(this.formats.transaction, transaction);\n\n        if (transaction.chainId != null) {\n            let chainId = transaction.chainId;\n\n            if (isHexString(chainId)) {\n                chainId = BigNumber.from(chainId).toNumber();\n            }\n\n            result.chainId = chainId;\n\n        } else {\n            let chainId = transaction.networkId;\n\n            // geth-etc returns chainId\n            if (chainId == null && result.v == null) {\n                chainId = transaction.chainId;\n            }\n\n            if (isHexString(chainId)) {\n                chainId = BigNumber.from(chainId).toNumber();\n            }\n\n            if (typeof(chainId) !== \"number\" && result.v != null) {\n                chainId = (result.v - 35) / 2;\n                if (chainId < 0) { chainId = 0; }\n                chainId = parseInt(chainId);\n            }\n\n            if (typeof(chainId) !== \"number\") { chainId = 0; }\n\n            result.chainId = chainId;\n        }\n\n        // 0x0000... should actually be null\n        if (result.blockHash && result.blockHash.replace(/0/g, \"\") === \"x\") {\n            result.blockHash = null;\n        }\n\n        return result;\n    }\n\n    transaction(value: any): any {\n        return parseTransaction(value);\n    }\n\n    receiptLog(value: any): any {\n        return Formatter.check(this.formats.receiptLog, value);\n    }\n\n    receipt(value: any): TransactionReceipt {\n        const result: TransactionReceipt = Formatter.check(this.formats.receipt, value);\n\n        // RSK incorrectly implemented EIP-658, so we munge things a bit here for it\n        if (result.root != null) {\n            if (result.root.length <= 4) {\n                // Could be 0x00, 0x0, 0x01 or 0x1\n                const value = BigNumber.from(result.root).toNumber();\n                if (value === 0 || value === 1) {\n                    // Make sure if both are specified, they match\n                    if (result.status != null && (result.status !== value)) {\n                        logger.throwArgumentError(\"alt-root-status/status mismatch\", \"value\", { root: result.root, status: result.status });\n                    }\n                    result.status = value;\n                    delete result.root;\n                } else {\n                    logger.throwArgumentError(\"invalid alt-root-status\", \"value.root\", result.root);\n                }\n            } else if (result.root.length !== 66) {\n                // Must be a valid bytes32\n                logger.throwArgumentError(\"invalid root hash\", \"value.root\", result.root);\n            }\n        }\n\n        if (result.status != null) {\n            result.byzantium = true;\n        }\n\n        return result;\n    }\n\n    topics(value: any): any {\n        if (Array.isArray(value)) {\n            return value.map((v) => this.topics(v));\n\n        } else if (value != null) {\n            return this.hash(value, true);\n        }\n\n        return null;\n    }\n\n    filter(value: any): any {\n        return Formatter.check(this.formats.filter, value);\n    }\n\n    filterLog(value: any): any {\n        return Formatter.check(this.formats.filterLog, value);\n    }\n\n    static check(format: { [ name: string ]: FormatFunc }, object: any): any {\n        const result: any = {};\n        for (const key in format) {\n            try {\n                const value = format[key](object[key]);\n                if (value !== undefined) { result[key] = value; }\n            } catch (error) {\n                error.checkKey = key;\n                error.checkValue = object[key];\n                throw error;\n            }\n        }\n        return result;\n    }\n\n    // if value is null-ish, nullValue is returned\n    static allowNull(format: FormatFunc, nullValue?: any): FormatFunc {\n        return (function(value: any) {\n            if (value == null) { return nullValue; }\n            return format(value);\n        });\n    }\n\n    // If value is false-ish, replaceValue is returned\n    static allowFalsish(format: FormatFunc, replaceValue: any): FormatFunc {\n        return (function(value: any) {\n            if (!value) { return replaceValue; }\n            return format(value);\n        });\n    }\n\n    // Requires an Array satisfying check\n    static arrayOf(format: FormatFunc): FormatFunc {\n        return (function(array: any): Array<any> {\n            if (!Array.isArray(array)) { throw new Error(\"not an array\"); }\n\n            const result: any = [];\n\n            array.forEach(function(value) {\n                result.push(format(value));\n            });\n\n            return result;\n        });\n    }\n}\n\nexport interface CommunityResourcable {\n    isCommunityResource(): boolean;\n}\n\nexport function isCommunityResourcable(value: any): value is CommunityResourcable {\n    return (value && typeof(value.isCommunityResource) === \"function\");\n}\n\nexport function isCommunityResource(value: any): boolean {\n    return (isCommunityResourcable(value) && value.isCommunityResource());\n}\n\n// Show the throttle message only once\nlet throttleMessage = false;\nexport function showThrottleMessage() {\n    if (throttleMessage) { return; }\n    throttleMessage = true;\n\n    console.log(\"========= NOTICE =========\")\n    console.log(\"Request-Rate Exceeded  (this message will not be repeated)\");\n    console.log(\"\");\n    console.log(\"The default API keys for each service are provided as a highly-throttled,\");\n    console.log(\"community resource for low-traffic projects and early prototyping.\");\n    console.log(\"\");\n    console.log(\"While your application will continue to function, we highly recommended\");\n    console.log(\"signing up for your own API keys to improve performance, increase your\");\n    console.log(\"request rate/limit and enable other perks, such as metrics and advanced APIs.\");\n    console.log(\"\");\n    console.log(\"For more details: https:/\\/docs.ethers.io/api-keys/\");\n    console.log(\"==========================\");\n}\n\n","\"use strict\";\n\nimport {\n    Block, BlockTag, BlockWithTransactions, EventType, Filter, FilterByBlockHash, ForkEvent,\n    Listener, Log, Provider, TransactionReceipt, TransactionRequest, TransactionResponse\n} from \"@ethersproject/abstract-provider\";\nimport { Base58 } from \"@ethersproject/basex\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { arrayify, concat, hexConcat, hexDataLength, hexDataSlice, hexlify, hexValue, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { HashZero } from \"@ethersproject/constants\";\nimport { namehash } from \"@ethersproject/hash\";\nimport { getNetwork, Network, Networkish } from \"@ethersproject/networks\";\nimport { Deferrable, defineReadOnly, getStatic, resolveProperties } from \"@ethersproject/properties\";\nimport { Transaction } from \"@ethersproject/transactions\";\nimport { sha256 } from \"@ethersproject/sha2\";\nimport { toUtf8Bytes, toUtf8String } from \"@ethersproject/strings\";\nimport { fetchJson, poll } from \"@ethersproject/web\";\n\nimport bech32 from \"bech32\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { Formatter } from \"./formatter\";\n\n//////////////////////////////\n// Event Serializeing\n\nfunction checkTopic(topic: string): string {\n     if (topic == null) { return \"null\"; }\n     if (hexDataLength(topic) !== 32) {\n         logger.throwArgumentError(\"invalid topic\", \"topic\", topic);\n     }\n     return topic.toLowerCase();\n}\n\nfunction serializeTopics(topics: Array<string | Array<string>>): string {\n    // Remove trailing null AND-topics; they are redundant\n    topics = topics.slice();\n    while (topics.length > 0 && topics[topics.length - 1] == null) { topics.pop(); }\n\n    return topics.map((topic) => {\n        if (Array.isArray(topic)) {\n\n            // Only track unique OR-topics\n            const unique: { [ topic: string ]: boolean } = { }\n            topic.forEach((topic) => {\n                unique[checkTopic(topic)] = true;\n            });\n\n            // The order of OR-topics does not matter\n            const sorted = Object.keys(unique);\n            sorted.sort();\n\n            return sorted.join(\"|\");\n\n        } else {\n            return checkTopic(topic);\n        }\n    }).join(\"&\");\n}\n\nfunction deserializeTopics(data: string): Array<string | Array<string>> {\n    if (data === \"\") { return [ ]; }\n\n    return data.split(/&/g).map((topic) => {\n        if (topic === \"\") { return [ ]; }\n\n        const comps = topic.split(\"|\").map((topic) => {\n            return ((topic === \"null\") ? null: topic);\n        });\n\n        return ((comps.length === 1) ? comps[0]: comps);\n    });\n}\n\nfunction getEventTag(eventName: EventType): string {\n    if (typeof(eventName) === \"string\") {\n        eventName = eventName.toLowerCase();\n\n        if (hexDataLength(eventName) === 32) {\n            return \"tx:\" + eventName;\n        }\n\n        if (eventName.indexOf(\":\") === -1) {\n            return eventName;\n        }\n\n    } else if (Array.isArray(eventName)) {\n        return \"filter:*:\" + serializeTopics(eventName);\n\n    } else if (ForkEvent.isForkEvent(eventName)) {\n        logger.warn(\"not implemented\");\n        throw new Error(\"not implemented\");\n\n    } else if (eventName && typeof(eventName) === \"object\") {\n        return \"filter:\" + (eventName.address || \"*\") + \":\" + serializeTopics(eventName.topics || []);\n    }\n\n    throw new Error(\"invalid event - \" + eventName);\n}\n\n//////////////////////////////\n// Helper Object\n\nfunction getTime() {\n    return (new Date()).getTime();\n}\n\nfunction stall(duration: number): Promise<void> {\n    return new Promise((resolve) => {\n        setTimeout(resolve, duration);\n    });\n}\n\n//////////////////////////////\n// Provider Object\n\n\n/**\n *  EventType\n *   - \"block\"\n *   - \"poll\"\n *   - \"didPoll\"\n *   - \"pending\"\n *   - \"error\"\n *   - \"network\"\n *   - filter\n *   - topics array\n *   - transaction hash\n */\n\nconst PollableEvents = [ \"block\", \"network\", \"pending\", \"poll\" ];\n\nexport class Event {\n    readonly listener: Listener;\n    readonly once: boolean;\n    readonly tag: string;\n\n    constructor(tag: string, listener: Listener, once: boolean) {\n        defineReadOnly(this, \"tag\", tag);\n        defineReadOnly(this, \"listener\", listener);\n        defineReadOnly(this, \"once\", once);\n    }\n\n    get event(): EventType {\n        switch (this.type) {\n            case \"tx\":\n               return this.hash;\n            case \"filter\":\n               return this.filter;\n        }\n        return this.tag;\n    }\n\n    get type(): string {\n        return this.tag.split(\":\")[0]\n    }\n\n    get hash(): string {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== \"tx\") { return null; }\n        return comps[1];\n    }\n\n    get filter(): Filter {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== \"filter\") { return null; }\n        const address = comps[1];\n\n        const topics = deserializeTopics(comps[2]);\n        const filter: Filter = { };\n\n        if (topics.length > 0) { filter.topics = topics; }\n        if (address && address !== \"*\") { filter.address = address; }\n\n        return filter;\n    }\n\n    pollable(): boolean {\n        return (this.tag.indexOf(\":\") >= 0 || PollableEvents.indexOf(this.tag) >= 0);\n    }\n}\n\nexport interface EnsResolver {\n\n    // Name this Resolver is associated with\n    readonly name: string;\n\n    // The address of the resolver\n    readonly address: string;\n\n    // Multichain address resolution (also normal address resolution)\n    // See: https://eips.ethereum.org/EIPS/eip-2304\n    getAddress(coinType?: 60): Promise<null | string>\n\n    // Contenthash field\n    // See: https://eips.ethereum.org/EIPS/eip-1577\n    getContentHash(): Promise<null | string>;\n\n    // Storage of text records\n    // See: https://eips.ethereum.org/EIPS/eip-634\n    getText(key: string): Promise<null | string>;\n};\n\nexport interface EnsProvider {\n    resolveName(name: string): Promise<null | string>;\n    lookupAddress(address: string): Promise<null | string>;\n    getResolver(name: string): Promise<null | EnsResolver>;\n}\n\ntype CoinInfo = {\n    symbol: string,\n    ilk?: string,     // General family\n    prefix?: string,  // Bech32 prefix\n    p2pkh?: number,   // Pay-to-Public-Key-Hash Version\n    p2sh?: number,    // Pay-to-Script-Hash Version\n};\n\n// https://github.com/satoshilabs/slips/blob/master/slip-0044.md\nconst coinInfos: { [ coinType: string ]: CoinInfo } = {\n    \"0\":   { symbol: \"btc\",  p2pkh: 0x00, p2sh: 0x05, prefix: \"bc\" },\n    \"2\":   { symbol: \"ltc\",  p2pkh: 0x30, p2sh: 0x32, prefix: \"ltc\" },\n    \"3\":   { symbol: \"doge\", p2pkh: 0x1e, p2sh: 0x16 },\n    \"60\":  { symbol: \"eth\",  ilk: \"eth\" },\n    \"61\":  { symbol: \"etc\",  ilk: \"eth\" },\n    \"700\": { symbol: \"xdai\", ilk: \"eth\" },\n};\n\nfunction bytes32ify(value: number): string {\n    return hexZeroPad(BigNumber.from(value).toHexString(), 32);\n}\n\n// Compute the Base58Check encoded data (checksum is first 4 bytes of sha256d)\nfunction base58Encode(data: Uint8Array): string {\n    return Base58.encode(concat([ data, hexDataSlice(sha256(sha256(data)), 0, 4) ]));\n}\n\nexport interface Avatar {\n    url: string;\n    linkage: Array<{ type: string, content: string }>;\n}\n\nconst matcherIpfs = new RegExp(\"^(ipfs):/\\/(.*)$\", \"i\");\nconst matchers = [\n    new RegExp(\"^(https):/\\/(.*)$\", \"i\"),\n    new RegExp(\"^(data):(.*)$\", \"i\"),\n    matcherIpfs,\n    new RegExp(\"^eip155:[0-9]+/(erc[0-9]+):(.*)$\", \"i\"),\n];\n\nfunction _parseString(result: string): null | string {\n    try {\n        return toUtf8String(_parseBytes(result));\n    } catch(error) { }\n    return null;\n}\n\nfunction _parseBytes(result: string): null | string {\n    if (result === \"0x\") { return null; }\n\n    const offset = BigNumber.from(hexDataSlice(result, 0, 32)).toNumber();\n    const length = BigNumber.from(hexDataSlice(result, offset, offset + 32)).toNumber();\n    return hexDataSlice(result, offset + 32, offset + 32 + length);\n}\n\n// Trim off the ipfs:// prefix and return the default gateway URL\nfunction getIpfsLink(link: string): string {\n    if (link.match(/^ipfs:\\/\\/ipfs\\//i)) {\n        link = link.substring(12);\n    } else if (link.match(/^ipfs:\\/\\//i)) {\n        link = link.substring(7);\n    } else {\n        logger.throwArgumentError(\"unsupported IPFS format\", \"link\", link);\n    }\n\n    return `https:/\\/gateway.ipfs.io/ipfs/${ link }`;\n}\n\nexport class Resolver implements EnsResolver {\n    readonly provider: BaseProvider;\n\n    readonly name: string;\n    readonly address: string;\n\n    readonly _resolvedAddress: null | string;\n\n    // The resolvedAddress is only for creating a ReverseLookup resolver\n    constructor(provider: BaseProvider, address: string, name: string, resolvedAddress?: string) {\n        defineReadOnly(this, \"provider\", provider);\n        defineReadOnly(this, \"name\", name);\n        defineReadOnly(this, \"address\", provider.formatter.address(address));\n        defineReadOnly(this, \"_resolvedAddress\", resolvedAddress);\n    }\n\n    async _fetchBytes(selector: string, parameters?: string): Promise<null | string> {\n        // e.g. keccak256(\"addr(bytes32,uint256)\")\n        const tx = {\n            to: this.address,\n            data: hexConcat([ selector, namehash(this.name), (parameters || \"0x\") ])\n        };\n\n        try {\n            return _parseBytes(await this.provider.call(tx));\n        } catch (error) {\n            if (error.code === Logger.errors.CALL_EXCEPTION) { return null; }\n            return null;\n        }\n    }\n\n    _getAddress(coinType: number, hexBytes: string): string {\n        const coinInfo = coinInfos[String(coinType)];\n\n        if (coinInfo == null) {\n            logger.throwError(`unsupported coin type: ${ coinType }`, Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: `getAddress(${ coinType })`\n            });\n        }\n\n        if (coinInfo.ilk === \"eth\") {\n            return this.provider.formatter.address(hexBytes);\n        }\n\n        const bytes = arrayify(hexBytes);\n\n        // P2PKH: OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG\n        if (coinInfo.p2pkh != null) {\n            const p2pkh = hexBytes.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);\n            if (p2pkh) {\n                const length = parseInt(p2pkh[1], 16);\n                if (p2pkh[2].length === length * 2 && length >= 1 && length <= 75) {\n                    return base58Encode(concat([ [ coinInfo.p2pkh ], (\"0x\" + p2pkh[2]) ]));\n                }\n            }\n        }\n\n        // P2SH: OP_HASH160 <scriptHash> OP_EQUAL\n        if (coinInfo.p2sh != null) {\n            const p2sh = hexBytes.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);\n            if (p2sh) {\n                const length = parseInt(p2sh[1], 16);\n                if (p2sh[2].length === length * 2 && length >= 1 && length <= 75) {\n                    return base58Encode(concat([ [ coinInfo.p2sh ], (\"0x\" + p2sh[2]) ]));\n                }\n            }\n        }\n\n        // Bech32\n        if (coinInfo.prefix != null) {\n            const length = bytes[1];\n\n            // https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki#witness-program\n            let version = bytes[0];\n            if (version === 0x00) {\n                if (length !== 20 && length !== 32) {\n                    version = -1;\n                }\n            } else {\n                version = -1;\n            }\n\n            if (version >= 0 && bytes.length === 2 + length && length >= 1 && length <= 75) {\n                const words = bech32.toWords(bytes.slice(2));\n                words.unshift(version);\n                return bech32.encode(coinInfo.prefix, words);\n            }\n        }\n\n        return null;\n    }\n\n\n    async getAddress(coinType?: number): Promise<string> {\n        if (coinType == null) { coinType = 60; }\n\n        // If Ethereum, use the standard `addr(bytes32)`\n        if (coinType === 60) {\n            try {\n                // keccak256(\"addr(bytes32)\")\n                const transaction = {\n                    to: this.address,\n                    data: (\"0x3b3b57de\" + namehash(this.name).substring(2))\n                };\n                const hexBytes = await this.provider.call(transaction);\n\n                // No address\n                if (hexBytes === \"0x\" || hexBytes === HashZero) { return null; }\n\n                return this.provider.formatter.callAddress(hexBytes);\n            } catch (error) {\n                if (error.code === Logger.errors.CALL_EXCEPTION) { return null; }\n                throw error;\n            }\n        }\n\n        // keccak256(\"addr(bytes32,uint256\")\n        const hexBytes = await this._fetchBytes(\"0xf1cb7e06\", bytes32ify(coinType));\n\n        // No address\n        if (hexBytes == null || hexBytes === \"0x\") { return null; }\n\n        // Compute the address\n        const address = this._getAddress(coinType, hexBytes);\n\n        if (address == null) {\n            logger.throwError(`invalid or unsupported coin data`, Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: `getAddress(${ coinType })`,\n                coinType: coinType,\n                data: hexBytes\n            });\n        }\n\n        return address;\n    }\n\n    async getAvatar(): Promise<null | Avatar> {\n        const linkage: Array<{ type: string, content: string }> = [ { type: \"name\", content: this.name } ];\n        try {\n            // test data for ricmoo.eth\n            //const avatar = \"eip155:1/erc721:0x265385c7f4132228A0d54EB1A9e7460b91c0cC68/29233\";\n            const avatar = await this.getText(\"avatar\");\n            if (avatar == null) { return null; }\n\n            for (let i = 0; i < matchers.length; i++) {\n                const match = avatar.match(matchers[i]);\n                if (match == null) { continue; }\n\n                const scheme = match[1].toLowerCase();\n\n                switch (scheme) {\n                    case \"https\":\n                        linkage.push({ type: \"url\", content: avatar });\n                        return { linkage, url: avatar };\n\n                    case \"data\":\n                        linkage.push({ type: \"data\", content: avatar });\n                        return { linkage, url: avatar };\n\n                    case \"ipfs\":\n                        linkage.push({ type: \"ipfs\", content: avatar });\n                        return { linkage, url: getIpfsLink(avatar) };\n\n                    case \"erc721\":\n                    case \"erc1155\": {\n                        // Depending on the ERC type, use tokenURI(uint256) or url(uint256)\n                        const selector = (scheme === \"erc721\") ? \"0xc87b56dd\": \"0x0e89341c\";\n                        linkage.push({ type: scheme, content: avatar });\n\n                        // The owner of this name\n                        const owner = (this._resolvedAddress || await this.getAddress());\n\n                        const comps = (match[2] || \"\").split(\"/\");\n                        if (comps.length !== 2) { return null; }\n\n                        const addr = await this.provider.formatter.address(comps[0]);\n                        const tokenId = hexZeroPad(BigNumber.from(comps[1]).toHexString(), 32);\n\n                        // Check that this account owns the token\n                        if (scheme === \"erc721\") {\n                            // ownerOf(uint256 tokenId)\n                            const tokenOwner = this.provider.formatter.callAddress(await this.provider.call({\n                                to: addr, data: hexConcat([ \"0x6352211e\", tokenId ])\n                            }));\n                            if (owner !== tokenOwner) { return null; }\n                            linkage.push({ type: \"owner\", content: tokenOwner });\n\n                        } else if (scheme === \"erc1155\") {\n                            // balanceOf(address owner, uint256 tokenId)\n                            const balance = BigNumber.from(await this.provider.call({\n                                to: addr, data: hexConcat([ \"0x00fdd58e\", hexZeroPad(owner, 32), tokenId ])\n                            }));\n                            if (balance.isZero()) { return null; }\n                            linkage.push({ type: \"balance\", content: balance.toString() });\n                        }\n\n                        // Call the token contract for the metadata URL\n                        const tx = {\n                            to: this.provider.formatter.address(comps[0]),\n                            data: hexConcat([ selector, tokenId ])\n                        };\n\n                        let metadataUrl = _parseString(await this.provider.call(tx))\n                        if (metadataUrl == null) { return null; }\n                        linkage.push({ type: \"metadata-url-base\", content: metadataUrl });\n\n                        // ERC-1155 allows a generic {id} in the URL\n                        if (scheme === \"erc1155\") {\n                            metadataUrl = metadataUrl.replace(\"{id}\", tokenId.substring(2));\n                            linkage.push({ type: \"metadata-url-expanded\", content: metadataUrl });\n                        }\n\n                        // Transform IPFS metadata links\n                        if (metadataUrl.match(/^ipfs:/i)) {\n                            metadataUrl = getIpfsLink(metadataUrl);\n                        }\n\n                        linkage.push({ type: \"metadata-url\", content: metadataUrl });\n\n                        // Get the token metadata\n                        const metadata = await fetchJson(metadataUrl);\n                        if (!metadata) { return null; }\n                        linkage.push({ type: \"metadata\", content: JSON.stringify(metadata) });\n\n                        // Pull the image URL out\n                        let imageUrl = metadata.image;\n                        if (typeof(imageUrl) !== \"string\") { return null; }\n\n                        if (imageUrl.match(/^(https:\\/\\/|data:)/i)) {\n                            // Allow\n                        } else {\n                            // Transform IPFS link to gateway\n                            const ipfs = imageUrl.match(matcherIpfs);\n                            if (ipfs == null) { return null; }\n\n                            linkage.push({ type: \"url-ipfs\", content: imageUrl });\n                            imageUrl = getIpfsLink(imageUrl);\n                        }\n\n                        linkage.push({ type: \"url\", content: imageUrl });\n\n                        return { linkage, url: imageUrl };\n                    }\n                }\n            }\n        } catch (error) { }\n\n        return null;\n    }\n\n    async getContentHash(): Promise<string> {\n\n        // keccak256(\"contenthash()\")\n        const hexBytes = await this._fetchBytes(\"0xbc1c58d1\");\n\n        // No contenthash\n        if (hexBytes == null || hexBytes === \"0x\") { return null; }\n\n        // IPFS (CID: 1, Type: DAG-PB)\n        const ipfs = hexBytes.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);\n        if (ipfs) {\n            const length = parseInt(ipfs[3], 16);\n            if (ipfs[4].length === length * 2) {\n                return \"ipfs:/\\/\" + Base58.encode(\"0x\" + ipfs[1]);\n            }\n        }\n\n        // Swarm (CID: 1, Type: swarm-manifest; hash/length hard-coded to keccak256/32)\n        const swarm = hexBytes.match(/^0xe40101fa011b20([0-9a-f]*)$/)\n        if (swarm) {\n            if (swarm[1].length === (32 * 2)) {\n                return \"bzz:/\\/\" + swarm[1]\n            }\n        }\n\n        return logger.throwError(`invalid or unsupported content hash data`, Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"getContentHash()\",\n            data: hexBytes\n        });\n    }\n\n    async getText(key: string): Promise<string> {\n\n        // The key encoded as parameter to fetchBytes\n        let keyBytes = toUtf8Bytes(key);\n\n        // The nodehash consumes the first slot, so the string pointer targets\n        // offset 64, with the length at offset 64 and data starting at offset 96\n        keyBytes = concat([ bytes32ify(64), bytes32ify(keyBytes.length), keyBytes ]);\n\n        // Pad to word-size (32 bytes)\n        if ((keyBytes.length % 32) !== 0) {\n            keyBytes = concat([ keyBytes, hexZeroPad(\"0x\", 32 - (key.length % 32)) ])\n        }\n\n        const hexBytes = await this._fetchBytes(\"0x59d1d43c\", hexlify(keyBytes));\n        if (hexBytes == null || hexBytes === \"0x\") { return null; }\n\n        return toUtf8String(hexBytes);\n    }\n}\n\nlet defaultFormatter: Formatter = null;\n\nlet nextPollId = 1;\n\nexport class BaseProvider extends Provider implements EnsProvider {\n    _networkPromise: Promise<Network>;\n    _network: Network;\n\n    _events: Array<Event>;\n\n    formatter: Formatter;\n\n    // To help mitigate the eventually consistent nature of the blockchain\n    // we keep a mapping of events we emit. If we emit an event X, we expect\n    // that a user should be able to query for that event in the callback,\n    // if the node returns null, we stall the response until we get back a\n    // meaningful value, since we may be hitting a re-org, or a node that\n    // has not indexed the event yet.\n    // Events:\n    //   - t:{hash}    - Transaction hash\n    //   - b:{hash}    - BlockHash\n    //   - block       - The most recent emitted block\n    _emitted: { [ eventName: string ]: number | \"pending\" };\n\n    _pollingInterval: number;\n    _poller: NodeJS.Timer;\n    _bootstrapPoll: NodeJS.Timer;\n\n    _lastBlockNumber: number;\n\n    _fastBlockNumber: number;\n    _fastBlockNumberPromise: Promise<number>;\n    _fastQueryDate: number;\n\n    _maxInternalBlockNumber: number;\n    _internalBlockNumber: Promise<{ blockNumber: number, reqTime: number, respTime: number }>;\n\n    readonly anyNetwork: boolean;\n\n\n    /**\n     *  ready\n     *\n     *  A Promise<Network> that resolves only once the provider is ready.\n     *\n     *  Sub-classes that call the super with a network without a chainId\n     *  MUST set this. Standard named networks have a known chainId.\n     *\n     */\n\n    constructor(network: Networkish | Promise<Network>) {\n        logger.checkNew(new.target, Provider);\n\n        super();\n\n        // Events being listened to\n        this._events = [];\n\n        this._emitted = { block: -2 };\n\n        this.formatter = new.target.getFormatter();\n\n        // If network is any, this Provider allows the underlying\n        // network to change dynamically, and we auto-detect the\n        // current network\n        defineReadOnly(this, \"anyNetwork\", (network === \"any\"));\n        if (this.anyNetwork) { network = this.detectNetwork(); }\n\n        if (network instanceof Promise) {\n            this._networkPromise = network;\n\n            // Squash any \"unhandled promise\" errors; that do not need to be handled\n            network.catch((error) => { });\n\n            // Trigger initial network setting (async)\n            this._ready().catch((error) => { });\n\n        } else {\n            const knownNetwork = getStatic<(network: Networkish) => Network>(new.target, \"getNetwork\")(network);\n            if (knownNetwork) {\n                defineReadOnly(this, \"_network\", knownNetwork);\n                this.emit(\"network\", knownNetwork, null);\n\n            } else {\n                logger.throwArgumentError(\"invalid network\", \"network\", network);\n            }\n        }\n\n        this._maxInternalBlockNumber = -1024;\n\n        this._lastBlockNumber = -2;\n\n        this._pollingInterval = 4000;\n\n        this._fastQueryDate = 0;\n    }\n\n    async _ready(): Promise<Network> {\n        if (this._network == null) {\n            let network: Network = null;\n            if (this._networkPromise) {\n                try {\n                    network = await this._networkPromise;\n                } catch (error) { }\n            }\n\n            // Try the Provider's network detection (this MUST throw if it cannot)\n            if (network == null) {\n                network = await this.detectNetwork();\n            }\n\n            // This should never happen; every Provider sub-class should have\n            // suggested a network by here (or have thrown).\n            if (!network) {\n                logger.throwError(\"no network detected\", Logger.errors.UNKNOWN_ERROR, { });\n            }\n\n            // Possible this call stacked so do not call defineReadOnly again\n            if (this._network == null) {\n                if (this.anyNetwork) {\n                    this._network = network;\n                } else {\n                    defineReadOnly(this, \"_network\", network);\n                }\n                this.emit(\"network\", network, null);\n            }\n        }\n\n        return this._network;\n    }\n\n    // This will always return the most recently established network.\n    // For \"any\", this can change (a \"network\" event is emitted before\n    // any change is reflected); otherwise this cannot change\n    get ready(): Promise<Network> {\n        return poll(() => {\n            return this._ready().then((network) => {\n                return network;\n            }, (error) => {\n                // If the network isn't running yet, we will wait\n                if (error.code === Logger.errors.NETWORK_ERROR && error.event === \"noNetwork\") {\n                    return undefined;\n                }\n                throw error;\n            });\n        });\n    }\n\n    // @TODO: Remove this and just create a singleton formatter\n    static getFormatter(): Formatter {\n        if (defaultFormatter == null) {\n            defaultFormatter = new Formatter();\n        }\n        return defaultFormatter;\n    }\n\n    // @TODO: Remove this and just use getNetwork\n    static getNetwork(network: Networkish): Network {\n        return getNetwork((network == null) ? \"homestead\": network);\n    }\n\n    // Fetches the blockNumber, but will reuse any result that is less\n    // than maxAge old or has been requested since the last request\n    async _getInternalBlockNumber(maxAge: number): Promise<number> {\n        await this._ready();\n\n        // Allowing stale data up to maxAge old\n        if (maxAge > 0) {\n\n            // While there are pending internal block requests...\n            while (this._internalBlockNumber) {\n\n                // ...\"remember\" which fetch we started with\n                const internalBlockNumber = this._internalBlockNumber;\n\n                try {\n                    // Check the result is not too stale\n                    const result = await internalBlockNumber;\n                    if ((getTime() - result.respTime) <= maxAge) {\n                        return result.blockNumber;\n                    }\n\n                    // Too old; fetch a new value\n                    break;\n\n                } catch(error) {\n\n                    // The fetch rejected; if we are the first to get the\n                    // rejection, drop through so we replace it with a new\n                    // fetch; all others blocked will then get that fetch\n                    // which won't match the one they \"remembered\" and loop\n                    if (this._internalBlockNumber === internalBlockNumber) {\n                        break;\n                    }\n                }\n            }\n        }\n\n        const reqTime = getTime();\n\n        const checkInternalBlockNumber = resolveProperties({\n            blockNumber: this.perform(\"getBlockNumber\", { }),\n            networkError: this.getNetwork().then((network) => (null), (error) => (error))\n        }).then(({ blockNumber, networkError }) => {\n            if (networkError) {\n                // Unremember this bad internal block number\n                if (this._internalBlockNumber === checkInternalBlockNumber) {\n                    this._internalBlockNumber = null;\n                }\n                throw networkError;\n            }\n\n            const respTime = getTime();\n\n            blockNumber = BigNumber.from(blockNumber).toNumber();\n            if (blockNumber < this._maxInternalBlockNumber) { blockNumber = this._maxInternalBlockNumber; }\n\n            this._maxInternalBlockNumber = blockNumber;\n            this._setFastBlockNumber(blockNumber); // @TODO: Still need this?\n            return { blockNumber, reqTime, respTime };\n        });\n\n        this._internalBlockNumber = checkInternalBlockNumber;\n\n        // Swallow unhandled exceptions; if needed they are handled else where\n        checkInternalBlockNumber.catch((error) => {\n            // Don't null the dead (rejected) fetch, if it has already been updated\n            if (this._internalBlockNumber === checkInternalBlockNumber) {\n                this._internalBlockNumber = null;\n            }\n        });\n\n        return (await checkInternalBlockNumber).blockNumber;\n    }\n\n    async poll(): Promise<void> {\n        const pollId = nextPollId++;\n\n        // Track all running promises, so we can trigger a post-poll once they are complete\n        const runners: Array<Promise<void>> = [];\n\n        let blockNumber: number = null;\n        try {\n            blockNumber = await this._getInternalBlockNumber(100 + this.pollingInterval / 2);\n        } catch (error) {\n            this.emit(\"error\", error);\n            return;\n        }\n        this._setFastBlockNumber(blockNumber);\n\n        // Emit a poll event after we have the latest (fast) block number\n        this.emit(\"poll\", pollId, blockNumber);\n\n        // If the block has not changed, meh.\n        if (blockNumber === this._lastBlockNumber) {\n            this.emit(\"didPoll\", pollId);\n            return;\n        }\n\n        // First polling cycle, trigger a \"block\" events\n        if (this._emitted.block === -2) {\n            this._emitted.block = blockNumber - 1;\n        }\n\n        if (Math.abs((<number>(this._emitted.block)) - blockNumber) > 1000) {\n            logger.warn(`network block skew detected; skipping block events (emitted=${ this._emitted.block } blockNumber${ blockNumber })`);\n            this.emit(\"error\", logger.makeError(\"network block skew detected\", Logger.errors.NETWORK_ERROR, {\n                blockNumber: blockNumber,\n                event: \"blockSkew\",\n                previousBlockNumber: this._emitted.block\n            }));\n            this.emit(\"block\", blockNumber);\n\n        } else {\n            // Notify all listener for each block that has passed\n            for (let i = (<number>this._emitted.block) + 1; i <= blockNumber; i++) {\n                this.emit(\"block\", i);\n            }\n        }\n\n        // The emitted block was updated, check for obsolete events\n        if ((<number>this._emitted.block) !== blockNumber) {\n            this._emitted.block = blockNumber;\n\n            Object.keys(this._emitted).forEach((key) => {\n                // The block event does not expire\n                if (key === \"block\") { return; }\n\n                // The block we were at when we emitted this event\n                const eventBlockNumber = this._emitted[key];\n\n                // We cannot garbage collect pending transactions or blocks here\n                // They should be garbage collected by the Provider when setting\n                // \"pending\" events\n                if (eventBlockNumber === \"pending\") { return; }\n\n                // Evict any transaction hashes or block hashes over 12 blocks\n                // old, since they should not return null anyways\n                if (blockNumber - eventBlockNumber > 12) {\n                    delete this._emitted[key];\n                }\n            });\n        }\n\n        // First polling cycle\n        if (this._lastBlockNumber === -2) {\n            this._lastBlockNumber = blockNumber - 1;\n        }\n\n        // Find all transaction hashes we are waiting on\n        this._events.forEach((event) => {\n            switch (event.type) {\n                case \"tx\": {\n                    const hash = event.hash;\n                    let runner = this.getTransactionReceipt(hash).then((receipt) => {\n                        if (!receipt || receipt.blockNumber == null) { return null; }\n                        this._emitted[\"t:\" + hash] = receipt.blockNumber;\n                        this.emit(hash, receipt);\n                        return null;\n                    }).catch((error: Error) => { this.emit(\"error\", error); });\n\n                    runners.push(runner);\n\n                    break;\n                }\n\n                case \"filter\": {\n                    const filter = event.filter;\n                    filter.fromBlock = this._lastBlockNumber + 1;\n                    filter.toBlock = blockNumber;\n\n                    const runner = this.getLogs(filter).then((logs) => {\n                        if (logs.length === 0) { return; }\n                        logs.forEach((log: Log) => {\n                            this._emitted[\"b:\" + log.blockHash] = log.blockNumber;\n                            this._emitted[\"t:\" + log.transactionHash] = log.blockNumber;\n                            this.emit(filter, log);\n                        });\n                    }).catch((error: Error) => { this.emit(\"error\", error); });\n                    runners.push(runner);\n\n                    break;\n                }\n            }\n        });\n\n        this._lastBlockNumber = blockNumber;\n\n        // Once all events for this loop have been processed, emit \"didPoll\"\n        Promise.all(runners).then(() => {\n            this.emit(\"didPoll\", pollId);\n        }).catch((error) => { this.emit(\"error\", error); });\n\n        return;\n    }\n\n    // Deprecated; do not use this\n    resetEventsBlock(blockNumber: number): void {\n        this._lastBlockNumber = blockNumber - 1;\n        if (this.polling) { this.poll(); }\n    }\n\n    get network(): Network {\n        return this._network;\n    }\n\n    // This method should query the network if the underlying network\n    // can change, such as when connected to a JSON-RPC backend\n    async detectNetwork(): Promise<Network> {\n        return logger.throwError(\"provider does not support network detection\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"provider.detectNetwork\"\n        });\n    }\n\n    async getNetwork(): Promise<Network> {\n        const network = await this._ready();\n\n        // Make sure we are still connected to the same network; this is\n        // only an external call for backends which can have the underlying\n        // network change spontaneously\n        const currentNetwork = await this.detectNetwork();\n        if (network.chainId !== currentNetwork.chainId) {\n\n            // We are allowing network changes, things can get complex fast;\n            // make sure you know what you are doing if you use \"any\"\n            if (this.anyNetwork) {\n                this._network = currentNetwork;\n\n                // Reset all internal block number guards and caches\n                this._lastBlockNumber = -2;\n                this._fastBlockNumber = null;\n                this._fastBlockNumberPromise = null;\n                this._fastQueryDate = 0;\n                this._emitted.block = -2;\n                this._maxInternalBlockNumber = -1024;\n                this._internalBlockNumber = null;\n\n                // The \"network\" event MUST happen before this method resolves\n                // so any events have a chance to unregister, so we stall an\n                // additional event loop before returning from /this/ call\n                this.emit(\"network\", currentNetwork, network);\n                await stall(0);\n\n                return this._network;\n            }\n\n            const error = logger.makeError(\"underlying network changed\", Logger.errors.NETWORK_ERROR, {\n                event: \"changed\",\n                network: network,\n                detectedNetwork: currentNetwork\n            });\n\n            this.emit(\"error\", error);\n            throw error;\n        }\n\n        return network;\n    }\n\n    get blockNumber(): number {\n        this._getInternalBlockNumber(100 + this.pollingInterval / 2).then((blockNumber) => {\n            this._setFastBlockNumber(blockNumber);\n        }, (error) => { });\n\n        return (this._fastBlockNumber != null) ? this._fastBlockNumber: -1;\n    }\n\n    get polling(): boolean {\n        return (this._poller != null);\n    }\n\n    set polling(value: boolean) {\n        if (value && !this._poller) {\n            this._poller = setInterval(() => { this.poll(); }, this.pollingInterval);\n\n            if (!this._bootstrapPoll) {\n                this._bootstrapPoll = setTimeout(() => {\n                    this.poll();\n\n                    // We block additional polls until the polling interval\n                    // is done, to prevent overwhelming the poll function\n                    this._bootstrapPoll = setTimeout(() => {\n                        // If polling was disabled, something may require a poke\n                        // since starting the bootstrap poll and it was disabled\n                        if (!this._poller) { this.poll(); }\n\n                        // Clear out the bootstrap so we can do another\n                        this._bootstrapPoll = null;\n                    }, this.pollingInterval);\n                }, 0);\n            }\n\n        } else if (!value && this._poller) {\n            clearInterval(this._poller);\n            this._poller = null;\n        }\n    }\n\n    get pollingInterval(): number {\n        return this._pollingInterval;\n    }\n\n    set pollingInterval(value: number) {\n        if (typeof(value) !== \"number\" || value <= 0 || parseInt(String(value)) != value) {\n            throw new Error(\"invalid polling interval\");\n        }\n\n        this._pollingInterval = value;\n\n        if (this._poller) {\n            clearInterval(this._poller);\n            this._poller = setInterval(() => { this.poll(); }, this._pollingInterval);\n        }\n    }\n\n    _getFastBlockNumber(): Promise<number> {\n        const now = getTime();\n\n        // Stale block number, request a newer value\n        if ((now - this._fastQueryDate) > 2 * this._pollingInterval) {\n            this._fastQueryDate = now;\n            this._fastBlockNumberPromise = this.getBlockNumber().then((blockNumber) => {\n                if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {\n                    this._fastBlockNumber = blockNumber;\n                }\n                return this._fastBlockNumber;\n            });\n        }\n\n        return this._fastBlockNumberPromise;\n    }\n\n    _setFastBlockNumber(blockNumber: number): void {\n        // Older block, maybe a stale request\n        if (this._fastBlockNumber != null && blockNumber < this._fastBlockNumber) { return; }\n\n        // Update the time we updated the blocknumber\n        this._fastQueryDate = getTime();\n\n        // Newer block number, use  it\n        if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {\n            this._fastBlockNumber = blockNumber;\n            this._fastBlockNumberPromise = Promise.resolve(blockNumber);\n        }\n    }\n\n    async waitForTransaction(transactionHash: string, confirmations?: number, timeout?: number): Promise<TransactionReceipt> {\n        return this._waitForTransaction(transactionHash, (confirmations == null) ? 1: confirmations, timeout || 0, null);\n    }\n\n    async _waitForTransaction(transactionHash: string, confirmations: number, timeout: number, replaceable: { data: string, from: string, nonce: number, to: string, value: BigNumber, startBlock: number }): Promise<TransactionReceipt> {\n        const receipt = await this.getTransactionReceipt(transactionHash);\n\n        // Receipt is already good\n        if ((receipt ? receipt.confirmations: 0) >= confirmations) { return receipt; }\n\n        // Poll until the receipt is good...\n        return new Promise((resolve, reject) => {\n            const cancelFuncs: Array<() => void> = [];\n\n            let done = false;\n            const alreadyDone = function() {\n                if (done) { return true; }\n                done = true;\n                cancelFuncs.forEach((func) => { func(); });\n                return false;\n            };\n\n            const minedHandler = (receipt: TransactionReceipt) => {\n                if (receipt.confirmations < confirmations) { return; }\n                if (alreadyDone()) { return; }\n                resolve(receipt);\n            }\n            this.on(transactionHash, minedHandler);\n            cancelFuncs.push(() => { this.removeListener(transactionHash, minedHandler); });\n\n            if (replaceable) {\n                let lastBlockNumber = replaceable.startBlock;\n                let scannedBlock: number = null;\n                const replaceHandler = async (blockNumber: number) => {\n                    if (done) { return; }\n\n                    // Wait 1 second; this is only used in the case of a fault, so\n                    // we will trade off a little bit of latency for more consistent\n                    // results and fewer JSON-RPC calls\n                    await stall(1000);\n\n                    this.getTransactionCount(replaceable.from).then(async (nonce) => {\n                        if (done) { return; }\n\n                        if (nonce <= replaceable.nonce) {\n                            lastBlockNumber = blockNumber;\n\n                        } else {\n                            // First check if the transaction was mined\n                            {\n                                const mined = await this.getTransaction(transactionHash);\n                                if (mined && mined.blockNumber != null) { return; }\n                            }\n\n                            // First time scanning. We start a little earlier for some\n                            // wiggle room here to handle the eventually consistent nature\n                            // of blockchain (e.g. the getTransactionCount was for a\n                            // different block)\n                            if (scannedBlock == null) {\n                                scannedBlock = lastBlockNumber - 3;\n                                if (scannedBlock < replaceable.startBlock) {\n                                    scannedBlock = replaceable.startBlock;\n                                }\n                            }\n\n                            while (scannedBlock <= blockNumber) {\n                                if (done) { return; }\n\n                                const block = await this.getBlockWithTransactions(scannedBlock);\n                                for (let ti = 0; ti < block.transactions.length; ti++) {\n                                    const tx = block.transactions[ti];\n\n                                    // Successfully mined!\n                                    if (tx.hash === transactionHash) { return; }\n\n                                    // Matches our transaction from and nonce; its a replacement\n                                    if (tx.from === replaceable.from && tx.nonce === replaceable.nonce) {\n                                        if (done) { return; }\n\n                                        // Get the receipt of the replacement\n                                        const receipt = await this.waitForTransaction(tx.hash, confirmations);\n\n                                        // Already resolved or rejected (prolly a timeout)\n                                        if (alreadyDone()) { return; }\n\n                                        // The reason we were replaced\n                                        let reason = \"replaced\";\n                                        if (tx.data === replaceable.data && tx.to === replaceable.to && tx.value.eq(replaceable.value)) {\n                                            reason = \"repriced\";\n                                        } else  if (tx.data === \"0x\" && tx.from === tx.to && tx.value.isZero()) {\n                                            reason = \"cancelled\"\n                                        }\n\n                                        // Explain why we were replaced\n                                        reject(logger.makeError(\"transaction was replaced\", Logger.errors.TRANSACTION_REPLACED, {\n                                            cancelled: (reason === \"replaced\" || reason === \"cancelled\"),\n                                            reason,\n                                            replacement: this._wrapTransaction(tx),\n                                            hash: transactionHash,\n                                            receipt\n                                        }));\n\n                                        return;\n                                    }\n                                }\n                                scannedBlock++;\n                            }\n                        }\n\n                        if (done) { return; }\n                        this.once(\"block\", replaceHandler);\n\n                    }, (error) => {\n                        if (done) { return; }\n                        this.once(\"block\", replaceHandler);\n                    });\n                };\n\n                if (done) { return; }\n                this.once(\"block\", replaceHandler);\n\n                cancelFuncs.push(() => {\n                    this.removeListener(\"block\", replaceHandler);\n                });\n            }\n\n            if (typeof(timeout) === \"number\" && timeout > 0) {\n                const timer = setTimeout(() => {\n                    if (alreadyDone()) { return; }\n                    reject(logger.makeError(\"timeout exceeded\", Logger.errors.TIMEOUT, { timeout: timeout }));\n                }, timeout);\n                if (timer.unref) { timer.unref(); }\n\n                cancelFuncs.push(() => { clearTimeout(timer); });\n            }\n        });\n    }\n\n    async getBlockNumber(): Promise<number> {\n        return this._getInternalBlockNumber(0);\n    }\n\n    async getGasPrice(): Promise<BigNumber> {\n        await this.getNetwork();\n\n        const result = await this.perform(\"getGasPrice\", { });\n        try {\n            return BigNumber.from(result);\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"getGasPrice\",\n                result, error\n            });\n        }\n    }\n\n    async getBalance(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<BigNumber> {\n        await this.getNetwork();\n        const params = await resolveProperties({\n            address: this._getAddress(addressOrName),\n            blockTag: this._getBlockTag(blockTag)\n        });\n\n        const result = await this.perform(\"getBalance\", params);\n        try {\n            return BigNumber.from(result);\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"getBalance\",\n                params, result, error\n            });\n        }\n    }\n\n    async getTransactionCount(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<number> {\n        await this.getNetwork();\n        const params = await resolveProperties({\n            address: this._getAddress(addressOrName),\n            blockTag: this._getBlockTag(blockTag)\n        });\n\n        const result = await this.perform(\"getTransactionCount\", params);\n        try {\n            return BigNumber.from(result).toNumber();\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"getTransactionCount\",\n                params, result, error\n            });\n        }\n    }\n\n    async getCode(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string> {\n        await this.getNetwork();\n        const params = await resolveProperties({\n            address: this._getAddress(addressOrName),\n            blockTag: this._getBlockTag(blockTag)\n        });\n\n        const result = await this.perform(\"getCode\", params);\n        try {\n            return hexlify(result);\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"getCode\",\n                params, result, error\n            });\n        }\n    }\n\n    async getStorageAt(addressOrName: string | Promise<string>, position: BigNumberish | Promise<BigNumberish>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string> {\n        await this.getNetwork();\n        const params = await resolveProperties({\n            address: this._getAddress(addressOrName),\n            blockTag: this._getBlockTag(blockTag),\n            position: Promise.resolve(position).then((p) => hexValue(p))\n        });\n        const result = await this.perform(\"getStorageAt\", params);\n        try {\n            return hexlify(result);\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"getStorageAt\",\n                params, result, error\n            });\n        }\n    }\n\n    // This should be called by any subclass wrapping a TransactionResponse\n    _wrapTransaction(tx: Transaction, hash?: string, startBlock?: number): TransactionResponse {\n        if (hash != null && hexDataLength(hash) !== 32) { throw new Error(\"invalid response - sendTransaction\"); }\n\n        const result = <TransactionResponse>tx;\n\n        // Check the hash we expect is the same as the hash the server reported\n        if (hash != null && tx.hash !== hash) {\n            logger.throwError(\"Transaction hash mismatch from Provider.sendTransaction.\", Logger.errors.UNKNOWN_ERROR, { expectedHash: tx.hash, returnedHash: hash });\n        }\n\n        result.wait = async (confirms?: number, timeout?: number) => {\n            if (confirms == null) { confirms = 1; }\n            if (timeout == null) { timeout = 0; }\n\n            // Get the details to detect replacement\n            let replacement = undefined;\n            if (confirms !== 0 && startBlock != null) {\n                replacement = {\n                    data: tx.data,\n                    from: tx.from,\n                    nonce: tx.nonce,\n                    to: tx.to,\n                    value: tx.value,\n                    startBlock\n                };\n            }\n\n            const receipt = await this._waitForTransaction(tx.hash, confirms, timeout, replacement);\n            if (receipt == null && confirms === 0) { return null; }\n\n            // No longer pending, allow the polling loop to garbage collect this\n            this._emitted[\"t:\" + tx.hash] = receipt.blockNumber;\n\n            if (receipt.status === 0) {\n                logger.throwError(\"transaction failed\", Logger.errors.CALL_EXCEPTION, {\n                    transactionHash: tx.hash,\n                    transaction: tx,\n                    receipt: receipt\n                });\n            }\n            return receipt;\n        };\n\n        return result;\n    }\n\n    async sendTransaction(signedTransaction: string | Promise<string>): Promise<TransactionResponse> {\n        await this.getNetwork();\n        const hexTx = await Promise.resolve(signedTransaction).then(t => hexlify(t));\n        const tx = this.formatter.transaction(signedTransaction);\n        if (tx.confirmations == null) { tx.confirmations = 0; }\n        const blockNumber = await this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n        try {\n            const hash = await this.perform(\"sendTransaction\", { signedTransaction: hexTx });\n            return this._wrapTransaction(tx, hash, blockNumber);\n        } catch (error) {\n            (<any>error).transaction = tx;\n            (<any>error).transactionHash = tx.hash;\n            throw error;\n        }\n    }\n\n    async _getTransactionRequest(transaction: Deferrable<TransactionRequest>): Promise<Transaction> {\n        const values: any = await transaction;\n\n        const tx: any = { };\n\n        [\"from\", \"to\"].forEach((key) => {\n            if (values[key] == null) { return; }\n            tx[key] = Promise.resolve(values[key]).then((v) => (v ? this._getAddress(v): null))\n        });\n\n        [\"gasLimit\", \"gasPrice\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"value\"].forEach((key) => {\n            if (values[key] == null) { return; }\n            tx[key] = Promise.resolve(values[key]).then((v) => (v ? BigNumber.from(v): null));\n        });\n\n        [\"type\"].forEach((key) => {\n            if (values[key] == null) { return; }\n            tx[key] = Promise.resolve(values[key]).then((v) => ((v != null) ? v: null));\n        });\n\n        if (values.accessList) {\n            tx.accessList = this.formatter.accessList(values.accessList);\n        }\n\n        [\"data\"].forEach((key) => {\n            if (values[key] == null) { return; }\n            tx[key] = Promise.resolve(values[key]).then((v) => (v ? hexlify(v): null));\n        });\n\n        return this.formatter.transactionRequest(await resolveProperties(tx));\n    }\n\n    async _getFilter(filter: Filter | FilterByBlockHash | Promise<Filter | FilterByBlockHash>): Promise<Filter | FilterByBlockHash> {\n        filter = await filter;\n\n        const result: any = { };\n\n        if (filter.address != null) {\n            result.address = this._getAddress(filter.address);\n        }\n\n        [\"blockHash\", \"topics\"].forEach((key) => {\n            if ((<any>filter)[key] == null) { return; }\n            result[key] = (<any>filter)[key];\n        });\n\n        [\"fromBlock\", \"toBlock\"].forEach((key) => {\n            if ((<any>filter)[key] == null) { return; }\n            result[key] = this._getBlockTag((<any>filter)[key]);\n        });\n\n        return this.formatter.filter(await resolveProperties(result));\n    }\n\n    async call(transaction: Deferrable<TransactionRequest>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string> {\n        await this.getNetwork();\n        const params = await resolveProperties({\n            transaction: this._getTransactionRequest(transaction),\n            blockTag: this._getBlockTag(blockTag)\n        });\n\n        const result = await this.perform(\"call\", params);\n        try {\n            return hexlify(result);\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"call\",\n                params, result, error\n            });\n        }\n    }\n\n    async estimateGas(transaction: Deferrable<TransactionRequest>): Promise<BigNumber> {\n        await this.getNetwork();\n        const params = await resolveProperties({\n            transaction: this._getTransactionRequest(transaction)\n        });\n\n        const result = await this.perform(\"estimateGas\", params);\n        try {\n            return BigNumber.from(result);\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"estimateGas\",\n                params, result, error\n            });\n        }\n    }\n\n    async _getAddress(addressOrName: string | Promise<string>): Promise<string> {\n        addressOrName = await addressOrName;\n        if (typeof(addressOrName) !== \"string\") {\n            logger.throwArgumentError(\"invalid address or ENS name\", \"name\", addressOrName);\n        }\n\n        const address = await this.resolveName(addressOrName);\n        if (address == null) {\n            logger.throwError(\"ENS name not configured\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: `resolveName(${ JSON.stringify(addressOrName) })`\n            });\n        }\n        return address;\n    }\n\n    async _getBlock(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>, includeTransactions?: boolean): Promise<Block | BlockWithTransactions> {\n        await this.getNetwork();\n\n        blockHashOrBlockTag = await blockHashOrBlockTag;\n\n        // If blockTag is a number (not \"latest\", etc), this is the block number\n        let blockNumber = -128;\n\n        const params: { [key: string]: any } = {\n            includeTransactions: !!includeTransactions\n        };\n\n        if (isHexString(blockHashOrBlockTag, 32)) {\n            params.blockHash = blockHashOrBlockTag;\n        } else {\n            try {\n                params.blockTag = await this._getBlockTag(blockHashOrBlockTag);\n                if (isHexString(params.blockTag)) {\n                    blockNumber = parseInt(params.blockTag.substring(2), 16);\n                }\n            } catch (error) {\n                logger.throwArgumentError(\"invalid block hash or block tag\", \"blockHashOrBlockTag\", blockHashOrBlockTag);\n            }\n        }\n\n        return poll(async () => {\n            const block = await this.perform(\"getBlock\", params);\n\n            // Block was not found\n            if (block == null) {\n\n                // For blockhashes, if we didn't say it existed, that blockhash may\n                // not exist. If we did see it though, perhaps from a log, we know\n                // it exists, and this node is just not caught up yet.\n                if (params.blockHash != null) {\n                    if (this._emitted[\"b:\" + params.blockHash] == null) { return null; }\n                }\n\n                // For block tags, if we are asking for a future block, we return null\n                if (params.blockTag != null) {\n                    if (blockNumber > this._emitted.block) { return null; }\n                }\n\n                // Retry on the next block\n                return undefined;\n            }\n\n            // Add transactions\n            if (includeTransactions) {\n                let blockNumber: number = null;\n                for (let i = 0; i < block.transactions.length; i++) {\n                    const tx = block.transactions[i];\n                    if (tx.blockNumber == null) {\n                        tx.confirmations = 0;\n\n                    } else if (tx.confirmations == null) {\n                        if (blockNumber == null) {\n                            blockNumber = await this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                        }\n\n                        // Add the confirmations using the fast block number (pessimistic)\n                        let confirmations = (blockNumber - tx.blockNumber) + 1;\n                        if (confirmations <= 0) { confirmations = 1; }\n                        tx.confirmations = confirmations;\n                    }\n                }\n\n                const blockWithTxs: any = this.formatter.blockWithTransactions(block);\n                blockWithTxs.transactions = blockWithTxs.transactions.map((tx: TransactionResponse) => this._wrapTransaction(tx));\n                return blockWithTxs;\n            }\n\n            return this.formatter.block(block);\n\n        }, { oncePoll: this });\n    }\n\n    getBlock(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>): Promise<Block> {\n        return <Promise<Block>>(this._getBlock(blockHashOrBlockTag, false));\n    }\n\n    getBlockWithTransactions(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>): Promise<BlockWithTransactions> {\n        return <Promise<BlockWithTransactions>>(this._getBlock(blockHashOrBlockTag, true));\n    }\n\n    async getTransaction(transactionHash: string | Promise<string>): Promise<TransactionResponse> {\n        await this.getNetwork();\n        transactionHash = await transactionHash;\n\n        const params = { transactionHash: this.formatter.hash(transactionHash, true) };\n\n        return poll(async () => {\n            const result = await this.perform(\"getTransaction\", params);\n\n            if (result == null) {\n                if (this._emitted[\"t:\" + transactionHash] == null) {\n                    return null;\n                }\n                return undefined;\n            }\n\n            const tx = this.formatter.transactionResponse(result);\n\n            if (tx.blockNumber == null) {\n                tx.confirmations = 0;\n\n            } else if (tx.confirmations == null) {\n                const blockNumber = await this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n\n                // Add the confirmations using the fast block number (pessimistic)\n                let confirmations = (blockNumber - tx.blockNumber) + 1;\n                if (confirmations <= 0) { confirmations = 1; }\n                tx.confirmations = confirmations;\n            }\n\n            return this._wrapTransaction(tx);\n        }, { oncePoll: this });\n    }\n\n    async getTransactionReceipt(transactionHash: string | Promise<string>): Promise<TransactionReceipt> {\n        await this.getNetwork();\n\n        transactionHash = await transactionHash;\n\n        const params = { transactionHash: this.formatter.hash(transactionHash, true) };\n\n        return poll(async () => {\n            const result = await this.perform(\"getTransactionReceipt\", params);\n\n            if (result == null) {\n                if (this._emitted[\"t:\" + transactionHash] == null) {\n                    return null;\n                }\n                return undefined;\n            }\n\n            // \"geth-etc\" returns receipts before they are ready\n            if (result.blockHash == null) { return undefined; }\n\n            const receipt = this.formatter.receipt(result);\n\n            if (receipt.blockNumber == null) {\n                receipt.confirmations = 0;\n\n            } else if (receipt.confirmations == null) {\n                const blockNumber = await this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n\n                // Add the confirmations using the fast block number (pessimistic)\n                let confirmations = (blockNumber - receipt.blockNumber) + 1;\n                if (confirmations <= 0) { confirmations = 1; }\n                receipt.confirmations = confirmations;\n            }\n\n            return receipt;\n        }, { oncePoll: this });\n    }\n\n    async getLogs(filter: Filter | FilterByBlockHash | Promise<Filter | FilterByBlockHash>): Promise<Array<Log>> {\n        await this.getNetwork();\n        const params = await resolveProperties({ filter: this._getFilter(filter) });\n        const logs: Array<Log> = await this.perform(\"getLogs\", params);\n        logs.forEach((log) => {\n            if (log.removed == null) { log.removed = false; }\n        });\n        return Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs);\n    }\n\n    async getEtherPrice(): Promise<number> {\n        await this.getNetwork();\n        return this.perform(\"getEtherPrice\", { });\n    }\n\n    async _getBlockTag(blockTag: BlockTag | Promise<BlockTag>): Promise<BlockTag> {\n        blockTag = await blockTag;\n\n        if (typeof(blockTag) === \"number\" && blockTag < 0) {\n            if (blockTag % 1) {\n                logger.throwArgumentError(\"invalid BlockTag\", \"blockTag\", blockTag);\n            }\n\n            let blockNumber = await this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n            blockNumber += blockTag;\n            if (blockNumber < 0) { blockNumber = 0; }\n            return this.formatter.blockTag(blockNumber)\n        }\n\n        return this.formatter.blockTag(blockTag);\n    }\n\n\n    async getResolver(name: string): Promise<null | Resolver> {\n        try {\n            const address = await this._getResolver(name);\n            if (address == null) { return null; }\n            return new Resolver(this, address, name);\n        } catch (error) {\n            if (error.code === Logger.errors.CALL_EXCEPTION) { return null; }\n            throw error;\n        }\n    }\n\n    async _getResolver(name: string): Promise<string> {\n        // Get the resolver from the blockchain\n        const network = await this.getNetwork();\n\n        // No ENS...\n        if (!network.ensAddress) {\n            logger.throwError(\n                \"network does not support ENS\",\n                Logger.errors.UNSUPPORTED_OPERATION,\n                { operation: \"ENS\", network: network.name }\n            );\n        }\n\n        // keccak256(\"resolver(bytes32)\")\n        const transaction = {\n            to: network.ensAddress,\n            data: (\"0x0178b8bf\" + namehash(name).substring(2))\n        };\n\n        try {\n            return this.formatter.callAddress(await this.call(transaction));\n        } catch (error) {\n            if (error.code === Logger.errors.CALL_EXCEPTION) { return null; }\n            throw error;\n        }\n    }\n\n    async resolveName(name: string | Promise<string>): Promise<null | string> {\n        name = await name;\n\n        // If it is already an address, nothing to resolve\n        try {\n            return Promise.resolve(this.formatter.address(name));\n        } catch (error) {\n            // If is is a hexstring, the address is bad (See #694)\n            if (isHexString(name)) { throw error; }\n        }\n\n        if (typeof(name) !== \"string\") {\n            logger.throwArgumentError(\"invalid ENS name\", \"name\", name);\n        }\n\n        // Get the addr from the resovler\n        const resolver = await this.getResolver(name);\n        if (!resolver) { return null; }\n\n        return await resolver.getAddress();\n    }\n\n    async lookupAddress(address: string | Promise<string>): Promise<null | string> {\n        address = await address;\n        address = this.formatter.address(address);\n\n        const reverseName = address.substring(2).toLowerCase() + \".addr.reverse\";\n\n        const resolverAddress = await this._getResolver(reverseName);\n        if (!resolverAddress) { return null; }\n\n        // keccak(\"name(bytes32)\")\n        let bytes = arrayify(await this.call({\n            to: resolverAddress,\n            data: (\"0x691f3431\" + namehash(reverseName).substring(2))\n        }));\n\n        // Strip off the dynamic string pointer (0x20)\n        if (bytes.length < 32 || !BigNumber.from(bytes.slice(0, 32)).eq(32)) { return null; }\n        bytes = bytes.slice(32);\n\n        // Not a length-prefixed string\n        if (bytes.length < 32) { return null; }\n\n        // Get the length of the string (from the length-prefix)\n        const length = BigNumber.from(bytes.slice(0, 32)).toNumber();\n        bytes = bytes.slice(32);\n\n        // Length longer than available data\n        if (length > bytes.length) { return null; }\n\n        const name = toUtf8String(bytes.slice(0, length));\n\n        // Make sure the reverse record matches the foward record\n        const addr = await this.resolveName(name);\n        if (addr != address) { return null; }\n\n        return name;\n    }\n\n    async getAvatar(nameOrAddress: string): Promise<null | string> {\n        let resolver: Resolver = null;\n        if (isHexString(nameOrAddress)) {\n            // Address; reverse lookup\n            const address = this.formatter.address(nameOrAddress);\n\n            const reverseName = address.substring(2).toLowerCase() + \".addr.reverse\";\n\n            const resolverAddress = await this._getResolver(reverseName);\n            if (!resolverAddress) { return null; }\n\n            resolver = new Resolver(this, resolverAddress, \"_\", address);\n\n        } else {\n            // ENS name; forward lookup\n            resolver = await this.getResolver(nameOrAddress);\n            if (!resolver) { return null; }\n        }\n\n        const avatar = await resolver.getAvatar();\n        if (avatar == null) { return null; }\n\n        return avatar.url;\n    }\n\n    perform(method: string, params: any): Promise<any> {\n        return logger.throwError(method + \" not implemented\", Logger.errors.NOT_IMPLEMENTED, { operation: method });\n    }\n\n    _startEvent(event: Event): void {\n        this.polling = (this._events.filter((e) => e.pollable()).length > 0);\n    }\n\n    _stopEvent(event: Event): void {\n        this.polling = (this._events.filter((e) => e.pollable()).length > 0);\n    }\n\n    _addEventListener(eventName: EventType, listener: Listener, once: boolean): this {\n        const event = new Event(getEventTag(eventName), listener, once)\n        this._events.push(event);\n        this._startEvent(event);\n\n        return this;\n    }\n\n    on(eventName: EventType, listener: Listener): this {\n        return this._addEventListener(eventName, listener, false);\n    }\n\n    once(eventName: EventType, listener: Listener): this {\n        return this._addEventListener(eventName, listener, true);\n    }\n\n\n    emit(eventName: EventType, ...args: Array<any>): boolean {\n        let result = false;\n\n        let stopped: Array<Event> = [ ];\n\n        let eventTag = getEventTag(eventName);\n        this._events = this._events.filter((event) => {\n            if (event.tag !== eventTag) { return true; }\n\n            setTimeout(() => {\n                event.listener.apply(this, args);\n            }, 0);\n\n            result = true;\n\n            if (event.once) {\n                stopped.push(event);\n                return false;\n            }\n\n            return true;\n        });\n\n        stopped.forEach((event) => { this._stopEvent(event); });\n\n        return result;\n    }\n\n    listenerCount(eventName?: EventType): number {\n        if (!eventName) { return this._events.length; }\n\n        let eventTag = getEventTag(eventName);\n        return this._events.filter((event) => {\n            return (event.tag === eventTag);\n        }).length;\n    }\n\n    listeners(eventName?: EventType): Array<Listener> {\n        if (eventName == null) {\n            return this._events.map((event) => event.listener);\n        }\n\n        let eventTag = getEventTag(eventName);\n        return this._events\n            .filter((event) => (event.tag === eventTag))\n            .map((event) => event.listener);\n    }\n\n    off(eventName: EventType, listener?: Listener): this {\n        if (listener == null) {\n            return this.removeAllListeners(eventName);\n        }\n\n        const stopped: Array<Event> = [ ];\n\n        let found = false;\n\n        let eventTag = getEventTag(eventName);\n        this._events = this._events.filter((event) => {\n            if (event.tag !== eventTag || event.listener != listener) { return true; }\n            if (found) { return true; }\n            found = true;\n            stopped.push(event);\n            return false;\n        });\n\n        stopped.forEach((event) => { this._stopEvent(event); });\n\n        return this;\n    }\n\n    removeAllListeners(eventName?: EventType): this {\n        let stopped: Array<Event> = [ ];\n        if (eventName == null) {\n            stopped = this._events;\n\n            this._events = [ ];\n        } else {\n            const eventTag = getEventTag(eventName);\n            this._events = this._events.filter((event) => {\n                if (event.tag !== eventTag) { return true; }\n                stopped.push(event);\n                return false;\n            });\n        }\n\n        stopped.forEach((event) => { this._stopEvent(event); });\n\n        return this;\n    }\n}\n","\"use strict\";\n\n// See: https://github.com/ethereum/wiki/wiki/JSON-RPC\n\nimport { Provider, TransactionRequest, TransactionResponse } from \"@ethersproject/abstract-provider\";\nimport { Signer, TypedDataDomain, TypedDataField, TypedDataSigner } from \"@ethersproject/abstract-signer\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { Bytes, hexlify, hexValue, isHexString } from \"@ethersproject/bytes\";\nimport { _TypedDataEncoder } from \"@ethersproject/hash\";\nimport { Network, Networkish } from \"@ethersproject/networks\";\nimport { checkProperties, deepCopy, Deferrable, defineReadOnly, getStatic, resolveProperties, shallowCopy } from \"@ethersproject/properties\";\nimport { toUtf8Bytes } from \"@ethersproject/strings\";\nimport { AccessList, accessListify } from \"@ethersproject/transactions\";\nimport { ConnectionInfo, fetchJson, poll } from \"@ethersproject/web\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { BaseProvider, Event } from \"./base-provider\";\n\n\nconst errorGas = [ \"call\", \"estimateGas\" ];\n\nfunction checkError(method: string, error: any, params: any): any {\n    // Undo the \"convenience\" some nodes are attempting to prevent backwards\n    // incompatibility; maybe for v6 consider forwarding reverts as errors\n    if (method === \"call\" && error.code === Logger.errors.SERVER_ERROR) {\n        const e = error.error;\n        if (e && e.message.match(\"reverted\") && isHexString(e.data)) {\n            return e.data;\n        }\n\n        logger.throwError(\"missing revert data in call exception\", Logger.errors.CALL_EXCEPTION, {\n            error, data: \"0x\"\n        });\n    }\n\n    let message = error.message;\n    if (error.code === Logger.errors.SERVER_ERROR && error.error && typeof(error.error.message) === \"string\") {\n        message = error.error.message;\n    } else if (typeof(error.body) === \"string\") {\n        message = error.body;\n    } else if (typeof(error.responseText) === \"string\") {\n        message = error.responseText;\n    }\n    message = (message || \"\").toLowerCase();\n\n    const transaction = params.transaction || params.signedTransaction;\n\n    // \"insufficient funds for gas * price + value + cost(data)\"\n    if (message.match(/insufficient funds|base fee exceeds gas limit/)) {\n        logger.throwError(\"insufficient funds for intrinsic transaction cost\", Logger.errors.INSUFFICIENT_FUNDS, {\n            error, method, transaction\n        });\n    }\n\n    // \"nonce too low\"\n    if (message.match(/nonce too low/)) {\n        logger.throwError(\"nonce has already been used\", Logger.errors.NONCE_EXPIRED, {\n            error, method, transaction\n        });\n    }\n\n    // \"replacement transaction underpriced\"\n    if (message.match(/replacement transaction underpriced/)) {\n        logger.throwError(\"replacement fee too low\", Logger.errors.REPLACEMENT_UNDERPRICED, {\n            error, method, transaction\n        });\n    }\n\n    // \"replacement transaction underpriced\"\n    if (message.match(/only replay-protected/)) {\n        logger.throwError(\"legacy pre-eip-155 transactions not supported\", Logger.errors.UNSUPPORTED_OPERATION, {\n            error, method, transaction\n        });\n    }\n\n    if (errorGas.indexOf(method) >= 0 && message.match(/gas required exceeds allowance|always failing transaction|execution reverted/)) {\n        logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n            error, method, transaction\n        });\n    }\n\n    throw error;\n}\n\nfunction timer(timeout: number): Promise<any> {\n    return new Promise(function(resolve) {\n        setTimeout(resolve, timeout);\n    });\n}\n\nfunction getResult(payload: { error?: { code?: number, data?: any, message?: string }, result?: any }): any {\n    if (payload.error) {\n        // @TODO: not any\n        const error: any = new Error(payload.error.message);\n        error.code = payload.error.code;\n        error.data = payload.error.data;\n        throw error;\n    }\n\n    return payload.result;\n}\n\nfunction getLowerCase(value: string): string {\n    if (value) { return value.toLowerCase(); }\n    return value;\n}\n\nconst _constructorGuard = {};\n\nexport class JsonRpcSigner extends Signer implements TypedDataSigner {\n    readonly provider: JsonRpcProvider;\n    _index: number;\n    _address: string;\n\n    constructor(constructorGuard: any, provider: JsonRpcProvider, addressOrIndex?: string | number) {\n        logger.checkNew(new.target, JsonRpcSigner);\n\n        super();\n\n        if (constructorGuard !== _constructorGuard) {\n            throw new Error(\"do not call the JsonRpcSigner constructor directly; use provider.getSigner\");\n        }\n\n        defineReadOnly(this, \"provider\", provider);\n\n        if (addressOrIndex == null) { addressOrIndex = 0; }\n\n        if (typeof(addressOrIndex) === \"string\") {\n            defineReadOnly(this, \"_address\", this.provider.formatter.address(addressOrIndex));\n            defineReadOnly(this, \"_index\", null);\n\n        } else if (typeof(addressOrIndex) === \"number\") {\n            defineReadOnly(this, \"_index\", addressOrIndex);\n            defineReadOnly(this, \"_address\", null);\n\n        } else {\n            logger.throwArgumentError(\"invalid address or index\", \"addressOrIndex\", addressOrIndex);\n        }\n    }\n\n    connect(provider: Provider): JsonRpcSigner {\n        return logger.throwError(\"cannot alter JSON-RPC Signer connection\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"connect\"\n        });\n    }\n\n    connectUnchecked(): JsonRpcSigner {\n        return new UncheckedJsonRpcSigner(_constructorGuard, this.provider, this._address || this._index);\n    }\n\n    getAddress(): Promise<string> {\n        if (this._address) {\n            return Promise.resolve(this._address);\n        }\n\n        return this.provider.send(\"eth_accounts\", []).then((accounts) => {\n            if (accounts.length <= this._index) {\n                logger.throwError(\"unknown account #\" + this._index, Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"getAddress\"\n                });\n            }\n            return this.provider.formatter.address(accounts[this._index])\n        });\n    }\n\n    sendUncheckedTransaction(transaction: Deferrable<TransactionRequest>): Promise<string> {\n        transaction = shallowCopy(transaction);\n\n        const fromAddress = this.getAddress().then((address) => {\n            if (address) { address = address.toLowerCase(); }\n            return address;\n        });\n\n        // The JSON-RPC for eth_sendTransaction uses 90000 gas; if the user\n        // wishes to use this, it is easy to specify explicitly, otherwise\n        // we look it up for them.\n        if (transaction.gasLimit == null) {\n            const estimate = shallowCopy(transaction);\n            estimate.from = fromAddress;\n            transaction.gasLimit = this.provider.estimateGas(estimate);\n        }\n\n        if (transaction.to != null) {\n            transaction.to = Promise.resolve(transaction.to).then(async (to) => {\n                if (to == null) { return null; }\n                const address = await this.provider.resolveName(to);\n                if (address == null) {\n                    logger.throwArgumentError(\"provided ENS name resolves to null\", \"tx.to\", to);\n                }\n                return address;\n            });\n        }\n\n        return resolveProperties({\n            tx: resolveProperties(transaction),\n            sender: fromAddress\n        }).then(({ tx, sender }) => {\n\n            if (tx.from != null) {\n                if (tx.from.toLowerCase() !== sender) {\n                    logger.throwArgumentError(\"from address mismatch\", \"transaction\", transaction);\n                }\n            } else {\n                tx.from = sender;\n            }\n\n            const hexTx = (<any>this.provider.constructor).hexlifyTransaction(tx, { from: true });\n\n            return this.provider.send(\"eth_sendTransaction\", [ hexTx ]).then((hash) => {\n                return hash;\n            }, (error) => {\n                return checkError(\"sendTransaction\", error, hexTx);\n            });\n        });\n    }\n\n    signTransaction(transaction: Deferrable<TransactionRequest>): Promise<string> {\n        return logger.throwError(\"signing transactions is unsupported\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"signTransaction\"\n        });\n    }\n\n    async sendTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionResponse> {\n        // This cannot be mined any earlier than any recent block\n        const blockNumber = await this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval);\n\n        // Send the transaction\n        const hash = await this.sendUncheckedTransaction(transaction);\n\n        try {\n            // Unfortunately, JSON-RPC only provides and opaque transaction hash\n            // for a response, and we need the actual transaction, so we poll\n            // for it; it should show up very quickly\n            return await poll(async () => {\n                const tx = await this.provider.getTransaction(hash);\n                if (tx === null) { return undefined; }\n                return this.provider._wrapTransaction(tx, hash, blockNumber);\n            }, { oncePoll: this.provider });\n        } catch (error) {\n            (<any>error).transactionHash = hash;\n            throw error;\n        }\n    }\n\n    async signMessage(message: Bytes | string): Promise<string> {\n        const data = ((typeof(message) === \"string\") ? toUtf8Bytes(message): message);\n        const address = await this.getAddress();\n\n        return await this.provider.send(\"personal_sign\", [ hexlify(data), address.toLowerCase() ]);\n    }\n\n    async _legacySignMessage(message: Bytes | string): Promise<string> {\n        const data = ((typeof(message) === \"string\") ? toUtf8Bytes(message): message);\n        const address = await this.getAddress();\n\n        // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign\n        return await this.provider.send(\"eth_sign\", [ address.toLowerCase(), hexlify(data) ]);\n    }\n\n    async _signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): Promise<string> {\n        // Populate any ENS names (in-place)\n        const populated = await _TypedDataEncoder.resolveNames(domain, types, value, (name: string) => {\n            return this.provider.resolveName(name);\n        });\n\n        const address = await this.getAddress();\n\n        return await this.provider.send(\"eth_signTypedData_v4\", [\n            address.toLowerCase(),\n            JSON.stringify(_TypedDataEncoder.getPayload(populated.domain, types, populated.value))\n        ]);\n    }\n\n    async unlock(password: string): Promise<boolean> {\n        const provider = this.provider;\n\n        const address = await this.getAddress();\n\n        return provider.send(\"personal_unlockAccount\", [ address.toLowerCase(), password, null ]);\n    }\n}\n\nclass UncheckedJsonRpcSigner extends JsonRpcSigner {\n    sendTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionResponse> {\n        return this.sendUncheckedTransaction(transaction).then((hash) => {\n            return <TransactionResponse>{\n                hash: hash,\n                nonce: null,\n                gasLimit: null,\n                gasPrice: null,\n                data: null,\n                value: null,\n                chainId: null,\n                confirmations: 0,\n                from: null,\n                wait: (confirmations?: number) => { return this.provider.waitForTransaction(hash, confirmations); }\n            };\n        });\n    }\n}\n\nconst allowedTransactionKeys: { [ key: string ]: boolean } = {\n    chainId: true, data: true, gasLimit: true, gasPrice:true, nonce: true, to: true, value: true,\n    type: true, accessList: true,\n    maxFeePerGas: true, maxPriorityFeePerGas: true\n}\n\nexport class JsonRpcProvider extends BaseProvider {\n    readonly connection: ConnectionInfo;\n\n    _pendingFilter: Promise<number>;\n    _nextId: number;\n\n    // During any given event loop, the results for a given call will\n    // all be the same, so we can dedup the calls to save requests and\n    // bandwidth. @TODO: Try out generalizing this against send?\n    _eventLoopCache: Record<string, Promise<any>>;\n    get _cache(): Record<string, Promise<any>> {\n        if (this._eventLoopCache == null) {\n            this._eventLoopCache = { };\n        }\n        return this._eventLoopCache;\n    }\n\n    constructor(url?: ConnectionInfo | string, network?: Networkish) {\n        logger.checkNew(new.target, JsonRpcProvider);\n\n        let networkOrReady: Networkish | Promise<Network> = network;\n\n        // The network is unknown, query the JSON-RPC for it\n        if (networkOrReady == null) {\n            networkOrReady = new Promise((resolve, reject) => {\n                setTimeout(() => {\n                    this.detectNetwork().then((network) => {\n                        resolve(network);\n                    }, (error) => {\n                        reject(error);\n                    });\n                }, 0);\n            });\n        }\n\n        super(networkOrReady);\n\n        // Default URL\n        if (!url) { url = getStatic<() => string>(this.constructor, \"defaultUrl\")(); }\n\n        if (typeof(url) === \"string\") {\n            defineReadOnly(this, \"connection\",Object.freeze({\n                url: url\n            }));\n        } else {\n            defineReadOnly(this, \"connection\", Object.freeze(shallowCopy(url)));\n        }\n\n        this._nextId = 42;\n    }\n\n    static defaultUrl(): string {\n        return \"http:/\\/localhost:8545\";\n    }\n\n    detectNetwork(): Promise<Network> {\n        if (!this._cache[\"detectNetwork\"]) {\n            this._cache[\"detectNetwork\"] = this._uncachedDetectNetwork();\n\n            // Clear this cache at the beginning of the next event loop\n            setTimeout(() => {\n                this._cache[\"detectNetwork\"] = null;\n            }, 0);\n        }\n        return this._cache[\"detectNetwork\"];\n    }\n\n    async _uncachedDetectNetwork(): Promise<Network> {\n        await timer(0);\n\n        let chainId = null;\n        try {\n            chainId = await this.send(\"eth_chainId\", [ ]);\n        } catch (error) {\n            try {\n                chainId = await this.send(\"net_version\", [ ]);\n            } catch (error) { }\n        }\n\n        if (chainId != null) {\n            const getNetwork = getStatic<(network: Networkish) => Network>(this.constructor, \"getNetwork\");\n            try {\n                return getNetwork(BigNumber.from(chainId).toNumber());\n            } catch (error) {\n                return logger.throwError(\"could not detect network\", Logger.errors.NETWORK_ERROR, {\n                    chainId: chainId,\n                    event: \"invalidNetwork\",\n                    serverError: error\n                });\n            }\n        }\n\n        return logger.throwError(\"could not detect network\", Logger.errors.NETWORK_ERROR, {\n            event: \"noNetwork\"\n        });\n    }\n\n    getSigner(addressOrIndex?: string | number): JsonRpcSigner {\n        return new JsonRpcSigner(_constructorGuard, this, addressOrIndex);\n    }\n\n    getUncheckedSigner(addressOrIndex?: string | number): UncheckedJsonRpcSigner {\n        return this.getSigner(addressOrIndex).connectUnchecked();\n    }\n\n    listAccounts(): Promise<Array<string>> {\n        return this.send(\"eth_accounts\", []).then((accounts: Array<string>) => {\n            return accounts.map((a) => this.formatter.address(a));\n        });\n    }\n\n    send(method: string, params: Array<any>): Promise<any> {\n        const request = {\n            method: method,\n            params: params,\n            id: (this._nextId++),\n            jsonrpc: \"2.0\"\n        };\n\n        this.emit(\"debug\", {\n            action: \"request\",\n            request: deepCopy(request),\n            provider: this\n        });\n\n        // We can expand this in the future to any call, but for now these\n        // are the biggest wins and do not require any serializing parameters.\n        const cache = ([ \"eth_chainId\", \"eth_blockNumber\" ].indexOf(method) >= 0);\n        if (cache && this._cache[method]) {\n            return this._cache[method];\n        }\n\n        const result = fetchJson(this.connection, JSON.stringify(request), getResult).then((result) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                request: request,\n                response: result,\n                provider: this\n            });\n\n            return result;\n\n        }, (error) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                error: error,\n                request: request,\n                provider: this\n            });\n\n            throw error;\n        });\n\n        // Cache the fetch, but clear it on the next event loop\n        if (cache) {\n            this._cache[method] = result;\n            setTimeout(() => {\n                this._cache[method] = null;\n            }, 0);\n        }\n\n        return result;\n    }\n\n    prepareRequest(method: string, params: any): [ string, Array<any> ] {\n        switch (method) {\n            case \"getBlockNumber\":\n                return [ \"eth_blockNumber\", [] ];\n\n            case \"getGasPrice\":\n                return [ \"eth_gasPrice\", [] ];\n\n            case \"getBalance\":\n                return [ \"eth_getBalance\", [ getLowerCase(params.address), params.blockTag ] ];\n\n            case \"getTransactionCount\":\n                return [ \"eth_getTransactionCount\", [ getLowerCase(params.address), params.blockTag ] ];\n\n            case \"getCode\":\n                return [ \"eth_getCode\", [ getLowerCase(params.address), params.blockTag ] ];\n\n            case \"getStorageAt\":\n                return [ \"eth_getStorageAt\", [ getLowerCase(params.address), params.position, params.blockTag ] ];\n\n            case \"sendTransaction\":\n                return [ \"eth_sendRawTransaction\", [ params.signedTransaction ] ]\n\n            case \"getBlock\":\n                if (params.blockTag) {\n                    return [ \"eth_getBlockByNumber\", [ params.blockTag, !!params.includeTransactions ] ];\n                } else if (params.blockHash) {\n                    return [ \"eth_getBlockByHash\", [ params.blockHash, !!params.includeTransactions ] ];\n                }\n                return null;\n\n            case \"getTransaction\":\n                return [ \"eth_getTransactionByHash\", [ params.transactionHash ] ];\n\n            case \"getTransactionReceipt\":\n                return [ \"eth_getTransactionReceipt\", [ params.transactionHash ] ];\n\n            case \"call\": {\n                const hexlifyTransaction = getStatic<(t: TransactionRequest, a?: { [key: string]: boolean }) => { [key: string]: string }>(this.constructor, \"hexlifyTransaction\");\n                return [ \"eth_call\", [ hexlifyTransaction(params.transaction, { from: true }), params.blockTag ] ];\n            }\n\n            case \"estimateGas\": {\n                const hexlifyTransaction = getStatic<(t: TransactionRequest, a?: { [key: string]: boolean }) => { [key: string]: string }>(this.constructor, \"hexlifyTransaction\");\n                return [ \"eth_estimateGas\", [ hexlifyTransaction(params.transaction, { from: true }) ] ];\n            }\n\n            case \"getLogs\":\n                if (params.filter && params.filter.address != null) {\n                    params.filter.address = getLowerCase(params.filter.address);\n                }\n                return [ \"eth_getLogs\", [ params.filter ] ];\n\n            default:\n                break;\n        }\n\n        return null;\n    }\n\n    async perform(method: string, params: any): Promise<any> {\n        // Legacy networks do not like the type field being passed along (which\n        // is fair), so we delete type if it is 0 and a non-EIP-1559 network\n        if (method === \"call\" || method === \"estimateGas\") {\n            const tx = params.transaction;\n            if (tx && tx.type != null && BigNumber.from(tx.type).isZero()) {\n                // If there are no EIP-1559 properties, it might be non-EIP-a559\n                if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {\n                    const feeData = await this.getFeeData();\n                    if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {\n                        // Network doesn't know about EIP-1559 (and hence type)\n                        params = shallowCopy(params);\n                        params.transaction = shallowCopy(tx);\n                        delete params.transaction.type;\n                    }\n                }\n            }\n        }\n\n        const args = this.prepareRequest(method,  params);\n\n        if (args == null) {\n            logger.throwError(method + \" not implemented\", Logger.errors.NOT_IMPLEMENTED, { operation: method });\n        }\n        try {\n            return await this.send(args[0], args[1])\n        } catch (error) {\n            return checkError(method, error, params);\n        }\n    }\n\n    _startEvent(event: Event): void {\n        if (event.tag === \"pending\") { this._startPending(); }\n        super._startEvent(event);\n    }\n\n    _startPending(): void {\n        if (this._pendingFilter != null) { return; }\n        const self = this;\n\n        const pendingFilter: Promise<number> = this.send(\"eth_newPendingTransactionFilter\", []);\n        this._pendingFilter = pendingFilter;\n\n        pendingFilter.then(function(filterId) {\n            function poll() {\n                self.send(\"eth_getFilterChanges\", [ filterId ]).then(function(hashes: Array<string>) {\n                    if (self._pendingFilter != pendingFilter) { return null; }\n\n                    let seq = Promise.resolve();\n                    hashes.forEach(function(hash) {\n                        // @TODO: This should be garbage collected at some point... How? When?\n                        self._emitted[\"t:\" + hash.toLowerCase()] = \"pending\";\n                        seq = seq.then(function() {\n                            return self.getTransaction(hash).then(function(tx) {\n                                self.emit(\"pending\", tx);\n                                return null;\n                            });\n                        });\n                    });\n\n                    return seq.then(function() {\n                        return timer(1000);\n                    });\n                }).then(function() {\n                    if (self._pendingFilter != pendingFilter) {\n                        self.send(\"eth_uninstallFilter\", [ filterId ]);\n                        return;\n                    }\n                    setTimeout(function() { poll(); }, 0);\n\n                    return null;\n                }).catch((error: Error) => { });\n            }\n            poll();\n\n            return filterId;\n        }).catch((error: Error) => { });\n    }\n\n    _stopEvent(event: Event): void {\n        if (event.tag === \"pending\" && this.listenerCount(\"pending\") === 0) {\n            this._pendingFilter = null;\n        }\n        super._stopEvent(event);\n    }\n\n    // Convert an ethers.js transaction into a JSON-RPC transaction\n    //  - gasLimit => gas\n    //  - All values hexlified\n    //  - All numeric values zero-striped\n    //  - All addresses are lowercased\n    // NOTE: This allows a TransactionRequest, but all values should be resolved\n    //       before this is called\n    // @TODO: This will likely be removed in future versions and prepareRequest\n    //        will be the preferred method for this.\n    static hexlifyTransaction(transaction: TransactionRequest, allowExtra?: { [key: string]: boolean }): { [key: string]: string | AccessList } {\n        // Check only allowed properties are given\n        const allowed = shallowCopy(allowedTransactionKeys);\n        if (allowExtra) {\n            for (const key in allowExtra) {\n                if (allowExtra[key]) { allowed[key] = true; }\n            }\n        }\n\n        checkProperties(transaction, allowed);\n\n        const result: { [key: string]: string | AccessList } = {};\n\n        // Some nodes (INFURA ropsten; INFURA mainnet is fine) do not like leading zeros.\n        [\"gasLimit\", \"gasPrice\", \"type\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"nonce\", \"value\"].forEach(function(key) {\n            if ((<any>transaction)[key] == null) { return; }\n            const value = hexValue((<any>transaction)[key]);\n            if (key === \"gasLimit\") { key = \"gas\"; }\n            result[key] = value;\n        });\n\n        [\"from\", \"to\", \"data\"].forEach(function(key) {\n            if ((<any>transaction)[key] == null) { return; }\n            result[key] = hexlify((<any>transaction)[key]);\n        });\n\n        if ((<any>transaction).accessList) {\n            result[\"accessList\"] = accessListify((<any>transaction).accessList);\n        }\n\n        return result;\n    }\n}\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\n\nlet WS: any = null;\n\ntry {\n    WS = (WebSocket as any);\n    if (WS == null) { throw new Error(\"inject please\"); }\n} catch (error) {\n    const logger = new Logger(version);\n    WS = function() {\n        logger.throwError(\"WebSockets not supported in this environment\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"new WebSocket()\"\n        });\n    }\n}\n//export default WS;\n//module.exports = WS;\nexport { WS as WebSocket };\n","\"use strict\";\n\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { Network, Networkish } from \"@ethersproject/networks\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Event } from \"./base-provider\";\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\nimport { WebSocket } from \"./ws\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n/**\n *  Notes:\n *\n *  This provider differs a bit from the polling providers. One main\n *  difference is how it handles consistency. The polling providers\n *  will stall responses to ensure a consistent state, while this\n *  WebSocket provider assumes the connected backend will manage this.\n *\n *  For example, if a polling provider emits an event which indicates\n *  the event occurred in blockhash XXX, a call to fetch that block by\n *  its hash XXX, if not present will retry until it is present. This\n *  can occur when querying a pool of nodes that are mildly out of sync\n *  with each other.\n */\n\nlet NextId = 1;\n\nexport type InflightRequest = {\n     callback: (error: Error, result: any) => void;\n     payload: string;\n};\n\nexport type Subscription = {\n    tag: string;\n    processFunc: (payload: any) => void;\n};\n\n\n// For more info about the Real-time Event API see:\n//   https://geth.ethereum.org/docs/rpc/pubsub\n\nexport class WebSocketProvider extends JsonRpcProvider {\n    readonly _websocket: any;\n    readonly _requests: { [ name: string ]: InflightRequest };\n    readonly _detectNetwork: Promise<Network>;\n\n    // Maps event tag to subscription ID (we dedupe identical events)\n    readonly _subIds: { [ tag: string ]: Promise<string> };\n\n    // Maps Subscription ID to Subscription\n    readonly _subs: { [ name: string ]: Subscription };\n\n    _wsReady: boolean;\n\n    constructor(url: string, network?: Networkish) {\n        // This will be added in the future; please open an issue to expedite\n        if (network === \"any\") {\n            logger.throwError(\"WebSocketProvider does not support 'any' network yet\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"network:any\"\n            });\n        }\n\n        super(url, network);\n        this._pollingInterval = -1;\n\n        this._wsReady = false;\n\n        defineReadOnly(this, \"_websocket\", new WebSocket(this.connection.url));\n        defineReadOnly(this, \"_requests\", { });\n        defineReadOnly(this, \"_subs\", { });\n        defineReadOnly(this, \"_subIds\", { });\n        defineReadOnly(this, \"_detectNetwork\", super.detectNetwork());\n\n        // Stall sending requests until the socket is open...\n        this._websocket.onopen = () => {\n            this._wsReady = true;\n            Object.keys(this._requests).forEach((id) => {\n                this._websocket.send(this._requests[id].payload);\n            });\n        };\n\n        this._websocket.onmessage = (messageEvent: { data: string }) => {\n            const data = messageEvent.data;\n            const result = JSON.parse(data);\n            if (result.id != null) {\n                const id = String(result.id);\n                const request = this._requests[id];\n                delete this._requests[id];\n\n                if (result.result !== undefined) {\n                    request.callback(null, result.result);\n\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        request: JSON.parse(request.payload),\n                        response: result.result,\n                        provider: this\n                    });\n\n                } else {\n                    let error: Error = null;\n                    if (result.error) {\n                        error = new Error(result.error.message || \"unknown error\");\n                        defineReadOnly(<any>error, \"code\", result.error.code || null);\n                        defineReadOnly(<any>error, \"response\", data);\n                    } else {\n                        error = new Error(\"unknown error\");\n                    }\n\n                    request.callback(error, undefined);\n\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        error: error,\n                        request: JSON.parse(request.payload),\n                        provider: this\n                    });\n\n                }\n\n            } else if (result.method === \"eth_subscription\") {\n                // Subscription...\n                const sub = this._subs[result.params.subscription];\n                if (sub) {\n                    //this.emit.apply(this,                  );\n                    sub.processFunc(result.params.result)\n                }\n\n            } else {\n                console.warn(\"this should not happen\");\n            }\n        };\n\n        // This Provider does not actually poll, but we want to trigger\n        // poll events for things that depend on them (like stalling for\n        // block and transaction lookups)\n        const fauxPoll = setInterval(() => {\n            this.emit(\"poll\");\n        }, 1000);\n        if (fauxPoll.unref) { fauxPoll.unref(); }\n    }\n\n    detectNetwork(): Promise<Network> {\n        return this._detectNetwork;\n    }\n\n    get pollingInterval(): number {\n        return 0;\n    }\n\n    resetEventsBlock(blockNumber: number): void {\n        logger.throwError(\"cannot reset events block on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"resetEventBlock\"\n        });\n    }\n\n    set pollingInterval(value: number) {\n        logger.throwError(\"cannot set polling interval on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"setPollingInterval\"\n        });\n    }\n\n    async poll(): Promise<void> {\n        return null;\n    }\n\n    set polling(value: boolean) {\n        if (!value) { return; }\n\n        logger.throwError(\"cannot set polling on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"setPolling\"\n        });\n    }\n\n    send(method: string, params?: Array<any>): Promise<any> {\n        const rid = NextId++;\n\n        return new Promise((resolve, reject) => {\n            function callback(error: Error, result: any) {\n                if (error) { return reject(error); }\n                return resolve(result);\n            }\n\n            const payload = JSON.stringify({\n                method: method,\n                params: params,\n                id: rid,\n                jsonrpc: \"2.0\"\n            });\n\n            this.emit(\"debug\", {\n                action: \"request\",\n                request: JSON.parse(payload),\n                provider: this\n            });\n\n            this._requests[String(rid)] = { callback, payload };\n\n            if (this._wsReady) { this._websocket.send(payload); }\n        });\n    }\n\n    static defaultUrl(): string {\n        return \"ws:/\\/localhost:8546\";\n    }\n\n    async _subscribe(tag: string, param: Array<any>, processFunc: (result: any) => void): Promise<void> {\n        let subIdPromise = this._subIds[tag];\n        if (subIdPromise == null) {\n            subIdPromise = Promise.all(param).then((param) => {\n                return this.send(\"eth_subscribe\", param);\n            });\n            this._subIds[tag] = subIdPromise;\n        }\n        const subId = await subIdPromise;\n        this._subs[subId] = { tag, processFunc };\n    }\n\n    _startEvent(event: Event): void {\n        switch (event.type) {\n            case \"block\":\n                this._subscribe(\"block\", [ \"newHeads\" ], (result: any) => {\n                    const blockNumber = BigNumber.from(result.number).toNumber();\n                    this._emitted.block = blockNumber;\n                    this.emit(\"block\", blockNumber);\n                });\n                break;\n\n            case \"pending\":\n                this._subscribe(\"pending\", [ \"newPendingTransactions\" ], (result: any) => {\n                    this.emit(\"pending\", result);\n                });\n                break;\n\n            case \"filter\":\n                this._subscribe(event.tag, [ \"logs\", this._getFilter(event.filter) ], (result: any) => {\n                    if (result.removed == null) { result.removed = false; }\n                    this.emit(event.filter, this.formatter.filterLog(result));\n                });\n                break;\n\n            case \"tx\": {\n                const emitReceipt = (event: Event) => {\n                    const hash = event.hash;\n                    this.getTransactionReceipt(hash).then((receipt) => {\n                        if (!receipt) { return; }\n                        this.emit(hash, receipt);\n                    });\n                };\n\n                // In case it is already mined\n                emitReceipt(event);\n\n                // To keep things simple, we start up a single newHeads subscription\n                // to keep an eye out for transactions we are watching for.\n                // Starting a subscription for an event (i.e. \"tx\") that is already\n                // running is (basically) a nop.\n                this._subscribe(\"tx\", [ \"newHeads\" ], (result: any) => {\n                    this._events.filter((e) => (e.type === \"tx\")).forEach(emitReceipt);\n                });\n                break;\n            }\n\n            // Nothing is needed\n            case \"debug\":\n            case \"poll\":\n            case \"willPoll\":\n            case \"didPoll\":\n            case \"error\":\n                break;\n\n            default:\n                console.log(\"unhandled:\", event);\n                break;\n        }\n    }\n\n    _stopEvent(event: Event): void {\n        let tag = event.tag;\n\n        if (event.type === \"tx\") {\n            // There are remaining transaction event listeners\n            if (this._events.filter((e) => (e.type === \"tx\")).length) {\n                return;\n            }\n            tag = \"tx\";\n        } else if (this.listenerCount(event.event)) {\n            // There are remaining event listeners\n            return;\n        }\n\n        const subId = this._subIds[tag];\n        if (!subId) { return; }\n\n       delete this._subIds[tag];\n       subId.then((subId) => {\n            if (!this._subs[subId]) { return; }\n            delete this._subs[subId];\n            this.send(\"eth_unsubscribe\", [ subId ]);\n        });\n    }\n\n    async destroy(): Promise<void> {\n        // Wait until we have connected before trying to disconnect\n        if (this._websocket.readyState === WebSocket.CONNECTING) {\n            await (new Promise((resolve) => {\n                this._websocket.onopen = function() {\n                    resolve(true);\n                };\n\n                this._websocket.onerror = function() {\n                    resolve(false);\n                };\n            }));\n        }\n\n        // Hangup\n        // See: https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes\n        this._websocket.close(1000);\n    }\n}\n","\n\"use strict\";\n\nimport { Network, Networkish } from \"@ethersproject/networks\";\nimport { defineReadOnly, getStatic } from \"@ethersproject/properties\";\nimport { ConnectionInfo } from \"@ethersproject/web\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { CommunityResourcable } from \"./formatter\";\nimport { JsonRpcProvider, JsonRpcSigner } from \"./json-rpc-provider\";\n\ntype getUrlFunc = (network: Network, apiKey: string) => string | ConnectionInfo;\n\n// A StaticJsonRpcProvider is useful when you *know* for certain that\n// the backend will never change, as it never calls eth_chainId to\n// verify its backend. However, if the backend does change, the effects\n// are undefined and may include:\n// - inconsistent results\n// - locking up the UI\n// - block skew warnings\n// - wrong results\n// If the network is not explicit (i.e. auto-detection is expected), the\n// node MUST be running and available to respond to requests BEFORE this\n// is instantiated.\nexport class StaticJsonRpcProvider extends JsonRpcProvider {\n    async detectNetwork(): Promise<Network> {\n        let network = this.network;\n        if (network == null) {\n            network = await super.detectNetwork();\n\n            if (!network) {\n                logger.throwError(\"no network detected\", Logger.errors.UNKNOWN_ERROR, { });\n            }\n\n            // If still not set, set it\n            if (this._network == null) {\n                // A static network does not support \"any\"\n                defineReadOnly(this, \"_network\", network);\n\n                this.emit(\"network\", network, null);\n            }\n        }\n        return network;\n    }\n}\n\nexport abstract class UrlJsonRpcProvider extends StaticJsonRpcProvider implements CommunityResourcable {\n    readonly apiKey: any;\n\n    constructor(network?: Networkish, apiKey?: any) {\n        logger.checkAbstract(new.target, UrlJsonRpcProvider);\n\n        // Normalize the Network and API Key\n        network = getStatic<(network: Networkish) => Network>(new.target, \"getNetwork\")(network);\n        apiKey = getStatic<(apiKey: string) => string>(new.target, \"getApiKey\")(apiKey);\n\n        const connection = getStatic<getUrlFunc>(new.target, \"getUrl\")(network, apiKey);\n\n        super(connection, network);\n\n        if (typeof(apiKey) === \"string\") {\n            defineReadOnly(this, \"apiKey\", apiKey);\n        } else if (apiKey != null) {\n            Object.keys(apiKey).forEach((key) => {\n                defineReadOnly<any, any>(this, key, apiKey[key]);\n            });\n        }\n    }\n\n    _startPending(): void {\n        logger.warn(\"WARNING: API provider does not support pending filters\");\n    }\n\n    isCommunityResource(): boolean {\n        return false;\n    }\n\n    getSigner(address?: string): JsonRpcSigner {\n        return logger.throwError(\n            \"API provider does not support signing\",\n            Logger.errors.UNSUPPORTED_OPERATION,\n            { operation: \"getSigner\" }\n        );\n    }\n\n    listAccounts(): Promise<Array<string>> {\n        return Promise.resolve([]);\n    }\n\n    // Return a defaultApiKey if null, otherwise validate the API key\n    static getApiKey(apiKey: any): any {\n        return apiKey;\n    }\n\n    // Returns the url or connection for the given network and API key. The\n    // API key will have been sanitized by the getApiKey first, so any validation\n    // or transformations can be done there.\n    static getUrl(network: Network, apiKey: any): string | ConnectionInfo {\n        return logger.throwError(\"not implemented; sub-classes must override getUrl\", Logger.errors.NOT_IMPLEMENTED, {\n            operation: \"getUrl\"\n        });\n    }\n}\n","\"use strict\";\n\nimport { Network, Networkish } from \"@ethersproject/networks\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { ConnectionInfo } from \"@ethersproject/web\";\n\nimport { CommunityResourcable, showThrottleMessage } from \"./formatter\";\nimport { WebSocketProvider } from \"./websocket-provider\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\n\n// This key was provided to ethers.js by Alchemy to be used by the\n// default provider, but it is recommended that for your own\n// production environments, that you acquire your own API key at:\n//   https://dashboard.alchemyapi.io\n\nconst defaultApiKey = \"_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC\"\n\nexport class AlchemyWebSocketProvider extends WebSocketProvider implements CommunityResourcable {\n    readonly apiKey: string;\n\n    constructor(network?: Networkish, apiKey?: any) {\n        const provider = new AlchemyProvider(network, apiKey);\n\n        const url = provider.connection.url.replace(/^http/i, \"ws\")\n                                           .replace(\".alchemyapi.\", \".ws.alchemyapi.\");\n\n        super(url, provider.network);\n        defineReadOnly(this, \"apiKey\", provider.apiKey);\n    }\n\n    isCommunityResource(): boolean {\n        return (this.apiKey === defaultApiKey);\n    }\n}\n\nexport class AlchemyProvider extends UrlJsonRpcProvider {\n\n    static getWebSocketProvider(network?: Networkish, apiKey?: any): AlchemyWebSocketProvider {\n        return new AlchemyWebSocketProvider(network, apiKey);\n    }\n\n    static getApiKey(apiKey: any): any {\n        if (apiKey == null) { return defaultApiKey; }\n        if (apiKey && typeof(apiKey) !== \"string\") {\n            logger.throwArgumentError(\"invalid apiKey\", \"apiKey\", apiKey);\n        }\n        return apiKey;\n    }\n\n    static getUrl(network: Network, apiKey: string): ConnectionInfo {\n        let host = null;\n        switch (network.name) {\n            case \"homestead\":\n                host = \"eth-mainnet.alchemyapi.io/v2/\";\n                break;\n            case \"ropsten\":\n                host = \"eth-ropsten.alchemyapi.io/v2/\";\n                break;\n            case \"rinkeby\":\n                host = \"eth-rinkeby.alchemyapi.io/v2/\";\n                break;\n            case \"goerli\":\n                host = \"eth-goerli.alchemyapi.io/v2/\";\n                break;\n            case \"kovan\":\n                host = \"eth-kovan.alchemyapi.io/v2/\";\n                break;\n            case \"matic\":\n                host = \"polygon-mainnet.g.alchemy.com/v2/\";\n                break;\n            case \"maticmum\":\n                host = \"polygon-mumbai.g.alchemy.com/v2/\";\n                break;\n            case \"arbitrum\":\n                host = \"arb-mainnet.g.alchemy.com/v2/\";\n                break;\n            case \"arbitrum-rinkeby\":\n                host = \"arb-rinkeby.g.alchemy.com/v2/\";\n                break;\n            case \"optimism\":\n                host = \"opt-mainnet.g.alchemy.com/v2/\";\n                break;\n            case \"optimism-kovan\":\n                host = \"opt-kovan.g.alchemy.com/v2/\";\n                break;\n            default:\n               logger.throwArgumentError(\"unsupported network\", \"network\", arguments[0]);\n        }\n\n        return {\n            allowGzip: true,\n            url: (\"https:/\" + \"/\" + host + apiKey),\n            throttleCallback: (attempt: number, url: string) => {\n                if (apiKey === defaultApiKey) {\n                    showThrottleMessage();\n                }\n                return Promise.resolve(true);\n            }\n        };\n    }\n\n    isCommunityResource(): boolean {\n        return (this.apiKey === defaultApiKey);\n    }\n}\n","\"use strict\";\n\nimport { Network } from \"@ethersproject/networks\";\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport class CloudflareProvider extends UrlJsonRpcProvider {\n\n    static getApiKey(apiKey: any): any {\n        if (apiKey != null) {\n            logger.throwArgumentError(\"apiKey not supported for cloudflare\", \"apiKey\", apiKey);\n        }\n        return null;\n    }\n\n    static getUrl(network: Network, apiKey?: any): string {\n        let host = null;\n        switch (network.name) {\n            case \"homestead\":\n                host = \"https://cloudflare-eth.com/\";\n                break;\n            default:\n               logger.throwArgumentError(\"unsupported network\", \"network\", arguments[0]);\n        }\n\n        return host;\n    }\n\n    async perform(method: string, params: any): Promise<any> {\n        // The Cloudflare provider does not support eth_blockNumber,\n        // so we get the latest block and pull it from that\n        if (method === \"getBlockNumber\") {\n            const block = await super.perform(\"getBlock\", { blockTag: \"latest\" });\n            return block.number;\n        }\n\n        return super.perform(method, params);\n    }\n}\n","\"use strict\";\n\nimport { BlockTag, TransactionRequest, TransactionResponse } from \"@ethersproject/abstract-provider\";\nimport { hexlify, hexValue, isHexString } from \"@ethersproject/bytes\";\nimport { Network, Networkish } from \"@ethersproject/networks\";\nimport { deepCopy, defineReadOnly } from \"@ethersproject/properties\";\nimport { accessListify } from \"@ethersproject/transactions\";\nimport { ConnectionInfo, fetchJson } from \"@ethersproject/web\";\n\nimport { showThrottleMessage } from \"./formatter\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { BaseProvider } from \"./base-provider\";\n\n\n// The transaction has already been sanitized by the calls in Provider\nfunction getTransactionPostData(transaction: TransactionRequest): Record<string, string> {\n    const result: Record<string, string> = { };\n    for (let key in transaction) {\n        if ((<any>transaction)[key] == null) { continue; }\n        let value = (<any>transaction)[key];\n        if (key === \"type\" && value === 0) { continue; }\n\n        // Quantity-types require no leading zero, unless 0\n        if ((<any>{ type: true, gasLimit: true, gasPrice: true, maxFeePerGs: true, maxPriorityFeePerGas: true, nonce: true, value: true })[key]) {\n            value = hexValue(hexlify(value));\n        } else if (key === \"accessList\") {\n            value = \"[\" + accessListify(value).map((set) => {\n                return `{address:\"${ set.address }\",storageKeys:[\"${ set.storageKeys.join('\",\"') }\"]}`;\n            }).join(\",\") + \"]\";\n        } else {\n            value = hexlify(value);\n        }\n        result[key] = value;\n    }\n    return result;\n}\n\nfunction getResult(result: { status?: number, message?: string, result?: any }): any {\n    // getLogs, getHistory have weird success responses\n    if (result.status == 0 && (result.message === \"No records found\" || result.message === \"No transactions found\")) {\n        return result.result;\n    }\n\n    if (result.status != 1 || result.message != \"OK\") {\n        const error: any = new Error(\"invalid response\");\n        error.result = JSON.stringify(result);\n        if ((result.result || \"\").toLowerCase().indexOf(\"rate limit\") >= 0) {\n            error.throttleRetry = true;\n        }\n        throw error;\n    }\n\n    return result.result;\n}\n\nfunction getJsonResult(result: { jsonrpc: string, result?: any, error?: { code?: number, data?: any, message?: string} } ): any {\n    // This response indicates we are being throttled\n    if (result && (<any>result).status == 0 && (<any>result).message == \"NOTOK\" && (result.result || \"\").toLowerCase().indexOf(\"rate limit\") >= 0) {\n        const error: any = new Error(\"throttled response\");\n        error.result = JSON.stringify(result);\n        error.throttleRetry = true;\n        throw error;\n    }\n\n    if (result.jsonrpc != \"2.0\") {\n        // @TODO: not any\n        const error: any = new Error(\"invalid response\");\n        error.result = JSON.stringify(result);\n        throw error;\n    }\n\n    if (result.error) {\n        // @TODO: not any\n        const error: any = new Error(result.error.message || \"unknown error\");\n        if (result.error.code) { error.code = result.error.code; }\n        if (result.error.data) { error.data = result.error.data; }\n        throw error;\n    }\n\n    return result.result;\n}\n\n// The blockTag was normalized as a string by the Provider pre-perform operations\nfunction checkLogTag(blockTag: string): number | \"latest\" {\n    if (blockTag === \"pending\") { throw new Error(\"pending not supported\"); }\n    if (blockTag === \"latest\") { return blockTag; }\n\n    return parseInt(blockTag.substring(2), 16);\n}\n\n\nconst defaultApiKey = \"9D13ZE7XSBTJ94N9BNJ2MA33VMAY2YPIRB\";\n\nfunction checkError(method: string, error: any, transaction: any): any {\n    // Undo the \"convenience\" some nodes are attempting to prevent backwards\n    // incompatibility; maybe for v6 consider forwarding reverts as errors\n    if (method === \"call\" && error.code === Logger.errors.SERVER_ERROR) {\n        const e = error.error;\n\n        // Etherscan keeps changing their string\n        if (e && (e.message.match(/reverted/i) || e.message.match(/VM execution error/i))) {\n            // Etherscan prefixes the data like \"Reverted 0x1234\"\n            let data = e.data;\n            if (data) { data = \"0x\" + data.replace(/^.*0x/i, \"\"); }\n\n            if (isHexString(data)) { return data; }\n\n            logger.throwError(\"missing revert data in call exception\", Logger.errors.CALL_EXCEPTION, {\n                error, data: \"0x\"\n            });\n        }\n    }\n\n    // Get the message from any nested error structure\n    let message = error.message;\n    if (error.code === Logger.errors.SERVER_ERROR) {\n        if (error.error && typeof(error.error.message) === \"string\") {\n            message = error.error.message;\n        } else if (typeof(error.body) === \"string\") {\n            message = error.body;\n        } else if (typeof(error.responseText) === \"string\") {\n            message = error.responseText;\n        }\n    }\n    message = (message || \"\").toLowerCase();\n\n    // \"Insufficient funds. The account you tried to send transaction from does not have enough funds. Required 21464000000000 and got: 0\"\n    if (message.match(/insufficient funds/)) {\n        logger.throwError(\"insufficient funds for intrinsic transaction cost\", Logger.errors.INSUFFICIENT_FUNDS, {\n           error, method, transaction\n        });\n    }\n\n    // \"Transaction with the same hash was already imported.\"\n    if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {\n        logger.throwError(\"nonce has already been used\", Logger.errors.NONCE_EXPIRED, {\n           error, method, transaction\n        });\n    }\n\n    // \"Transaction gas price is too low. There is another transaction with same nonce in the queue. Try increasing the gas price or incrementing the nonce.\"\n    if (message.match(/another transaction with same nonce/)) {\n         logger.throwError(\"replacement fee too low\", Logger.errors.REPLACEMENT_UNDERPRICED, {\n            error, method, transaction\n         });\n    }\n\n    if (message.match(/execution failed due to an exception|execution reverted/)) {\n        logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n            error, method, transaction\n        });\n    }\n\n    throw error;\n}\n\nexport class EtherscanProvider extends BaseProvider{\n    readonly baseUrl: string;\n    readonly apiKey: string;\n\n    constructor(network?: Networkish, apiKey?: string) {\n        logger.checkNew(new.target, EtherscanProvider);\n\n        super(network);\n\n        defineReadOnly(this, \"baseUrl\", this.getBaseUrl());\n        defineReadOnly(this, \"apiKey\", apiKey || defaultApiKey);\n    }\n\n    getBaseUrl(): string {\n        switch(this.network ? this.network.name: \"invalid\") {\n            case \"homestead\":\n                return \"https:/\\/api.etherscan.io\";\n            case \"ropsten\":\n                return \"https:/\\/api-ropsten.etherscan.io\";\n            case \"rinkeby\":\n                return \"https:/\\/api-rinkeby.etherscan.io\";\n            case \"kovan\":\n                return \"https:/\\/api-kovan.etherscan.io\";\n            case \"goerli\":\n                return \"https:/\\/api-goerli.etherscan.io\";\n            default:\n        }\n\n        return logger.throwArgumentError(\"unsupported network\", \"network\", name);\n    }\n\n    getUrl(module: string, params: Record<string, string>): string {\n        const query = Object.keys(params).reduce((accum, key) => {\n            const value = params[key];\n            if (value != null) {\n                accum += `&${ key }=${ value }`\n            }\n            return accum\n        }, \"\");\n        const apiKey = ((this.apiKey) ? `&apikey=${ this.apiKey }`: \"\");\n        return `${ this.baseUrl }/api?module=${ module }${ query }${ apiKey }`;\n    }\n\n    getPostUrl(): string {\n        return `${ this.baseUrl }/api`;\n    }\n\n    getPostData(module: string, params: Record<string, any>): Record<string, any> {\n        params.module = module;\n        params.apikey = this.apiKey;\n        return params;\n    }\n\n    async fetch(module: string, params: Record<string, any>, post?: boolean): Promise<any> {\n        const url = (post ? this.getPostUrl(): this.getUrl(module, params));\n        const payload = (post ? this.getPostData(module, params): null);\n        const procFunc = (module === \"proxy\") ? getJsonResult: getResult;\n\n        this.emit(\"debug\", {\n            action: \"request\",\n            request: url,\n            provider: this\n        });\n\n        const connection: ConnectionInfo = {\n            url: url,\n            throttleSlotInterval: 1000,\n            throttleCallback: (attempt: number, url: string) => {\n                if (this.isCommunityResource()) {\n                    showThrottleMessage();\n                }\n                return Promise.resolve(true);\n            }\n        };\n\n        let payloadStr: string = null;\n        if (payload) {\n            connection.headers = { \"content-type\": \"application/x-www-form-urlencoded; charset=UTF-8\" };\n            payloadStr = Object.keys(payload).map((key) => {\n                return `${ key }=${ payload[key] }`\n            }).join(\"&\");\n        }\n\n        const result = await fetchJson(connection, payloadStr, procFunc || getJsonResult);\n\n        this.emit(\"debug\", {\n            action: \"response\",\n            request: url,\n            response: deepCopy(result),\n            provider: this\n        });\n\n        return result;\n    }\n\n    async detectNetwork(): Promise<Network> {\n        return this.network;\n    }\n\n    async perform(method: string, params: any): Promise<any> {\n\n        switch (method) {\n            case \"getBlockNumber\":\n                return this.fetch(\"proxy\", { action: \"eth_blockNumber\" });\n\n            case \"getGasPrice\":\n                return this.fetch(\"proxy\", { action: \"eth_gasPrice\" });\n\n            case \"getBalance\":\n                // Returns base-10 result\n                return this.fetch(\"account\", {\n                    action: \"balance\",\n                    address: params.address,\n                    tag: params.blockTag\n                });\n\n            case \"getTransactionCount\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_getTransactionCount\",\n                    address: params.address,\n                    tag: params.blockTag\n                });\n\n            case \"getCode\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_getCode\",\n                    address: params.address,\n                    tag: params.blockTag\n                });\n\n            case \"getStorageAt\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_getStorageAt\",\n                    address: params.address,\n                    position: params.position,\n                    tag: params.blockTag\n                });\n\n            case \"sendTransaction\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_sendRawTransaction\",\n                    hex: params.signedTransaction\n                }, true).catch((error) => {\n                    return checkError(\"sendTransaction\", error, params.signedTransaction);\n                });\n\n            case \"getBlock\":\n                if (params.blockTag) {\n                    return this.fetch(\"proxy\", {\n                        action: \"eth_getBlockByNumber\",\n                        tag: params.blockTag,\n                        boolean: (params.includeTransactions ? \"true\": \"false\")\n                    });\n                }\n                throw new Error(\"getBlock by blockHash not implemented\");\n\n            case \"getTransaction\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_getTransactionByHash\",\n                    txhash: params.transactionHash\n                });\n\n            case \"getTransactionReceipt\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_getTransactionReceipt\",\n                    txhash: params.transactionHash\n                });\n\n            case \"call\": {\n                if (params.blockTag !== \"latest\") {\n                    throw new Error(\"EtherscanProvider does not support blockTag for call\");\n                }\n\n                const postData = getTransactionPostData(params.transaction);\n                postData.module = \"proxy\";\n                postData.action = \"eth_call\";\n\n                try {\n                    return await this.fetch(\"proxy\", postData, true);\n                } catch (error) {\n                    return checkError(\"call\", error, params.transaction);\n                }\n            }\n\n            case \"estimateGas\": {\n                const postData = getTransactionPostData(params.transaction);\n                postData.module = \"proxy\";\n                postData.action = \"eth_estimateGas\";\n\n                try {\n                    return await this.fetch(\"proxy\", postData, true);\n                } catch (error) {\n                    return checkError(\"estimateGas\", error, params.transaction);\n                }\n            }\n\n            case \"getLogs\": {\n                const args: Record<string, any> = { action: \"getLogs\" }\n\n                if (params.filter.fromBlock) {\n                    args.fromBlock = checkLogTag(params.filter.fromBlock);\n                }\n\n                if (params.filter.toBlock) {\n                    args.toBlock = checkLogTag(params.filter.toBlock);\n                }\n\n                if (params.filter.address) {\n                    args.address = params.filter.address;\n                }\n\n                // @TODO: We can handle slightly more complicated logs using the logs API\n                if (params.filter.topics && params.filter.topics.length > 0) {\n                    if (params.filter.topics.length > 1) {\n                        logger.throwError(\"unsupported topic count\", Logger.errors.UNSUPPORTED_OPERATION, { topics: params.filter.topics });\n                    }\n\n                    if (params.filter.topics.length === 1) {\n                        const topic0 = params.filter.topics[0];\n                        if (typeof(topic0) !== \"string\" || topic0.length !== 66) {\n                            logger.throwError(\"unsupported topic format\", Logger.errors.UNSUPPORTED_OPERATION, { topic0: topic0 });\n                        }\n                        args.topic0 = topic0;\n                    }\n                }\n\n                const logs: Array<any> = await this.fetch(\"logs\", args);\n\n                // Cache txHash => blockHash\n                let blocks: { [tag: string]: string } = {};\n\n                // Add any missing blockHash to the logs\n                for (let i = 0; i < logs.length; i++) {\n                    const log = logs[i];\n                    if (log.blockHash != null) { continue; }\n                    if (blocks[log.blockNumber] == null) {\n                        const block = await this.getBlock(log.blockNumber);\n                        if (block) {\n                            blocks[log.blockNumber] = block.hash;\n                        }\n                    }\n                    log.blockHash = blocks[log.blockNumber];\n                }\n\n                return logs;\n            }\n\n            case \"getEtherPrice\":\n                if (this.network.name !== \"homestead\") { return 0.0; }\n                return parseFloat((await this.fetch(\"stats\", { action: \"ethprice\" })).ethusd);\n\n            default:\n                break;\n         }\n\n        return super.perform(method, params);\n    }\n\n    // Note: The `page` page parameter only allows pagination within the\n    //       10,000 window available without a page and offset parameter\n    //       Error: Result window is too large, PageNo x Offset size must\n    //              be less than or equal to 10000\n    async getHistory(addressOrName: string | Promise<string>, startBlock?: BlockTag, endBlock?: BlockTag): Promise<Array<TransactionResponse>> {\n        const params = {\n            action: \"txlist\",\n            address: (await this.resolveName(addressOrName)),\n            startblock: ((startBlock == null) ? 0: startBlock),\n            endblock: ((endBlock == null) ? 99999999: endBlock),\n            sort: \"asc\"\n        };\n\n        const result = await this.fetch(\"account\", params);\n\n        return result.map((tx: any) => {\n            [\"contractAddress\", \"to\"].forEach(function(key) {\n                if (tx[key] == \"\") { delete tx[key]; }\n            });\n            if (tx.creates == null && tx.contractAddress != null) {\n                tx.creates = tx.contractAddress;\n            }\n            const item = this.formatter.transactionResponse(tx);\n            if (tx.timeStamp) { item.timestamp = parseInt(tx.timeStamp); }\n            return item;\n        });\n    }\n\n    isCommunityResource(): boolean {\n        return (this.apiKey === defaultApiKey);\n    }\n}\n","\"use strict\";\n\nexport function shuffled(array: Array<any>): Array<any> {\n    array = array.slice();\n\n    for (let i = array.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        const tmp = array[i];\n        array[i] = array[j];\n        array[j] = tmp;\n    }\n\n    return array;\n}\n","\"use strict\";\n\nimport { Block, BlockWithTransactions, Provider } from \"@ethersproject/abstract-provider\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { isHexString } from \"@ethersproject/bytes\";\nimport { Network } from \"@ethersproject/networks\";\nimport { deepCopy, defineReadOnly, shallowCopy } from \"@ethersproject/properties\";\nimport { shuffled } from \"@ethersproject/random\";\nimport { poll } from \"@ethersproject/web\";\n\nimport { BaseProvider } from \"./base-provider\";\nimport { isCommunityResource } from \"./formatter\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nfunction now() { return (new Date()).getTime(); }\n\n// Returns to network as long as all agree, or null if any is null.\n// Throws an error if any two networks do not match.\nfunction checkNetworks(networks: Array<Network>): Network {\n    let result = null;\n\n    for (let i = 0; i < networks.length; i++) {\n        const network = networks[i];\n\n        // Null! We do not know our network; bail.\n        if (network == null) { return null; }\n\n        if (result) {\n            // Make sure the network matches the previous networks\n            if (!(result.name === network.name && result.chainId === network.chainId &&\n                ((result.ensAddress === network.ensAddress) || (result.ensAddress == null && network.ensAddress == null)))) {\n\n                logger.throwArgumentError(\"provider mismatch\", \"networks\", networks);\n           }\n        } else {\n            result = network;\n        }\n    }\n\n    return result;\n}\n\nfunction median(values: Array<number>, maxDelta?: number): number {\n    values = values.slice().sort();\n    const middle = Math.floor(values.length / 2);\n\n    // Odd length; take the middle\n    if (values.length % 2) {\n        return values[middle];\n    }\n\n    // Even length; take the average of the two middle\n    const a = values[middle - 1], b = values[middle];\n\n    if (maxDelta != null && Math.abs(a - b) > maxDelta) {\n        return null;\n    }\n\n    return (a + b) / 2;\n}\n\nfunction serialize(value: any): string {\n    if (value === null) {\n        return \"null\";\n    } else if (typeof(value) === \"number\" || typeof(value) === \"boolean\") {\n        return JSON.stringify(value);\n    } else if (typeof(value) === \"string\") {\n        return value;\n    } else if (BigNumber.isBigNumber(value)) {\n        return value.toString();\n    } else if (Array.isArray(value)) {\n        return JSON.stringify(value.map((i) => serialize(i)));\n    } else if (typeof(value) === \"object\") {\n        const keys = Object.keys(value);\n        keys.sort();\n        return \"{\" + keys.map((key) => {\n            let v = value[key];\n            if (typeof(v) === \"function\") {\n                v = \"[function]\";\n            } else {\n                v = serialize(v);\n            }\n            return JSON.stringify(key) + \":\" + v;\n        }).join(\",\") + \"}\";\n    }\n\n    throw new Error(\"unknown value type: \" + typeof(value));\n}\n\n// Next request ID to use for emitting debug info\nlet nextRid = 1;\n\n\nexport interface FallbackProviderConfig {\n    // The Provider\n    provider: Provider;\n\n    // The priority to favour this Provider; lower values are used first (higher priority)\n    priority?: number;\n\n    // Timeout before also triggering the next provider; this does not stop\n    // this provider and if its result comes back before a quorum is reached\n    // it will be incorporated into the vote\n    // - lower values will cause more network traffic but may result in a\n    //   faster result.\n    stallTimeout?: number;\n\n    // How much this provider contributes to the quorum; sometimes a specific\n    // provider may be more reliable or trustworthy than others, but usually\n    // this should be left as the default\n    weight?: number;\n};\n\n// A Staller is used to provide a delay to give a Provider a chance to response\n// before asking the next Provider to try.\ntype Staller = {\n    wait: (func: () => void) => Promise<void>\n    getPromise: () => Promise<void>,\n    cancel: () => void\n};\n\nfunction stall(duration: number): Staller {\n    let cancel: () => void = null;\n\n    let timer: NodeJS.Timer = null;\n    let promise = <Promise<void>>(new Promise((resolve) => {\n        cancel = function() {\n            if (timer) {\n                clearTimeout(timer);\n                timer = null;\n            }\n            resolve();\n        }\n        timer = setTimeout(cancel, duration);\n    }));\n\n    const wait = (func: () => void) => {\n        promise = promise.then(func);\n        return promise;\n    }\n\n    function getPromise(): Promise<void> {\n        return promise;\n    }\n\n    return { cancel, getPromise, wait };\n}\n\nconst ForwardErrors = [\n    Logger.errors.CALL_EXCEPTION,\n    Logger.errors.INSUFFICIENT_FUNDS,\n    Logger.errors.NONCE_EXPIRED,\n    Logger.errors.REPLACEMENT_UNDERPRICED,\n    Logger.errors.UNPREDICTABLE_GAS_LIMIT\n];\n\nconst ForwardProperties = [\n    \"address\",\n    \"args\",\n    \"errorArgs\",\n    \"errorSignature\",\n    \"method\",\n    \"transaction\",\n];\n\n\n// @TODO: Make this an object with staller and cancel built-in\ninterface RunningConfig extends FallbackProviderConfig {\n    start?: number;\n    done?: boolean;\n    cancelled?: boolean;\n    runner?: Promise<any>;\n    staller?: Staller;\n    result?: any;\n    error?: Error;\n};\n\nfunction exposeDebugConfig(config: RunningConfig, now?: number): any {\n    const result: any = {\n        weight: config.weight\n    };\n    Object.defineProperty(result, \"provider\", { get: () => config.provider });\n    if (config.start) { result.start = config.start; }\n    if (now) { result.duration = (now - config.start); }\n    if (config.done) {\n        if (config.error) {\n            result.error = config.error;\n        } else {\n            result.result = config.result || null;\n        }\n    }\n    return result;\n}\n\nfunction normalizedTally(normalize: (value: any) => string, quorum: number): (configs: Array<RunningConfig>) => any {\n    return function(configs: Array<RunningConfig>): any {\n\n        // Count the votes for each result\n        const tally: { [ key: string]: { count: number, result: any } } = { };\n        configs.forEach((c) => {\n            const value = normalize(c.result);\n            if (!tally[value]) { tally[value] = { count: 0, result: c.result }; }\n            tally[value].count++;\n        });\n\n        // Check for a quorum on any given result\n        const keys = Object.keys(tally);\n        for (let i = 0; i < keys.length; i++) {\n            const check = tally[keys[i]];\n            if (check.count >= quorum) {\n                return check.result;\n            }\n        }\n\n        // No quroum\n        return undefined;\n    }\n}\nfunction getProcessFunc(provider: FallbackProvider, method: string, params: { [ key: string ]: any }): (configs: Array<RunningConfig>) => any {\n\n    let normalize = serialize;\n\n    switch (method) {\n        case \"getBlockNumber\":\n            // Return the median value, unless there is (median + 1) is also\n            // present, in which case that is probably true and the median\n            // is going to be stale soon. In the event of a malicious node,\n            // the lie will be true soon enough.\n            return function(configs: Array<RunningConfig>): number {\n                const values = configs.map((c) => c.result);\n\n                // Get the median block number\n                let blockNumber = median(configs.map((c) => c.result), 2);\n                if (blockNumber == null) { return undefined; }\n\n                blockNumber = Math.ceil(blockNumber);\n\n                // If the next block height is present, its prolly safe to use\n                if (values.indexOf(blockNumber + 1) >= 0) { blockNumber++; }\n\n                // Don't ever roll back the blockNumber\n                if (blockNumber >= provider._highestBlockNumber) {\n                    provider._highestBlockNumber = blockNumber;\n                }\n\n                return provider._highestBlockNumber;\n            };\n\n        case \"getGasPrice\":\n            // Return the middle (round index up) value, similar to median\n            // but do not average even entries and choose the higher.\n            // Malicious actors must compromise 50% of the nodes to lie.\n            return function(configs: Array<RunningConfig>): BigNumber {\n                const values = configs.map((c) => c.result);\n                values.sort();\n                return values[Math.floor(values.length / 2)];\n            }\n\n        case \"getEtherPrice\":\n            // Returns the median price. Malicious actors must compromise at\n            // least 50% of the nodes to lie (in a meaningful way).\n            return function(configs: Array<RunningConfig>): number {\n                return median(configs.map((c) => c.result));\n            }\n\n        // No additional normalizing required; serialize is enough\n        case \"getBalance\":\n        case \"getTransactionCount\":\n        case \"getCode\":\n        case \"getStorageAt\":\n        case \"call\":\n        case \"estimateGas\":\n        case \"getLogs\":\n            break;\n\n        // We drop the confirmations from transactions as it is approximate\n        case \"getTransaction\":\n        case \"getTransactionReceipt\":\n            normalize = function(tx: any): string {\n                if (tx == null) { return null; }\n\n                tx = shallowCopy(tx);\n                tx.confirmations = -1;\n                return serialize(tx);\n            }\n            break;\n\n        // We drop the confirmations from transactions as it is approximate\n        case \"getBlock\":\n            // We drop the confirmations from transactions as it is approximate\n            if (params.includeTransactions) {\n                normalize = function(block: BlockWithTransactions): string {\n                    if (block == null) { return null; }\n\n                    block = shallowCopy(block);\n                    block.transactions = block.transactions.map((tx) => {\n                        tx = shallowCopy(tx);\n                        tx.confirmations = -1;\n                        return tx;\n                    });\n                    return serialize(block);\n                };\n            } else {\n                normalize = function(block: Block): string {\n                    if (block == null) { return null; }\n                    return serialize(block);\n                }\n            }\n            break;\n\n        default:\n            throw new Error(\"unknown method: \" + method);\n    }\n\n    // Return the result if and only if the expected quorum is\n    // satisfied and agreed upon for the final result.\n    return normalizedTally(normalize, provider.quorum);\n\n}\n\n// If we are doing a blockTag query, we need to make sure the backend is\n// caught up to the FallbackProvider, before sending a request to it.\nasync function waitForSync(config: RunningConfig, blockNumber: number): Promise<BaseProvider> {\n    const provider = <BaseProvider>(config.provider);\n\n    if ((provider.blockNumber != null && provider.blockNumber >= blockNumber) || blockNumber === -1) {\n        return provider;\n    }\n\n    return poll(() => {\n        return new Promise((resolve, reject) => {\n            setTimeout(function() {\n\n                // We are synced\n                if (provider.blockNumber >= blockNumber) { return resolve(provider); }\n\n                // We're done; just quit\n                if (config.cancelled) { return resolve(null); }\n\n                // Try again, next block\n                return resolve(undefined);\n            }, 0);\n        });\n    }, { oncePoll: provider });\n}\n\nasync function getRunner(config: RunningConfig, currentBlockNumber: number, method: string, params: { [ key: string]: any }): Promise<any> {\n    let provider = config.provider;\n\n    switch (method) {\n        case \"getBlockNumber\":\n        case \"getGasPrice\":\n            return provider[method]();\n        case \"getEtherPrice\":\n            if ((<any>provider).getEtherPrice) {\n                return (<any>provider).getEtherPrice();\n            }\n            break;\n        case \"getBalance\":\n        case \"getTransactionCount\":\n        case \"getCode\":\n            if (params.blockTag && isHexString(params.blockTag)) {\n                provider = await waitForSync(config, currentBlockNumber)\n            }\n            return provider[method](params.address, params.blockTag || \"latest\");\n        case \"getStorageAt\":\n            if (params.blockTag && isHexString(params.blockTag)) {\n                provider = await waitForSync(config, currentBlockNumber)\n            }\n            return provider.getStorageAt(params.address, params.position, params.blockTag || \"latest\");\n        case \"getBlock\":\n            if (params.blockTag && isHexString(params.blockTag)) {\n                provider = await waitForSync(config, currentBlockNumber)\n            }\n            return provider[(params.includeTransactions ? \"getBlockWithTransactions\": \"getBlock\")](params.blockTag || params.blockHash);\n        case \"call\":\n        case \"estimateGas\":\n            if (params.blockTag && isHexString(params.blockTag)) {\n                provider = await waitForSync(config, currentBlockNumber)\n            }\n            return provider[method](params.transaction);\n        case \"getTransaction\":\n        case \"getTransactionReceipt\":\n            return provider[method](params.transactionHash);\n        case \"getLogs\": {\n            let filter = params.filter;\n            if ((filter.fromBlock && isHexString(filter.fromBlock)) || (filter.toBlock && isHexString(filter.toBlock))) {\n                provider = await waitForSync(config, currentBlockNumber)\n            }\n            return provider.getLogs(filter);\n        }\n    }\n\n    return logger.throwError(\"unknown method error\", Logger.errors.UNKNOWN_ERROR, {\n        method: method,\n        params: params\n    });\n}\n\nexport class FallbackProvider extends BaseProvider {\n    readonly providerConfigs: ReadonlyArray<FallbackProviderConfig>;\n    readonly quorum: number;\n\n    // Due to the highly asyncronous nature of the blockchain, we need\n    // to make sure we never unroll the blockNumber due to our random\n    // sample of backends\n    _highestBlockNumber: number;\n\n    constructor(providers: Array<Provider | FallbackProviderConfig>, quorum?: number) {\n        logger.checkNew(new.target, FallbackProvider);\n\n        if (providers.length === 0) {\n            logger.throwArgumentError(\"missing providers\", \"providers\", providers);\n        }\n\n        const providerConfigs: Array<FallbackProviderConfig> = providers.map((configOrProvider, index) => {\n            if (Provider.isProvider(configOrProvider)) {\n                const stallTimeout = isCommunityResource(configOrProvider) ? 2000: 750;\n                const priority = 1;\n                return Object.freeze({ provider: configOrProvider, weight: 1, stallTimeout, priority });\n            }\n\n            const config: FallbackProviderConfig = shallowCopy(configOrProvider);\n\n            if (config.priority == null) { config.priority = 1; }\n            if (config.stallTimeout == null) {\n                config.stallTimeout = isCommunityResource(configOrProvider) ? 2000: 750;\n            }\n            if (config.weight == null) { config.weight = 1; }\n\n            const weight = config.weight;\n            if (weight % 1 || weight > 512 || weight < 1) {\n                logger.throwArgumentError(\"invalid weight; must be integer in [1, 512]\", `providers[${ index }].weight`, weight);\n            }\n\n            return Object.freeze(config);\n        });\n\n        const total = providerConfigs.reduce((accum, c) => (accum + c.weight), 0);\n\n        if (quorum == null) {\n            quorum = total / 2;\n        } else if (quorum > total) {\n            logger.throwArgumentError(\"quorum will always fail; larger than total weight\", \"quorum\", quorum);\n        }\n\n        // Are all providers' networks are known\n        let networkOrReady: Network | Promise<Network> = checkNetworks(providerConfigs.map((c) => (<any>(c.provider)).network));\n\n        // Not all networks are known; we must stall\n        if (networkOrReady == null) {\n            networkOrReady = new Promise((resolve, reject) => {\n                setTimeout(() => {\n                    this.detectNetwork().then(resolve, reject);\n                }, 0);\n            });\n        }\n\n        super(networkOrReady);\n\n        // Preserve a copy, so we do not get mutated\n        defineReadOnly(this, \"providerConfigs\", Object.freeze(providerConfigs));\n        defineReadOnly(this, \"quorum\", quorum);\n\n        this._highestBlockNumber = -1;\n    }\n\n    async detectNetwork(): Promise<Network> {\n        const networks = await Promise.all(this.providerConfigs.map((c) => c.provider.getNetwork()));\n        return checkNetworks(networks);\n    }\n\n    async perform(method: string, params: { [name: string]: any }): Promise<any> {\n        // Sending transactions is special; always broadcast it to all backends\n        if (method === \"sendTransaction\") {\n            const results: Array<string | Error> = await Promise.all(this.providerConfigs.map((c) => {\n                return c.provider.sendTransaction(params.signedTransaction).then((result) => {\n                    return result.hash;\n                }, (error) => {\n                    return error;\n                });\n            }));\n\n            // Any success is good enough (other errors are likely \"already seen\" errors\n            for (let i = 0; i < results.length; i++) {\n                const result = results[i];\n                if (typeof(result) === \"string\") { return result; }\n            }\n\n            // They were all an error; pick the first error\n            throw results[0];\n        }\n\n        // We need to make sure we are in sync with our backends, so we need\n        // to know this before we can make a lot of calls\n        if (this._highestBlockNumber === -1 && method !== \"getBlockNumber\") {\n            await this.getBlockNumber();\n        }\n\n        const processFunc = getProcessFunc(this, method, params);\n\n        // Shuffle the providers and then sort them by their priority; we\n        // shallowCopy them since we will store the result in them too\n        const configs: Array<RunningConfig> = shuffled(this.providerConfigs.map(shallowCopy));\n        configs.sort((a, b) => (a.priority - b.priority));\n\n        const currentBlockNumber = this._highestBlockNumber;\n\n        let i = 0;\n        let first = true;\n        while (true) {\n            const t0 = now();\n\n            // Compute the inflight weight (exclude anything past)\n            let inflightWeight = configs.filter((c) => (c.runner && ((t0 - c.start) < c.stallTimeout)))\n                                        .reduce((accum, c) => (accum + c.weight), 0);\n\n            // Start running enough to meet quorum\n            while (inflightWeight < this.quorum && i < configs.length) {\n                const config = configs[i++];\n\n                const rid = nextRid++;\n\n                config.start = now();\n                config.staller = stall(config.stallTimeout);\n                config.staller.wait(() => { config.staller = null; });\n\n                config.runner = getRunner(config, currentBlockNumber, method, params).then((result) => {\n                    config.done = true;\n                    config.result = result;\n\n                    if (this.listenerCount(\"debug\")) {\n                        this.emit(\"debug\", {\n                            action: \"request\",\n                            rid: rid,\n                            backend: exposeDebugConfig(config, now()),\n                            request: { method: method, params: deepCopy(params) },\n                            provider: this\n                        });\n                     }\n\n                }, (error) => {\n                    config.done = true;\n                    config.error = error;\n\n                    if (this.listenerCount(\"debug\")) {\n                        this.emit(\"debug\", {\n                            action: \"request\",\n                            rid: rid,\n                            backend: exposeDebugConfig(config, now()),\n                            request: { method: method, params: deepCopy(params) },\n                            provider: this\n                        });\n                    }\n                });\n\n                if (this.listenerCount(\"debug\")) {\n                    this.emit(\"debug\", {\n                        action: \"request\",\n                        rid: rid,\n                        backend: exposeDebugConfig(config, null),\n                        request: { method: method, params: deepCopy(params) },\n                        provider: this\n                    });\n                }\n\n                inflightWeight += config.weight;\n            }\n\n            // Wait for anything meaningful to finish or stall out\n            const waiting: Array<Promise<any>> = [ ];\n            configs.forEach((c) => {\n                if (c.done || !c.runner) { return; }\n                waiting.push(c.runner);\n                if (c.staller) { waiting.push(c.staller.getPromise()); }\n            });\n\n            if (waiting.length) { await Promise.race(waiting); }\n\n            // Check the quorum and process the results; the process function\n            // may additionally decide the quorum is not met\n            const results = configs.filter((c) => (c.done && c.error == null));\n            if (results.length >= this.quorum) {\n                const result = processFunc(results);\n                if (result !== undefined) {\n                    // Shut down any stallers\n                    configs.forEach(c => {\n                        if (c.staller) { c.staller.cancel(); }\n                        c.cancelled = true;\n                    });\n                    return result;\n                }\n                if (!first) { await stall(100).getPromise(); }\n                first = false;\n            }\n\n            // No result, check for errors that should be forwarded\n            const errors = configs.reduce((accum, c) => {\n                if (!c.done || c.error == null) { return accum; }\n\n                const code = (<any>(c.error)).code;\n                if (ForwardErrors.indexOf(code) >= 0) {\n                    if (!accum[code]) { accum[code] = { error: c.error, weight: 0 }; }\n                    accum[code].weight += c.weight;\n                }\n\n                return accum;\n            }, <{ [ code: string ]: { error: Error, weight: number } }>({ }));\n\n            Object.keys(errors).forEach((errorCode: string) => {\n                const tally = errors[errorCode];\n                if (tally.weight < this.quorum) { return; }\n\n                // Shut down any stallers\n                configs.forEach(c => {\n                    if (c.staller) { c.staller.cancel(); }\n                    c.cancelled = true;\n                });\n\n                const e = <any>(tally.error);\n\n                const props: { [ name: string ]: any } = { };\n                ForwardProperties.forEach((name) => {\n                    if (e[name] == null) { return; }\n                    props[name] = e[name];\n                });\n\n                logger.throwError(e.reason || e.message, <any>errorCode, props);\n            });\n\n            // All configs have run to completion; we will never get more data\n            if (configs.filter((c) => !c.done).length === 0) { break; }\n        }\n\n        // Shut down any stallers; shouldn't be any\n        configs.forEach(c => {\n            if (c.staller) { c.staller.cancel(); }\n            c.cancelled = true;\n        });\n\n        return logger.throwError(\"failed to meet quorum\", Logger.errors.SERVER_ERROR, {\n            method: method,\n            params: params,\n            //results: configs.map((c) => c.result),\n            //errors: configs.map((c) => c.error),\n            results: configs.map((c) => exposeDebugConfig(c)),\n            provider: this\n        });\n    }\n}\n","\"use strict\";\n\nconst IpcProvider: any = null;\n\nexport {\n    IpcProvider\n};\n","\"use strict\";\n\nimport { Network, Networkish } from \"@ethersproject/networks\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { ConnectionInfo } from \"@ethersproject/web\";\n\nimport { WebSocketProvider } from \"./websocket-provider\";\nimport { CommunityResourcable, showThrottleMessage } from \"./formatter\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\n\n\nconst defaultProjectId = \"84842078b09946638c03157f83405213\"\n\nexport class InfuraWebSocketProvider extends WebSocketProvider implements CommunityResourcable {\n    readonly apiKey: string;\n    readonly projectId: string;\n    readonly projectSecret: string;\n\n    constructor(network?: Networkish, apiKey?: any) {\n        const provider = new InfuraProvider(network, apiKey);\n        const connection = provider.connection;\n        if (connection.password) {\n            logger.throwError(\"INFURA WebSocket project secrets unsupported\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"InfuraProvider.getWebSocketProvider()\"\n            });\n        }\n\n        const url = connection.url.replace(/^http/i, \"ws\").replace(\"/v3/\", \"/ws/v3/\");\n        super(url, network);\n\n        defineReadOnly(this, \"apiKey\", provider.projectId);\n        defineReadOnly(this, \"projectId\", provider.projectId);\n        defineReadOnly(this, \"projectSecret\", provider.projectSecret);\n    }\n\n    isCommunityResource(): boolean {\n        return (this.projectId === defaultProjectId);\n    }\n}\n\nexport class InfuraProvider extends UrlJsonRpcProvider {\n    readonly projectId: string;\n    readonly projectSecret: string;\n\n    static getWebSocketProvider(network?: Networkish, apiKey?: any): InfuraWebSocketProvider {\n        return new InfuraWebSocketProvider(network, apiKey);\n    }\n\n    static getApiKey(apiKey: any): any {\n        const apiKeyObj: { apiKey: string, projectId: string, projectSecret: string } = {\n            apiKey: defaultProjectId,\n            projectId: defaultProjectId,\n            projectSecret: null\n        };\n\n        if (apiKey == null) { return apiKeyObj; }\n\n        if (typeof(apiKey) === \"string\") {\n            apiKeyObj.projectId = apiKey;\n\n        } else if (apiKey.projectSecret != null) {\n            logger.assertArgument((typeof(apiKey.projectId) === \"string\"),\n                \"projectSecret requires a projectId\", \"projectId\", apiKey.projectId);\n            logger.assertArgument((typeof(apiKey.projectSecret) === \"string\"),\n                \"invalid projectSecret\", \"projectSecret\", \"[REDACTED]\");\n\n            apiKeyObj.projectId = apiKey.projectId;\n            apiKeyObj.projectSecret = apiKey.projectSecret;\n\n        } else if (apiKey.projectId) {\n            apiKeyObj.projectId = apiKey.projectId;\n        }\n\n        apiKeyObj.apiKey = apiKeyObj.projectId;\n\n        return apiKeyObj;\n    }\n\n    static getUrl(network: Network, apiKey: any): ConnectionInfo {\n        let host: string = null;\n        switch(network ? network.name: \"unknown\") {\n            case \"homestead\":\n                host = \"mainnet.infura.io\";\n                break;\n            case \"ropsten\":\n                host = \"ropsten.infura.io\";\n                break;\n            case \"rinkeby\":\n                host = \"rinkeby.infura.io\";\n                break;\n            case \"kovan\":\n                host = \"kovan.infura.io\";\n                break;\n            case \"goerli\":\n                host = \"goerli.infura.io\";\n                break;\n            case \"matic\":\n                host = \"polygon-mainnet.infura.io\";\n                break;\n            case \"maticmum\":\n                host = \"polygon-mumbai.infura.io\";\n                break;\n            case \"optimism\":\n                host = \"optimism-mainnet.infura.io\";\n                break;\n            case \"optimism-kovan\":\n                host = \"optimism-kovan.infura.io\";\n                break;\n            case \"arbitrum\":\n                host = \"arbitrum-mainnet.infura.io\";\n                break;\n            case \"arbitrum-rinkeby\":\n                host = \"arbitrum-rinkeby.infura.io\";\n                break;\n            default:\n                logger.throwError(\"unsupported network\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"network\",\n                    value: network\n                });\n        }\n\n        const connection: ConnectionInfo = {\n            allowGzip: true,\n            url: (\"https:/\" + \"/\" + host + \"/v3/\" + apiKey.projectId),\n            throttleCallback: (attempt: number, url: string) => {\n                if (apiKey.projectId === defaultProjectId) {\n                    showThrottleMessage();\n                }\n                return Promise.resolve(true);\n            }\n        };\n\n        if (apiKey.projectSecret != null) {\n            connection.user = \"\";\n            connection.password = apiKey.projectSecret\n        }\n\n        return connection;\n    }\n\n    isCommunityResource(): boolean {\n        return (this.projectId === defaultProjectId);\n    }\n}\n","\nimport { deepCopy } from \"@ethersproject/properties\";\nimport { fetchJson } from \"@ethersproject/web\";\n\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\n\n// Experimental\n\nexport class JsonRpcBatchProvider extends JsonRpcProvider {\n    _pendingBatchAggregator: NodeJS.Timer;\n    _pendingBatch: Array<{\n        request: { method: string, params: Array<any>, id: number, jsonrpc: \"2.0\" },\n        resolve: (result: any) => void,\n        reject: (error: Error) => void\n    }>;\n\n    send(method: string, params: Array<any>): Promise<any> {\n        const request = {\n            method: method,\n            params: params,\n            id: (this._nextId++),\n            jsonrpc: \"2.0\"\n        };\n\n        if (this._pendingBatch == null) {\n            this._pendingBatch = [ ];\n        }\n\n        const inflightRequest: any = { request, resolve: null, reject: null };\n\n        const promise = new Promise((resolve, reject) => {\n            inflightRequest.resolve = resolve;\n            inflightRequest.reject = reject;\n        });\n\n        this._pendingBatch.push(inflightRequest);\n\n        if (!this._pendingBatchAggregator) {\n            // Schedule batch for next event loop + short duration\n            this._pendingBatchAggregator = setTimeout(() => {\n\n                // Get teh current batch and clear it, so new requests\n                // go into the next batch\n                const batch = this._pendingBatch;\n                this._pendingBatch = null;\n                this._pendingBatchAggregator = null;\n\n                // Get the request as an array of requests\n                const request = batch.map((inflight) => inflight.request);\n\n                this.emit(\"debug\", {\n                    action: \"requestBatch\",\n                    request: deepCopy(request),\n                    provider: this\n                });\n\n                return fetchJson(this.connection, JSON.stringify(request)).then((result) => {\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        request: request,\n                        response: result,\n                        provider: this\n                    });\n\n                    // For each result, feed it to the correct Promise, depending\n                    // on whether it was a success or error\n                    batch.forEach((inflightRequest, index) => {\n                        const payload = result[index];\n                        if (payload.error) {\n                            const error = new Error(payload.error.message);\n                            (<any>error).code = payload.error.code;\n                            (<any>error).data = payload.error.data;\n                            inflightRequest.reject(error);\n                        } else {\n                            inflightRequest.resolve(payload.result);\n                        }\n                    });\n\n                }, (error) => {\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        error: error,\n                        request: request,\n                        provider: this\n                    });\n\n                    batch.forEach((inflightRequest) => {\n                        inflightRequest.reject(error);\n                    });\n                });\n\n            }, 10);\n        }\n\n        return promise;\n    }\n}\n","/* istanbul ignore file */\n\n\"use strict\";\n\nimport { Network } from \"@ethersproject/networks\";\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n// Special API key provided by Nodesmith for ethers.js\nconst defaultApiKey = \"ETHERS_JS_SHARED\";\n\nexport class NodesmithProvider extends UrlJsonRpcProvider {\n\n    static getApiKey(apiKey: any): any {\n        if (apiKey && typeof(apiKey) !== \"string\") {\n            logger.throwArgumentError(\"invalid apiKey\", \"apiKey\", apiKey);\n        }\n        return apiKey || defaultApiKey;\n    }\n\n    static getUrl(network: Network, apiKey?: any): string {\n        logger.warn(\"NodeSmith will be discontinued on 2019-12-20; please migrate to another platform.\");\n\n        let host = null;\n        switch (network.name) {\n            case \"homestead\":\n                host = \"https://ethereum.api.nodesmith.io/v1/mainnet/jsonrpc\";\n                break;\n            case \"ropsten\":\n                host = \"https://ethereum.api.nodesmith.io/v1/ropsten/jsonrpc\";\n                break;\n            case \"rinkeby\":\n                host = \"https://ethereum.api.nodesmith.io/v1/rinkeby/jsonrpc\";\n                break;\n            case \"goerli\":\n                host = \"https://ethereum.api.nodesmith.io/v1/goerli/jsonrpc\";\n                break;\n            case \"kovan\":\n                host = \"https://ethereum.api.nodesmith.io/v1/kovan/jsonrpc\";\n                break;\n            default:\n               logger.throwArgumentError(\"unsupported network\", \"network\", arguments[0]);\n        }\n\n        return (host + \"?apiKey=\" + apiKey);\n    }\n}\n","\"use strict\";\n\nimport { Network, Networkish } from \"@ethersproject/networks\";\nimport { getStatic } from \"@ethersproject/properties\";\nimport { ConnectionInfo } from \"@ethersproject/web\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\n\n// These are load-balancer-based application IDs\nconst defaultApplicationIds: Record<string, string> = {\n    homestead: \"6004bcd10040261633ade990\",\n    ropsten: \"6004bd4d0040261633ade991\",\n    rinkeby: \"6004bda20040261633ade994\",\n    goerli: \"6004bd860040261633ade992\",\n};\n\nexport class PocketProvider extends UrlJsonRpcProvider {\n    readonly applicationId: string;\n    readonly applicationSecretKey: string;\n    readonly loadBalancer: boolean;\n\n    constructor(network?: Networkish, apiKey?: any) {\n        // We need a bit of creativity in the constructor because\n        // Pocket uses different default API keys based on the network\n\n        if (apiKey == null) {\n            const n = getStatic<(network: Networkish) => Network>(new.target, \"getNetwork\")(network);\n            if (n) {\n                const applicationId = defaultApplicationIds[n.name];\n                if (applicationId) {\n                    apiKey = {\n                        applicationId: applicationId,\n                        loadBalancer: true\n                    };\n                }\n            }\n\n            // If there was any issue above, we don't know this network\n            if (apiKey == null) {\n                logger.throwError(\"unsupported network\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"network\",\n                    value: network\n                });\n            }\n\n        }\n\n        super(network, apiKey);\n    }\n\n    static getApiKey(apiKey: any): any {\n        // Most API Providers allow null to get the default configuration, but\n        // Pocket requires the network to decide the default provider, so we\n        // rely on hijacking the constructor to add a sensible default for us\n\n        if (apiKey == null) {\n            logger.throwArgumentError(\"PocketProvider.getApiKey does not support null apiKey\", \"apiKey\", apiKey);\n        }\n\n        const apiKeyObj: { applicationId: string, applicationSecretKey: string, loadBalancer: boolean } = {\n            applicationId: null,\n            loadBalancer: false,\n            applicationSecretKey: null\n        };\n\n        // Parse applicationId and applicationSecretKey\n        if (typeof (apiKey) === \"string\") {\n            apiKeyObj.applicationId = apiKey;\n\n        } else if (apiKey.applicationSecretKey != null) {\n            logger.assertArgument((typeof (apiKey.applicationId) === \"string\"),\n                \"applicationSecretKey requires an applicationId\", \"applicationId\", apiKey.applicationId);\n            logger.assertArgument((typeof (apiKey.applicationSecretKey) === \"string\"),\n                \"invalid applicationSecretKey\", \"applicationSecretKey\", \"[REDACTED]\");\n\n            apiKeyObj.applicationId = apiKey.applicationId;\n            apiKeyObj.applicationSecretKey = apiKey.applicationSecretKey;\n            apiKeyObj.loadBalancer = !!apiKey.loadBalancer;\n\n        } else if (apiKey.applicationId) {\n            logger.assertArgument((typeof (apiKey.applicationId) === \"string\"),\n                \"apiKey.applicationId must be a string\", \"apiKey.applicationId\", apiKey.applicationId);\n\n            apiKeyObj.applicationId = apiKey.applicationId;\n            apiKeyObj.loadBalancer = !!apiKey.loadBalancer;\n\n        } else {\n            logger.throwArgumentError(\"unsupported PocketProvider apiKey\", \"apiKey\", apiKey);\n        }\n\n        return apiKeyObj;\n    }\n\n    static getUrl(network: Network, apiKey: any): ConnectionInfo {\n        let host: string = null;\n        switch (network ? network.name : \"unknown\") {\n            case \"homestead\":\n                host = \"eth-mainnet.gateway.pokt.network\";\n                break;\n            case \"ropsten\":\n                host = \"eth-ropsten.gateway.pokt.network\";\n                break;\n            case \"rinkeby\":\n                host = \"eth-rinkeby.gateway.pokt.network\";\n                break;\n            case \"goerli\":\n                host = \"eth-goerli.gateway.pokt.network\";\n                break;\n            default:\n                logger.throwError(\"unsupported network\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"network\",\n                    value: network\n                });\n        }\n\n        let url = null;\n        if (apiKey.loadBalancer) {\n            url = `https:/\\/${ host }/v1/lb/${ apiKey.applicationId }`\n        } else {\n            url = `https:/\\/${ host }/v1/${ apiKey.applicationId }`\n        }\n\n        const connection: ConnectionInfo = { url };\n\n        // Initialize empty headers\n        connection.headers = {}\n\n        // Apply application secret key\n        if (apiKey.applicationSecretKey != null) {\n            connection.user = \"\";\n            connection.password = apiKey.applicationSecretKey\n        }\n\n        return connection;\n    }\n\n    isCommunityResource(): boolean {\n        return (this.applicationId === defaultApplicationIds[this.network.name]);\n    }\n}\n","\"use strict\";\n\nimport { Networkish } from \"@ethersproject/networks\";\nimport { deepCopy, defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\n\n// Exported Types\nexport type ExternalProvider = {\n    isMetaMask?: boolean;\n    isStatus?: boolean;\n    host?: string;\n    path?: string;\n    sendAsync?: (request: { method: string, params?: Array<any> }, callback: (error: any, response: any) => void) => void\n    send?: (request: { method: string, params?: Array<any> }, callback: (error: any, response: any) => void) => void\n    request?: (request: { method: string, params?: Array<any> }) => Promise<any>\n}\n\nlet _nextId = 1;\n\nexport type JsonRpcFetchFunc = (method: string, params?: Array<any>) => Promise<any>;\n\ntype Web3LegacySend = (request: any, callback: (error: Error, response: any) => void) => void;\n\nfunction buildWeb3LegacyFetcher(provider: ExternalProvider, sendFunc: Web3LegacySend) : JsonRpcFetchFunc {\n    const fetcher = \"Web3LegacyFetcher\";\n\n    return function(method: string, params: Array<any>): Promise<any> {\n        const request = {\n            method: method,\n            params: params,\n            id: (_nextId++),\n            jsonrpc: \"2.0\"\n        };\n\n        return new Promise((resolve, reject) => {\n            this.emit(\"debug\", {\n                action: \"request\",\n                fetcher,\n                request: deepCopy(request),\n                provider: this\n            });\n\n            sendFunc(request, (error, response) => {\n\n                if (error) {\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        fetcher,\n                        error,\n                        request,\n                        provider: this\n                    });\n\n                    return reject(error);\n                }\n\n                this.emit(\"debug\", {\n                    action: \"response\",\n                    fetcher,\n                    request,\n                    response,\n                    provider: this\n                });\n\n                if (response.error) {\n                    const error = new Error(response.error.message);\n                    (<any>error).code = response.error.code;\n                    (<any>error).data = response.error.data;\n                    return reject(error);\n                }\n\n                resolve(response.result);\n            });\n        });\n    }\n}\n\nfunction buildEip1193Fetcher(provider: ExternalProvider): JsonRpcFetchFunc {\n    return function(method: string, params: Array<any>): Promise<any> {\n        if (params == null) { params = [ ]; }\n\n        const request = { method, params };\n\n        this.emit(\"debug\", {\n            action: \"request\",\n            fetcher: \"Eip1193Fetcher\",\n            request: deepCopy(request),\n            provider: this\n        });\n\n        return provider.request(request).then((response) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                fetcher: \"Eip1193Fetcher\",\n                request,\n                response,\n                provider: this\n            });\n\n            return response;\n\n        }, (error) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                fetcher: \"Eip1193Fetcher\",\n                request,\n                error,\n                provider: this\n            });\n\n            throw error;\n        });\n    }\n}\n\nexport class Web3Provider extends JsonRpcProvider {\n    readonly provider: ExternalProvider;\n    readonly jsonRpcFetchFunc: JsonRpcFetchFunc;\n\n    constructor(provider: ExternalProvider | JsonRpcFetchFunc, network?: Networkish) {\n        logger.checkNew(new.target, Web3Provider);\n\n        if (provider == null) {\n            logger.throwArgumentError(\"missing provider\", \"provider\", provider);\n        }\n\n        let path: string = null;\n        let jsonRpcFetchFunc: JsonRpcFetchFunc = null;\n        let subprovider: ExternalProvider = null;\n\n        if (typeof(provider) === \"function\") {\n            path = \"unknown:\";\n            jsonRpcFetchFunc = provider;\n\n        } else {\n            path = provider.host || provider.path || \"\";\n            if (!path && provider.isMetaMask) {\n                path = \"metamask\";\n            }\n\n            subprovider = provider;\n\n            if (provider.request) {\n                if (path === \"\") { path = \"eip-1193:\"; }\n                jsonRpcFetchFunc = buildEip1193Fetcher(provider);\n            } else if (provider.sendAsync) {\n                jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.sendAsync.bind(provider));\n            } else if (provider.send) {\n                jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.send.bind(provider));\n            } else {\n                logger.throwArgumentError(\"unsupported provider\", \"provider\", provider);\n            }\n\n            if (!path) { path = \"unknown:\"; }\n        }\n\n        super(path, network);\n\n        defineReadOnly(this, \"jsonRpcFetchFunc\", jsonRpcFetchFunc);\n        defineReadOnly(this, \"provider\", subprovider);\n    }\n\n    send(method: string, params: Array<any>): Promise<any> {\n        return this.jsonRpcFetchFunc(method, params);\n    }\n}\n","\"use strict\";\n\nimport {\n    Block,\n    BlockTag,\n    EventType,\n    FeeData,\n    Filter,\n    Log,\n    Listener,\n    Provider,\n    TransactionReceipt,\n    TransactionRequest,\n    TransactionResponse\n} from \"@ethersproject/abstract-provider\";\n\nimport { getNetwork } from \"@ethersproject/networks\";\nimport { Network, Networkish } from \"@ethersproject/networks\";\n\nimport { BaseProvider, EnsProvider, EnsResolver, Resolver } from \"./base-provider\";\n\nimport { AlchemyProvider, AlchemyWebSocketProvider } from \"./alchemy-provider\";\nimport { CloudflareProvider } from \"./cloudflare-provider\";\nimport { EtherscanProvider } from \"./etherscan-provider\";\nimport { FallbackProvider, FallbackProviderConfig } from \"./fallback-provider\";\nimport { IpcProvider } from \"./ipc-provider\";\nimport { InfuraProvider, InfuraWebSocketProvider } from \"./infura-provider\";\nimport { JsonRpcProvider, JsonRpcSigner } from \"./json-rpc-provider\";\nimport { JsonRpcBatchProvider } from \"./json-rpc-batch-provider\";\nimport { NodesmithProvider } from \"./nodesmith-provider\";\nimport { PocketProvider } from \"./pocket-provider\";\nimport { StaticJsonRpcProvider, UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\nimport { Web3Provider } from \"./web3-provider\";\nimport { WebSocketProvider } from \"./websocket-provider\";\nimport { ExternalProvider, JsonRpcFetchFunc } from \"./web3-provider\";\n\nimport { CommunityResourcable, Formatter, isCommunityResourcable, isCommunityResource, showThrottleMessage } from \"./formatter\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n////////////////////////\n// Helper Functions\n\nfunction getDefaultProvider(network?: Networkish, options?: any): BaseProvider {\n    if (network == null) { network = \"homestead\"; }\n\n    // If passed a URL, figure out the right type of provider based on the scheme\n    if (typeof(network) === \"string\") {\n        // @TODO: Add support for IpcProvider; maybe if it ends in \".ipc\"?\n\n        // Handle http and ws (and their secure variants)\n        const match = network.match(/^(ws|http)s?:/i);\n        if (match) {\n            switch (match[1]) {\n                case \"http\":\n                    return new JsonRpcProvider(network);\n                case \"ws\":\n                    return new WebSocketProvider(network);\n                default:\n                    logger.throwArgumentError(\"unsupported URL scheme\", \"network\", network);\n            }\n        }\n    }\n\n    const n = getNetwork(network);\n    if (!n || !n._defaultProvider) {\n        logger.throwError(\"unsupported getDefaultProvider network\", Logger.errors.NETWORK_ERROR, {\n            operation: \"getDefaultProvider\",\n            network: network\n        });\n    }\n\n    return n._defaultProvider({\n        FallbackProvider,\n\n        AlchemyProvider,\n        CloudflareProvider,\n        EtherscanProvider,\n        InfuraProvider,\n        JsonRpcProvider,\n        NodesmithProvider,\n        PocketProvider,\n        Web3Provider,\n\n        IpcProvider,\n    }, options);\n}\n\n////////////////////////\n// Exports\n\nexport {\n\n    // Abstract Providers (or Abstract-ish)\n    Provider,\n    BaseProvider,\n\n    Resolver,\n\n    UrlJsonRpcProvider,\n\n    ///////////////////////\n    // Concrete Providers\n\n    FallbackProvider,\n\n    AlchemyProvider,\n    AlchemyWebSocketProvider,\n    CloudflareProvider,\n    EtherscanProvider,\n    InfuraProvider,\n    InfuraWebSocketProvider,\n    JsonRpcProvider,\n    JsonRpcBatchProvider,\n    NodesmithProvider,\n    PocketProvider,\n    StaticJsonRpcProvider,\n    Web3Provider,\n    WebSocketProvider,\n\n    IpcProvider,\n\n\n    ///////////////////////\n    // Signer\n\n    JsonRpcSigner,\n\n\n    ///////////////////////\n    // Functions\n\n    getDefaultProvider,\n    getNetwork,\n    isCommunityResource,\n    isCommunityResourcable,\n    showThrottleMessage,\n\n\n    ///////////////////////\n    // Objects\n\n    Formatter,\n\n\n    ///////////////////////\n    // Types\n\n    Block,\n    BlockTag,\n    EventType,\n    FeeData,\n    Filter,\n    Log,\n    Listener,\n    TransactionReceipt,\n    TransactionRequest,\n    TransactionResponse,\n\n    ExternalProvider,\n    JsonRpcFetchFunc,\n\n    FallbackProviderConfig,\n\n    Network,\n    Networkish,\n\n    EnsProvider,\n    EnsResolver,\n\n    CommunityResourcable\n};\n\n","\"use strict\";\n\nimport { HashZero } from \"@ethersproject/constants\";\nimport { arrayify, BytesLike, concat, hexlify } from \"@ethersproject/bytes\";\n\nimport { toUtf8Bytes, toUtf8String } from \"./utf8\";\n\n\nexport function formatBytes32String(text: string): string {\n\n    // Get the bytes\n    const bytes = toUtf8Bytes(text);\n\n    // Check we have room for null-termination\n    if (bytes.length > 31) { throw new Error(\"bytes32 string must be less than 32 bytes\"); }\n\n    // Zero-pad (implicitly null-terminates)\n    return hexlify(concat([ bytes, HashZero ]).slice(0, 32));\n}\n\nexport function parseBytes32String(bytes: BytesLike): string {\n    const data = arrayify(bytes);\n\n    // Must be 32 bytes with a null-termination\n    if (data.length !== 32) { throw new Error(\"invalid bytes32 - not 32 bytes long\"); }\n    if (data[31] !== 0) { throw new Error(\"invalid bytes32 string - no null terminator\"); }\n\n    // Find the null termination\n    let length = 31;\n    while (data[length - 1] === 0) { length--; }\n\n    // Determine the string value\n    return toUtf8String(data.slice(0, length));\n}\n\n","export const version = \"units/5.5.0\";\n","\"use strict\";\n\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { formatFixed, parseFixed } from \"@ethersproject/bignumber\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst names = [\n    \"wei\",\n    \"kwei\",\n    \"mwei\",\n    \"gwei\",\n    \"szabo\",\n    \"finney\",\n    \"ether\",\n];\n\n\n// Some environments have issues with RegEx that contain back-tracking, so we cannot\n// use them.\nexport function commify(value: string | number): string {\n    const comps = String(value).split(\".\");\n\n    if (comps.length > 2 || !comps[0].match(/^-?[0-9]*$/) || (comps[1] && !comps[1].match(/^[0-9]*$/)) || value === \".\" || value === \"-.\") {\n        logger.throwArgumentError(\"invalid value\", \"value\", value);\n    }\n\n    // Make sure we have at least one whole digit (0 if none)\n    let whole = comps[0];\n\n    let negative = \"\";\n    if (whole.substring(0, 1) === \"-\") {\n        negative = \"-\";\n        whole = whole.substring(1);\n    }\n\n    // Make sure we have at least 1 whole digit with no leading zeros\n    while (whole.substring(0, 1) === \"0\") { whole = whole.substring(1); }\n    if (whole === \"\") { whole = \"0\"; }\n\n    let suffix = \"\";\n    if (comps.length === 2) { suffix = \".\" + (comps[1] || \"0\"); }\n    while (suffix.length > 2 && suffix[suffix.length - 1] === \"0\") {\n        suffix = suffix.substring(0, suffix.length - 1);\n    }\n\n    const formatted = [];\n    while (whole.length) {\n        if (whole.length <= 3) {\n            formatted.unshift(whole);\n            break;\n        } else {\n            const index = whole.length - 3;\n            formatted.unshift(whole.substring(index));\n            whole = whole.substring(0, index);\n        }\n    }\n\n    return negative + formatted.join(\",\") + suffix;\n}\n\nexport function formatUnits(value: BigNumberish, unitName?: string | BigNumberish): string {\n    if (typeof(unitName) === \"string\") {\n        const index = names.indexOf(unitName);\n        if (index !== -1) { unitName = 3 * index; }\n    }\n    return formatFixed(value, (unitName != null) ? unitName: 18);\n}\n\nexport function parseUnits(value: string, unitName?: BigNumberish): BigNumber {\n    if (typeof(value) !== \"string\") {\n        logger.throwArgumentError(\"value must be a string\", \"value\", value);\n    }\n    if (typeof(unitName) === \"string\") {\n        const index = names.indexOf(unitName);\n        if (index !== -1) { unitName = 3 * index; }\n    }\n    return parseFixed(value, (unitName != null) ? unitName: 18);\n}\n\nexport function formatEther(wei: BigNumberish): string {\n    return formatUnits(wei, 18);\n}\n\nexport function parseEther(ether: string): BigNumber {\n    return parseUnits(ether, 18);\n}\n\n","export const version = \"ethers/5.5.4\";\n","\"use strict\";\n\nimport { BaseContract, Contract, ContractFactory } from \"@ethersproject/contracts\";\n\nimport { BigNumber, FixedNumber } from \"@ethersproject/bignumber\";\n\nimport { Signer, VoidSigner } from \"@ethersproject/abstract-signer\";\nimport { Wallet } from \"@ethersproject/wallet\";\n\nimport * as constants from \"@ethersproject/constants\";\n\nimport * as providers from \"@ethersproject/providers\";\nimport { getDefaultProvider } from \"@ethersproject/providers\";\n\nimport { Wordlist, wordlists} from \"@ethersproject/wordlists\";\n\nimport * as utils from \"./utils\";\n\nimport { ErrorCode as errors, Logger } from \"@ethersproject/logger\";\n\n////////////////////////\n// Types\n\nimport { BigNumberish } from \"@ethersproject/bignumber\";\nimport { Bytes, BytesLike, Signature } from \"@ethersproject/bytes\";\nimport { Transaction, UnsignedTransaction } from \"@ethersproject/transactions\";\n\n\n////////////////////////\n// Compile-Time Constants\n\n// This is generated by \"npm run dist\"\nimport { version } from \"./_version\";\n\nconst logger = new Logger(version);\n\n////////////////////////\n// Types\n\nimport {\n    ContractFunction,\n    ContractReceipt,\n    ContractTransaction,\n\n    Event,\n    EventFilter,\n\n    Overrides,\n    PayableOverrides,\n    CallOverrides,\n\n    PopulatedTransaction,\n\n    ContractInterface\n} from \"@ethersproject/contracts\";\n\n\n////////////////////////\n// Exports\n\nexport {\n    Signer,\n\n    Wallet,\n    VoidSigner,\n\n    getDefaultProvider,\n    providers,\n\n    BaseContract,\n    Contract,\n    ContractFactory,\n\n    BigNumber,\n    FixedNumber,\n\n    constants,\n    errors,\n\n    logger,\n\n    utils,\n\n    wordlists,\n\n\n    ////////////////////////\n    // Compile-Time Constants\n\n    version,\n\n\n    ////////////////////////\n    // Types\n\n    ContractFunction,\n    ContractReceipt,\n    ContractTransaction,\n    Event,\n    EventFilter,\n\n    Overrides,\n    PayableOverrides,\n    CallOverrides,\n\n    PopulatedTransaction,\n\n    ContractInterface,\n\n    BigNumberish,\n\n    Bytes,\n    BytesLike,\n\n    Signature,\n\n    Transaction,\n    UnsignedTransaction,\n\n    Wordlist\n};\n\n","\"use strict\";\n\n// To modify this file, you must update ./misc/admin/lib/cmds/update-exports.js\n\nimport * as ethers from \"./ethers\";\n\ntry {\n    const anyGlobal = (window as any);\n\n    if (anyGlobal._ethers == null) {\n        anyGlobal._ethers = ethers;\n    }\n} catch (error) { }\n\nexport { ethers };\n\nexport {\n    Signer,\n\n    Wallet,\n    VoidSigner,\n\n    getDefaultProvider,\n    providers,\n\n    BaseContract,\n    Contract,\n    ContractFactory,\n\n    BigNumber,\n    FixedNumber,\n\n    constants,\n    errors,\n\n    logger,\n\n    utils,\n\n    wordlists,\n\n\n    ////////////////////////\n    // Compile-Time Constants\n\n    version,\n\n\n    ////////////////////////\n    // Types\n\n    ContractFunction,\n    ContractReceipt,\n    ContractTransaction,\n    Event,\n    EventFilter,\n\n    Overrides,\n    PayableOverrides,\n    CallOverrides,\n\n    PopulatedTransaction,\n\n    ContractInterface,\n\n    BigNumberish,\n\n    Bytes,\n    BytesLike,\n\n    Signature,\n\n    Transaction,\n    UnsignedTransaction,\n\n    Wordlist\n} from \"./ethers\";\n"],"names":["root","checkInt","value","parseInt","checkInts","arrayish","length","i","coerceArray","arg","copy","buffer","ArrayBuffer","isView","name","slice","Array","prototype","call","isArray","Error","Uint8Array","createArray","copyArray","sourceArray","targetArray","targetStart","sourceStart","sourceEnd","set","convertUtf8","toBytes","text","result","encodeURI","c","charCodeAt","push","substr","fromBytes","bytes","String","fromCharCode","join","convertHex","Hex","v","numberOfRounds","rcon","S","Si","T1","T2","T3","T4","T5","T6","T7","T8","U1","U2","U3","U4","convertToInt32","AES","key","this","Object","defineProperty","_prepare","rounds","_Ke","_Kd","index","roundKeyCount","KC","tk","tt","rconpointer","t","r","encrypt","plaintext","a","decrypt","ciphertext","ModeOfOperationECB","description","_aes","block","ModeOfOperationCBC","iv","_lastCipherblock","j","ModeOfOperationCFB","segmentSize","_shiftRegister","xorSegment","encrypted","ModeOfOperationOFB","_lastPrecipher","_lastPrecipherIndex","Counter","initialValue","_counter","setValue","setBytes","increment","ModeOfOperationCTR","counter","_remainingCounter","_remainingCounterIndex","aesjs","ModeOfOperation","ecb","cbc","cfb","ofb","ctr","utils","hex","utf8","padding","pkcs7","pad","data","padder","strip","_arrayTest","module","exports","logger","Logger","ripemd160","hash","update","arrayify","digest","sha256","sha512","computeHmac","algorithm","SupportedAlgorithm","throwError","operation","regexBytes","RegExp","regexNumber","regexArray","_pack","type","zeroPad","toUtf8Bytes","match","size","throwArgumentError","BigNumber","toTwos","byteLength","substring","baseType","forEach","concat","pack","types","values","tight","hexlify","keccak256","hashKeccak256","hashSha256","ALPHABET","ALPHABET_MAP","z","x","charAt","undefined","TypeError","polymodStep","pre","b","prefixChk","prefix","chk","__decode","str","LIMIT","lowered","toLowerCase","uppered","toUpperCase","split","lastIndexOf","wordChars","words","convert","inBits","outBits","bits","maxV","decodeUnsafe","res","apply","arguments","decode","encode","toWordsUnsafe","toWords","fromWordsUnsafe","fromWords","version","Coder","localName","dynamic","message","Writer","wordSize","defineReadOnly","_data","_dataLength","_padding","hexConcat","writer","_writeData","paddingOffset","offset","_getValue","Reader","coerceFunc","allowLoose","_offset","_coerceFunc","coerce","loose","alignedLength","Math","ceil","_peekBytes","readBytes","toNumber","AddressCoder","getAddress","error","_throwError","writeValue","reader","hexZeroPad","readValue","toHexString","AnonymousCoder","coder","defaultValue","coders","arrayValues","unique","map","argument","staticWriter","dynamicWriter","updateFuncs","dynamicOffset","updateFunc","writeUpdatableValue","baseOffset","func","appendWriter","unpack","baseReader","subReader","offsetReader","code","uniqueNames","reduce","accum","enumerable","get","freeze","ArrayCoder","defaultChild","count","checkArgumentCount","BooleanCoder","isZero","DynamicBytesCoder","writeBytes","BytesCoder","FixedBytesCoder","NullCoder","NumberCoder","signed","maxUintValue","MaxUint256","bounds","mask","gt","lt","add","One","mul","NegativeOne","Zero","fromTwos","StringCoder","toUtf8String","TupleCoder","_constructorGuard","ModifiersBytes","calldata","memory","storage","ModifiersNest","checkModifier","indexOf","populate","object","params","FormatTypes","sighash","minimal","full","json","paramTypeArray","ParamType","constructorGuard","arrayLength","arrayChildren","fromObject","components","_isParamType","format","indexed","comp","JSON","parse","stringify","allowIndexed","fromString","isParamType","verifyType","node","param","originalParam","newNode","parent","state","allowType","replace","allowParams","child","allowName","allowArray","sibling","readArray","parseParamType","parseParams","allowIndex","trim","depth","splitNesting","Fragment","_isFragment","isFragment","FunctionFragment","EventFragment","ConstructorFragment","ErrorFragment","anonymous","inputs","input","isEventFragment","verifyIdentifier","regexParen","modifier","warn","parseGas","gas","comps","parseModifiers","constant","payable","stateMutability","console","log","verifyState","isConstructorFragment","parens","outputs","output","toString","isFunctionFragment","returns","checkForbidden","fragment","sig","isErrorFragment","regexIdentifier","paramTypeBytes","paramTypeNumber","AbiCoder","checkNew","_getCoder","component","_getWordSize","from","_getWriter","_getReader","defaultAbiCoder","LogDescription","Description","TransactionDescription","ErrorDescription","Indexed","_isIndexed","BuiltinErrors","signature","reason","wrapAccessError","property","wrap","Interface","fragments","abi","filter","getStatic","bucket","deploy","functions","events","errors","nameOrSignatureOrSighash","isHexString","getSighash","matching","keys","f","nameOrSignatureOrTopic","topichash","getEventTopic","constructor","getFunction","getError","_","eventFragment","getEvent","_abiCoder","_encodeParams","_decodeParams","functionFragment","errorArgs","errorName","errorSignature","selector","builtin","method","topics","encodeTopic","id","pop","dataTypes","dataValues","topicHash","expected","nonIndexed","resultIndexed","resultNonIndexed","nonIndexedIndex","indexedIndex","tx","args","topic","decodeEventLog","hexData","errorFragment","address","hexDataSlice","_isInterface","ForkEvent","_isForkEvent","Provider","checkAbstract","resolveProperties","getBlock","gasPrice","getGasPrice","catch","maxFeePerGas","maxPriorityFeePerGas","baseFeePerGas","eventName","listener","on","off","_isProvider","allowedTransactionKeys","forwardErrors","Signer","blockTag","_checkProvider","provider","getBalance","getTransactionCount","transaction","checkTransaction","estimateGas","populateTransaction","signTransaction","signedTx","sendTransaction","getNetwork","network","chainId","getFeeData","resolveName","shallowCopy","Promise","all","resolve","then","to","__awaiter","hasEip1559","feeData","nonce","gasLimit","getChainId","results","_isSigner","VoidSigner","_fail","domain","accessList","customData","resolver","nameOrPromise","resolveAddresses","paramType","reject","makeError","contract","overrides","signer","override","check","resolvedAddress","resolved","interface","encodeFunctionData","ro","accessListify","intrinsic","roValue","leftovers","l","addContractWait","wait","bind","confirmations","receipt","logs","event","deepCopy","parsed","parseLog","e","eventSignature","removeListener","blockHash","getTransaction","transactionHash","getTransactionReceipt","buildCall","collapseSimple","signerOrProvider","deployTransaction","_deployed","decodeFunctionResult","buildDefault","txRequest","buildSend","getEventTag","RunningEvent","tag","_listeners","once","done","item","listenerCount","argsCopy","setTimeout","ErrorRunningEvent","FragmentRunningEvent","contractInterface","decodeError","checkErrors","path","childPath","checkResultErrors","WildcardRunningEvent","BaseContract","addressOrName","Contract","isSigner","isProvider","uniqueFilters","filters","encodeFilterTopics","uniqueSignatures","callStatic","buildPopulate","buildEstimate","signatures","_deployedPromise","getCode","contractAddress","deployed","runningEvent","_runningEvents","_normalizeRunningEvent","emit","_wrappedEmits","_checkRunningEvents","prepareEvent","addListener","wrappedEmit","_wrapEvent","getEmit","fromBlockOrBlockhash","toBlock","_getRunningEvent","fromBlock","getLogs","_addEventListener","run","listeners","removeAllListeners","getContractAddress","isInterface","isIndexed","ContractFactory","bytecode","bytecodeHex","isBytes","encodeDeploy","unsignedTx","getDeployTransaction","getContract","compilerOutput","evm","getInterface","throwFault","fault","zeros","getMultiplier","decimals","formatFixed","multiplier","negative","fraction","mod","whole","div","parseFixed","wholeValue","fractionValue","wei","FixedFormat","width","_multiplier","FixedNumber","_hex","_value","_isFixedNumber","other","_checkFormat","fromValue","sub","hasFraction","isNegative","subUnsafe","ONE","toFormat","addUnsafe","factor","bump","BUMP","mulUnsafe","floor","divUnsafe","parseFloat","isBigNumberish","fixedFormat","numeric","decimal","hashMessage","fill","hexTrue","hexFalse","domainFieldTypes","verifyingContract","salt","domainFieldNames","checkString","domainChecks","getBaseEncoder","boundsUpper","boundsLower","padOffset","hexPadRight","encodeType","fields","TypedDataEncoder","links","parents","subtypes","field","primaryTypes","n","checkCircular","found","subtype","primaryType","st","sort","_types","encoder","_encoderCache","_getEncoder","subEncoder","getEncoder","encodedType","unshift","encodeData","hashStruct","callback","_visit","domainFields","EIP712Domain","hashDomain","ensCache","visit","domainValues","domainTypes","typesWithDomain","BaseX","alphabet","_alphabetMap","source","digits","carry","base","string","k","_leader","q","byte","reverse","Base58","pbkdf2","password","iterations","keylen","hashAlgorithm","hLen","T","DK","block1","U","destPos","len","Wordlist","locale","mnemonic","wordlist","word","getWord","getWordIndex","lang","loadWords","langEn","LangEn","register","wordlists","en","N","MasterSecret","HardenedBit","getUpperMask","bytes32","base58check","getWordlist","defaultPath","HDNode","privateKey","publicKey","parentFingerprint","chainCode","mnemonicOrPath","signingKey","SigningKey","compressedPublicKey","computeAddress","I","IL","IR","ki","Ki","_addPoint","srcMnemonic","phrase","fingerprint","shift","_derive","seed","seedArray","entropyToMnemonic","mnemonicToEntropy","_fromSeed","mnemonicToSeed","extendedKey","UnicodeNormalizationForm","checkNormalize","entropy","normalize","bit","entropyBits","checksumMask","indices","remainingBits","checksumBits","checksum","isValidMnemonic","getAccountPath","anyGlobal","self","window","global","getGlobal","crypto","msCrypto","randomBytes","getRandomValues","looseArrayify","hexString","zpad","getPassword","searchPath","currentChild","matchingChild","uuidV4","CrowdsaleAccount","_isCrowdsaleAccount","ethaddr","encseed","encryptedSeed","aesCbc","aes","seedHex","seedHexBytes","isCrowdsaleWallet","isKeystoreWallet","getJsonWalletAddress","hasMnemonic","KeystoreAccount","_isKeystoreAccount","_getAccount","aesCtr","_decrypt","mnemonicKey","account","mnemonicCiphertext","mnemonicIv","mnemonicCounter","mnemonicAesCtr","fromMnemonic","derivePath","pbkdf2Sync","passwordBytes","dkLen","prfFunc","_pbkdf2","_computeKdfKey","pbkdf2Func","scryptFunc","progressCallback","kdf","p","prf","decryptJsonWallet","decryptCrowdsale","scrypt","decryptKeystore","decryptJsonWalletSync","decryptKeystoreSync","Wallet","curve","_mnemonic","_signingKey","signDigest","serialize","joinSignature","_TypedDataEncoder","populated","options","client","uuidRandom","uuid","derivedKey","macPrefix","mac","Crypto","cipher","cipherparams","kdfparams","dklen","now","Date","timestamp","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","gethFilename","encryptKeystore","extraEntropy","verifyMessage","recoverAddress","verifyTypedData","AddressZero","HashZero","EtherSymbol","ethDefaultProvider","providers","providerList","InfuraProvider","infura","EtherscanProvider","etherscan","AlchemyProvider","alchemy","PocketProvider","CloudflareProvider","FallbackProvider","quorum","renetwork","etcDefaultProvider","url","JsonRpcProvider","homestead","ensAddress","_defaultProvider","ropsten","classicMordor","networks","unspecified","mainnet","morden","testnet","rinkeby","kovan","goerli","kintsugi","classic","classicMorden","classicTestnet","classicKotti","xdai","matic","maticmum","optimism","arbitrum","bnb","bnbt","standard","defaultProvider","createTable","lo","pair","createRangeTable","hi","h","matchMap","ranges","range","d","Table_A_1_ranges","Table_B_1_flags","Table_B_2_ranges","s","Table_B_2_lut_abs","Table_B_2_lut_rel","Table_B_2_complex","Table_C_ranges","nameprep","codes","toUtf8CodePoints","codesTableB2","codepoint","_nameprepTableB2","_toUtf8String","Zeros","Partition","isValidName","namehash","current","partition","label","textData","atob","btoa","getUrl","href","request","headers","body","skipFetchSetup","mode","cache","credentials","redirect","referrer","fetch","response","arrayBuffer","statusCode","status","statusMessage","statusText","staller","duration","bodyify","isBytesLike","_fetchData","connection","processFunc","attemptLimit","throttleLimit","assertArgument","throttleCallback","throttleSlotInterval","allow304","timeout","allowGzip","user","allowInsecureAuthentication","authorization","base64Encode","reData","dataMatch","base64Decode","requestBody","requestMethod","flatHeaders","header","runningTimeout","timer","promise","cancel","clearTimeout","runningFetch","attempt","location","tryAgain","stall","retryAfter","random","pow","serverError","throttleRetry","race","fetchJson","updated","poll","ceiling","interval","retryLimit","oncePoll","onceBlock","Formatter","formats","getDefaultFormats","bigNumber","number","allowNull","blockNumber","transactionIndex","uint256","creates","raw","transactionRequest","receiptLog","arrayOf","logIndex","gasUsed","logsBloom","cumulativeGasUsed","effectiveGasPrice","parentHash","difficulty","miner","extraData","transactions","blockWithTransactions","transactionResponse","filterLog","removed","boolean","allowFalsish","strict","hexValue","hexDataLength","author","_difficulty","_block","networkId","parseTransaction","byzantium","checkKey","checkValue","nullValue","replaceValue","array","isCommunityResourcable","isCommunityResource","throttleMessage","showThrottleMessage","checkTopic","serializeTopics","sorted","isForkEvent","getTime","PollableEvents","Event","coinInfos","symbol","p2pkh","p2sh","ilk","bytes32ify","base58Encode","matcherIpfs","matchers","_parseString","_parseBytes","getIpfsLink","link","Resolver","formatter","parameters","CALL_EXCEPTION","coinType","hexBytes","coinInfo","bech32","callAddress","_fetchBytes","_getAddress","linkage","content","getText","avatar","scheme","_resolvedAddress","owner","addr","tokenId","tokenOwner","balance","metadataUrl","metadata","imageUrl","image","ipfs","swarm","keyBytes","defaultFormatter","nextPollId","BaseProvider","_events","_emitted","getFormatter","anyNetwork","detectNetwork","_networkPromise","_ready","knownNetwork","_maxInternalBlockNumber","_lastBlockNumber","_pollingInterval","_fastQueryDate","_network","maxAge","_internalBlockNumber","internalBlockNumber","respTime","reqTime","checkInternalBlockNumber","perform","networkError","_setFastBlockNumber","pollId","runners","_getInternalBlockNumber","pollingInterval","abs","previousBlockNumber","eventBlockNumber","runner","polling","currentNetwork","_fastBlockNumber","_fastBlockNumberPromise","detectedNetwork","_poller","setInterval","_bootstrapPoll","clearInterval","getBlockNumber","_waitForTransaction","replaceable","cancelFuncs","alreadyDone","minedHandler","lastBlockNumber","startBlock","scannedBlock","replaceHandler","mined","getBlockWithTransactions","ti","waitForTransaction","eq","cancelled","replacement","_wrapTransaction","unref","_getBlockTag","position","expectedHash","returnedHash","confirms","signedTransaction","hexTx","_getTransactionRequest","blockHashOrBlockTag","includeTransactions","blockWithTxs","_getBlock","_getFilter","_getResolver","getResolver","reverseName","resolverAddress","nameOrAddress","getAvatar","pollable","_startEvent","stopped","eventTag","_stopEvent","errorGas","checkError","responseText","getResult","payload","getLowerCase","JsonRpcSigner","addressOrIndex","UncheckedJsonRpcSigner","_address","_index","send","accounts","fromAddress","estimate","sender","hexlifyTransaction","sendUncheckedTransaction","networkOrReady","_nextId","_eventLoopCache","_cache","_uncachedDetectNetwork","getSigner","connectUnchecked","jsonrpc","action","prepareRequest","_startPending","_pendingFilter","pendingFilter","filterId","hashes","seq","allowExtra","allowed","checkProperties","WS","WebSocket","NextId","WebSocketProvider","_wsReady","_websocket","onopen","_requests","onmessage","messageEvent","_subs","subscription","fauxPoll","_detectNetwork","rid","subIdPromise","_subIds","subId","_subscribe","emitReceipt","readyState","CONNECTING","onerror","close","StaticJsonRpcProvider","_super","UrlJsonRpcProvider","apiKey","defaultApiKey","AlchemyWebSocketProvider","host","getTransactionPostData","maxFeePerGs","storageKeys","getJsonResult","checkLogTag","getBaseUrl","query","baseUrl","apikey","post","getPostUrl","getPostData","procFunc","payloadStr","txhash","postData","topic0","blocks","ethusd","endBlock","startblock","endblock","timeStamp","shuffled","tmp","checkNetworks","median","maxDelta","middle","nextRid","getPromise","ForwardErrors","ForwardProperties","exposeDebugConfig","config","weight","start","getProcessFunc","configs","_highestBlockNumber","tally","normalizedTally","waitForSync","getRunner","currentBlockNumber","getEtherPrice","getStorageAt","providerConfigs","configOrProvider","stallTimeout","priority","total","first","t0","inflightWeight","backend","waiting","errorCode","props","IpcProvider","defaultProjectId","InfuraWebSocketProvider","projectId","projectSecret","apiKeyObj","JsonRpcBatchProvider","_pendingBatch","inflightRequest","_pendingBatchAggregator","batch","inflight","NodesmithProvider","defaultApplicationIds","applicationId","loadBalancer","applicationSecretKey","buildWeb3LegacyFetcher","sendFunc","fetcher","Web3Provider","jsonRpcFetchFunc","subprovider","isMetaMask","buildEip1193Fetcher","sendAsync","getDefaultProvider","formatBytes32String","parseBytes32String","names","commify","suffix","formatted","formatUnits","unitName","parseUnits","formatEther","parseEther","ether","_ethers","ethers"],"sourceRoot":""}